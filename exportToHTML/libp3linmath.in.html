<html>
<head>
<title>libp3linmath.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3linmath.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">12 libp3linmath 4 Ns0b 12 panda3d.core </span>
<span class="s0">1594</span>
<span class="s0">2011 11 MathNumbers 0 260 3605 24 MathNumbers::MathNumbers 0 2 1 2 0</span>
<span class="s0">112</span>
<span class="s0">inline MathNumbers::MathNumbers(void) = default;</span>
<span class="s0">inline MathNumbers::MathNumbers(MathNumbers const &amp;) = default;</span>

<span class="s0">2012 12 ~MathNumbers 0 516 3605 25 MathNumbers::~MathNumbers 0 0 0</span>
<span class="s0">32</span>
<span class="s0">MathNumbers::~MathNumbers(void);</span>

<span class="s0">2013 9 deg_2_rad 0 1 0 9 deg_2_rad 0 2 1921 1922 0</span>
<span class="s0">67</span>
<span class="s0">inline double deg_2_rad(double f);</span>
<span class="s0">inline float deg_2_rad(float f);</span>

<span class="s0">2014 9 rad_2_deg 0 1 0 9 rad_2_deg 0 2 1923 1924 0</span>
<span class="s0">67</span>
<span class="s0">inline double rad_2_deg(double f);</span>
<span class="s0">inline float rad_2_deg(float f);</span>

<span class="s0">2015 10 LVecBase2f 0 260 3606 22 LVecBase2f::LVecBase2f 0 4 3 4 5 6 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">205</span>
<span class="s0">inline LVecBase2f::LVecBase2f(void) = default;</span>
<span class="s0">inline LVecBase2f::LVecBase2f(float fill_value);</span>
<span class="s0">inline LVecBase2f::LVecBase2f(float x, float y);</span>
<span class="s0">inline LVecBase2f::LVecBase2f(LVecBase2f const &amp;) = default;</span>

<span class="s0">2016 12 operator new 0 4 3606 24 LVecBase2f::operator new 0 1 7 0</span>
<span class="s0">124</span>
<span class="s0">inline void *LVecBase2f::operator new(std::size_t size);</span>
<span class="s0">inline void *LVecBase2f::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2017 15 operator delete 0 4 3606 27 LVecBase2f::operator delete 0 0 0</span>
<span class="s0">108</span>
<span class="s0">inline void LVecBase2f::operator delete(void *ptr);</span>
<span class="s0">inline void LVecBase2f::operator delete(void *, void *);</span>

<span class="s0">2018 12 validate_ptr 0 4 3606 24 LVecBase2f::validate_ptr 0 0 0</span>
<span class="s0">61</span>
<span class="s0">static inline bool LVecBase2f::validate_ptr(void const *ptr);</span>

<span class="s0">2019 10 operator = 0 4 3606 22 LVecBase2f::operator = 0 2 8 9 0</span>
<span class="s0">119</span>
<span class="s0">void LVecBase2f::operator =(LVecBase2f const &amp;copy) = default;</span>
<span class="s0">void LVecBase2f::operator =(float fill_value) = default;</span>

<span class="s0">2020 4 zero 0 4 3606 16 LVecBase2f::zero 0 1 10 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVecBase2f const &amp;LVecBase2f::zero(void);</span>

<span class="s0">2021 6 unit_x 0 4 3606 18 LVecBase2f::unit_x 0 1 11 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase2f const &amp;LVecBase2f::unit_x(void);</span>

<span class="s0">2022 6 unit_y 0 4 3606 18 LVecBase2f::unit_y 0 1 12 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase2f const &amp;LVecBase2f::unit_y(void);</span>

<span class="s0">2023 10 __reduce__ 0 4 3606 22 LVecBase2f::__reduce__ 0 1 13 0</span>
<span class="s0">62</span>
<span class="s0">inline PyObject *LVecBase2f::__reduce__(PyObject *self) const;</span>

<span class="s0">2024 11 __getattr__ 0 4 3606 23 LVecBase2f::__getattr__ 0 1 14 0</span>
<span class="s0">93</span>
<span class="s0">inline PyObject *LVecBase2f::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2025 11 __setattr__ 0 4 3606 23 LVecBase2f::__setattr__ 0 1 15 0</span>
<span class="s0">99</span>
<span class="s0">inline int LVecBase2f::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2026 11 operator [] 0 4 3606 23 LVecBase2f::operator [] 0 2 16 17 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline float LVecBase2f::operator [](int i) const;</span>
<span class="s0">inline float &amp;LVecBase2f::operator [](int i);</span>

<span class="s0">2027 4 size 0 4 3606 16 LVecBase2f::size 0 1 18 0</span>
<span class="s0">44</span>
<span class="s0">static constexpr int LVecBase2f::size(void);</span>

<span class="s0">2028 6 is_nan 0 4 3606 18 LVecBase2f::is_nan 0 1 19 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool LVecBase2f::is_nan(void) const;</span>

<span class="s0">2029 8 get_cell 0 4 3606 20 LVecBase2f::get_cell 0 1 20 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline float LVecBase2f::get_cell(int i) const;</span>

<span class="s0">2030 8 set_cell 0 4 3606 20 LVecBase2f::set_cell 0 1 21 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void LVecBase2f::set_cell(int i, float value);</span>

<span class="s0">2031 5 get_x 0 4 3606 17 LVecBase2f::get_x 0 1 22 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline float LVecBase2f::get_x(void) const;</span>

<span class="s0">2032 5 get_y 0 4 3606 17 LVecBase2f::get_y 0 1 23 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline float LVecBase2f::get_y(void) const;</span>

<span class="s0">2033 5 set_x 0 4 3606 17 LVecBase2f::set_x 0 1 24 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase2f::set_x(float value);</span>

<span class="s0">2034 5 set_y 0 4 3606 17 LVecBase2f::set_y 0 1 25 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase2f::set_y(float value);</span>

<span class="s0">2035 11 add_to_cell 0 4 3606 23 LVecBase2f::add_to_cell 0 1 26 164</span>
<span class="s0">// These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages:</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase2f::add_to_cell(int i, float value);</span>

<span class="s0">2036 5 add_x 0 4 3606 17 LVecBase2f::add_x 0 1 27 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase2f::add_x(float value);</span>

<span class="s0">2037 5 add_y 0 4 3606 17 LVecBase2f::add_y 0 1 28 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase2f::add_y(float value);</span>

<span class="s0">2038 8 get_data 0 4 3606 20 LVecBase2f::get_data 0 1 29 155</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the two data elements in the vector.</span>
 <span class="s0">* The next element occupies the next position consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline float const *LVecBase2f::get_data(void) const;</span>

<span class="s0">2039 18 get_num_components 0 4 3606 30 LVecBase2f::get_num_components 0 1 30 0</span>
<span class="s0">58</span>
<span class="s0">static constexpr int LVecBase2f::get_num_components(void);</span>

<span class="s0">2040 4 fill 0 4 3606 16 LVecBase2f::fill 0 1 31 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void LVecBase2f::fill(float fill_value);</span>

<span class="s0">2041 3 set 0 4 3606 15 LVecBase2f::set 0 1 32 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void LVecBase2f::set(float x, float y);</span>

<span class="s0">2042 3 dot 0 4 3606 15 LVecBase2f::dot 0 1 33 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline float LVecBase2f::dot(LVecBase2f const &amp;other) const;</span>

<span class="s0">2043 14 length_squared 0 4 3606 26 LVecBase2f::length_squared 0 1 34 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline float LVecBase2f::length_squared(void) const;</span>

<span class="s0">2044 6 length 0 4 3606 18 LVecBase2f::length 0 1 35 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline float LVecBase2f::length(void) const;</span>

<span class="s0">2045 9 normalize 0 4 3606 21 LVecBase2f::normalize 0 1 36 127</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline bool LVecBase2f::normalize(void);</span>

<span class="s0">2046 10 normalized 0 4 3606 22 LVecBase2f::normalized 0 1 37 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase2f LVecBase2f::normalized(void) const;</span>

<span class="s0">2047 7 project 0 4 3606 19 LVecBase2f::project 0 1 38 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LVecBase2f LVecBase2f::project(LVecBase2f const &amp;onto) const;</span>

<span class="s0">2048 10 operator &lt; 0 4 3606 22 LVecBase2f::operator &lt; 0 1 39 0</span>
<span class="s0">66</span>
<span class="s0">inline bool LVecBase2f::operator &lt;(LVecBase2f const &amp;other) const;</span>

<span class="s0">2049 11 operator == 0 4 3606 23 LVecBase2f::operator == 0 1 40 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase2f::operator ==(LVecBase2f const &amp;other) const;</span>

<span class="s0">2050 11 operator != 0 4 3606 23 LVecBase2f::operator != 0 1 41 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase2f::operator !=(LVecBase2f const &amp;other) const;</span>

<span class="s0">2051 10 compare_to 0 4 3606 22 LVecBase2f::compare_to 0 2 42 43 332</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">inline int LVecBase2f::compare_to(LVecBase2f const &amp;other) const;</span>
<span class="s0">inline int LVecBase2f::compare_to(LVecBase2f const &amp;other, float threshold) const;</span>

<span class="s0">2052 8 get_hash 0 4 3606 20 LVecBase2f::get_hash 0 2 44 45 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">inline std::size_t LVecBase2f::get_hash(void) const;</span>
<span class="s0">inline std::size_t LVecBase2f::get_hash(float threshold) const;</span>

<span class="s0">2053 8 add_hash 0 4 3606 20 LVecBase2f::add_hash 0 2 46 47 100</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">146</span>
<span class="s0">inline std::size_t LVecBase2f::add_hash(std::size_t hash) const;</span>
<span class="s0">inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const;</span>

<span class="s0">2054 13 generate_hash 0 4 3606 25 LVecBase2f::generate_hash 0 2 48 49 120</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">170</span>
<span class="s0">inline void LVecBase2f::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>
<span class="s0">inline void LVecBase2f::generate_hash(ChecksumHashGenerator &amp;hashgen, float threshold) const;</span>

<span class="s0">2055 10 operator - 0 68 3606 22 LVecBase2f::operator - 0 1 50 0</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase2f LVecBase2f::operator -(void) const;</span>

<span class="s0">2056 10 operator + 0 4 3606 22 LVecBase2f::operator + 0 1 51 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase2f LVecBase2f::operator +(LVecBase2f const &amp;other) const;</span>

<span class="s0">2057 10 operator - 0 4 3606 22 LVecBase2f::operator - 0 1 52 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase2f LVecBase2f::operator -(LVecBase2f const &amp;other) const;</span>

<span class="s0">2058 10 operator * 0 4 3606 22 LVecBase2f::operator * 0 1 53 0</span>
<span class="s0">61</span>
<span class="s0">inline LVecBase2f LVecBase2f::operator *(float scalar) const;</span>

<span class="s0">2059 10 operator / 0 4 3606 22 LVecBase2f::operator / 0 1 54 0</span>
<span class="s0">61</span>
<span class="s0">inline LVecBase2f LVecBase2f::operator /(float scalar) const;</span>

<span class="s0">2060 11 operator += 0 4 3606 23 LVecBase2f::operator += 0 1 55 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase2f::operator +=(LVecBase2f const &amp;other);</span>

<span class="s0">2061 11 operator -= 0 4 3606 23 LVecBase2f::operator -= 0 1 56 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase2f::operator -=(LVecBase2f const &amp;other);</span>

<span class="s0">2062 11 operator *= 0 4 3606 23 LVecBase2f::operator *= 0 1 57 0</span>
<span class="s0">50</span>
<span class="s0">inline void LVecBase2f::operator *=(float scalar);</span>

<span class="s0">2063 11 operator /= 0 4 3606 23 LVecBase2f::operator /= 0 1 58 0</span>
<span class="s0">50</span>
<span class="s0">inline void LVecBase2f::operator /=(float scalar);</span>

<span class="s0">2064 18 componentwise_mult 0 4 3606 30 LVecBase2f::componentwise_mult 0 1 59 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase2f::componentwise_mult(LVecBase2f const &amp;other);</span>

<span class="s0">2065 12 __floordiv__ 0 4 3606 24 LVecBase2f::__floordiv__ 0 1 60 0</span>
<span class="s0">78</span>
<span class="s0">inline PyObject *LVecBase2f::__floordiv__(PyObject *self, float scalar) const;</span>

<span class="s0">2066 13 __ifloordiv__ 0 4 3606 25 LVecBase2f::__ifloordiv__ 0 1 61 0</span>
<span class="s0">73</span>
<span class="s0">inline PyObject *LVecBase2f::__ifloordiv__(PyObject *self, float scalar);</span>

<span class="s0">2067 7 __pow__ 0 4 3606 19 LVecBase2f::__pow__ 0 1 62 0</span>
<span class="s0">75</span>
<span class="s0">inline PyObject *LVecBase2f::__pow__(PyObject *self, float exponent) const;</span>

<span class="s0">2068 8 __ipow__ 0 4 3606 20 LVecBase2f::__ipow__ 0 1 63 0</span>
<span class="s0">70</span>
<span class="s0">inline PyObject *LVecBase2f::__ipow__(PyObject *self, float exponent);</span>

<span class="s0">2069 9 __round__ 0 4 3606 21 LVecBase2f::__round__ 0 1 64 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase2f::__round__(PyObject *self);</span>

<span class="s0">2070 9 __floor__ 0 4 3606 21 LVecBase2f::__floor__ 0 1 65 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase2f::__floor__(PyObject *self);</span>

<span class="s0">2071 8 __ceil__ 0 4 3606 20 LVecBase2f::__ceil__ 0 1 66 0</span>
<span class="s0">54</span>
<span class="s0">inline PyObject *LVecBase2f::__ceil__(PyObject *self);</span>

<span class="s0">2072 4 fmax 0 4 3606 16 LVecBase2f::fmax 0 1 67 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &amp;other) const;</span>

<span class="s0">2073 4 fmin 0 4 3606 16 LVecBase2f::fmin 0 1 68 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &amp;other) const;</span>

<span class="s0">2074 12 almost_equal 0 4 3606 24 LVecBase2f::almost_equal 0 2 69 70 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">154</span>
<span class="s0">inline bool LVecBase2f::almost_equal(LVecBase2f const &amp;other, float threshold) const;</span>
<span class="s0">inline bool LVecBase2f::almost_equal(LVecBase2f const &amp;other) const;</span>

<span class="s0">2075 6 output 0 4 3606 18 LVecBase2f::output 0 1 71 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase2f::output(std::ostream &amp;out) const;</span>

<span class="s0">2076 8 __repr__ 0 4 3606 20 LVecBase2f::__repr__ 0 1 72 0</span>
<span class="s0">52</span>
<span class="s0">inline std::string LVecBase2f::__repr__(void) const;</span>

<span class="s0">2077 20 write_datagram_fixed 0 4 3606 32 LVecBase2f::write_datagram_fixed 0 1 73 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void LVecBase2f::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">2078 19 read_datagram_fixed 0 4 3606 31 LVecBase2f::read_datagram_fixed 0 1 74 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void LVecBase2f::read_datagram_fixed(DatagramIterator &amp;source);</span>

<span class="s0">2079 14 write_datagram 0 4 3606 26 LVecBase2f::write_datagram 0 1 75 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase2f::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">2080 13 read_datagram 0 4 3606 25 LVecBase2f::read_datagram 0 1 76 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LVecBase2f::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">2081 14 get_class_type 0 4 3606 26 LVecBase2f::get_class_type 0 1 77 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle LVecBase2f::get_class_type(void);</span>

<span class="s0">2082 11 ~LVecBase2f 0 516 3606 23 LVecBase2f::~LVecBase2f 0 0 0</span>
<span class="s0">30</span>
<span class="s0">LVecBase2f::~LVecBase2f(void);</span>

<span class="s0">2083 10 LVecBase2d 0 260 3609 22 LVecBase2d::LVecBase2d 0 4 78 79 80 81 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">208</span>
<span class="s0">inline LVecBase2d::LVecBase2d(void) = default;</span>
<span class="s0">inline LVecBase2d::LVecBase2d(double fill_value);</span>
<span class="s0">inline LVecBase2d::LVecBase2d(double x, double y);</span>
<span class="s0">inline LVecBase2d::LVecBase2d(LVecBase2d const &amp;) = default;</span>

<span class="s0">2084 12 operator new 0 4 3609 24 LVecBase2d::operator new 0 1 82 0</span>
<span class="s0">124</span>
<span class="s0">inline void *LVecBase2d::operator new(std::size_t size);</span>
<span class="s0">inline void *LVecBase2d::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2085 15 operator delete 0 4 3609 27 LVecBase2d::operator delete 0 0 0</span>
<span class="s0">108</span>
<span class="s0">inline void LVecBase2d::operator delete(void *ptr);</span>
<span class="s0">inline void LVecBase2d::operator delete(void *, void *);</span>

<span class="s0">2086 12 validate_ptr 0 4 3609 24 LVecBase2d::validate_ptr 0 0 0</span>
<span class="s0">61</span>
<span class="s0">static inline bool LVecBase2d::validate_ptr(void const *ptr);</span>

<span class="s0">2087 10 operator = 0 4 3609 22 LVecBase2d::operator = 0 2 83 84 0</span>
<span class="s0">120</span>
<span class="s0">void LVecBase2d::operator =(LVecBase2d const &amp;copy) = default;</span>
<span class="s0">void LVecBase2d::operator =(double fill_value) = default;</span>

<span class="s0">2088 4 zero 0 4 3609 16 LVecBase2d::zero 0 1 85 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVecBase2d const &amp;LVecBase2d::zero(void);</span>

<span class="s0">2089 6 unit_x 0 4 3609 18 LVecBase2d::unit_x 0 1 86 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase2d const &amp;LVecBase2d::unit_x(void);</span>

<span class="s0">2090 6 unit_y 0 4 3609 18 LVecBase2d::unit_y 0 1 87 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase2d const &amp;LVecBase2d::unit_y(void);</span>

<span class="s0">2091 10 __reduce__ 0 4 3609 22 LVecBase2d::__reduce__ 0 1 88 0</span>
<span class="s0">62</span>
<span class="s0">inline PyObject *LVecBase2d::__reduce__(PyObject *self) const;</span>

<span class="s0">2092 11 __getattr__ 0 4 3609 23 LVecBase2d::__getattr__ 0 1 89 0</span>
<span class="s0">93</span>
<span class="s0">inline PyObject *LVecBase2d::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2093 11 __setattr__ 0 4 3609 23 LVecBase2d::__setattr__ 0 1 90 0</span>
<span class="s0">99</span>
<span class="s0">inline int LVecBase2d::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2094 11 operator [] 0 4 3609 23 LVecBase2d::operator [] 0 2 91 92 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline double LVecBase2d::operator [](int i) const;</span>
<span class="s0">inline double &amp;LVecBase2d::operator [](int i);</span>

<span class="s0">2095 4 size 0 4 3609 16 LVecBase2d::size 0 1 93 0</span>
<span class="s0">44</span>
<span class="s0">static constexpr int LVecBase2d::size(void);</span>

<span class="s0">2096 6 is_nan 0 4 3609 18 LVecBase2d::is_nan 0 1 94 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool LVecBase2d::is_nan(void) const;</span>

<span class="s0">2097 8 get_cell 0 4 3609 20 LVecBase2d::get_cell 0 1 95 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline double LVecBase2d::get_cell(int i) const;</span>

<span class="s0">2098 8 set_cell 0 4 3609 20 LVecBase2d::set_cell 0 1 96 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void LVecBase2d::set_cell(int i, double value);</span>

<span class="s0">2099 5 get_x 0 4 3609 17 LVecBase2d::get_x 0 1 97 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double LVecBase2d::get_x(void) const;</span>

<span class="s0">2100 5 get_y 0 4 3609 17 LVecBase2d::get_y 0 1 98 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double LVecBase2d::get_y(void) const;</span>

<span class="s0">2101 5 set_x 0 4 3609 17 LVecBase2d::set_x 0 1 99 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase2d::set_x(double value);</span>

<span class="s0">2102 5 set_y 0 4 3609 17 LVecBase2d::set_y 0 1 100 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase2d::set_y(double value);</span>

<span class="s0">2103 11 add_to_cell 0 4 3609 23 LVecBase2d::add_to_cell 0 1 101 164</span>
<span class="s0">// These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages:</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void LVecBase2d::add_to_cell(int i, double value);</span>

<span class="s0">2104 5 add_x 0 4 3609 17 LVecBase2d::add_x 0 1 102 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase2d::add_x(double value);</span>

<span class="s0">2105 5 add_y 0 4 3609 17 LVecBase2d::add_y 0 1 103 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase2d::add_y(double value);</span>

<span class="s0">2106 8 get_data 0 4 3609 20 LVecBase2d::get_data 0 1 104 155</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the two data elements in the vector.</span>
 <span class="s0">* The next element occupies the next position consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline double const *LVecBase2d::get_data(void) const;</span>

<span class="s0">2107 18 get_num_components 0 4 3609 30 LVecBase2d::get_num_components 0 1 105 0</span>
<span class="s0">58</span>
<span class="s0">static constexpr int LVecBase2d::get_num_components(void);</span>

<span class="s0">2108 4 fill 0 4 3609 16 LVecBase2d::fill 0 1 106 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void LVecBase2d::fill(double fill_value);</span>

<span class="s0">2109 3 set 0 4 3609 15 LVecBase2d::set 0 1 107 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void LVecBase2d::set(double x, double y);</span>

<span class="s0">2110 3 dot 0 4 3609 15 LVecBase2d::dot 0 1 108 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline double LVecBase2d::dot(LVecBase2d const &amp;other) const;</span>

<span class="s0">2111 14 length_squared 0 4 3609 26 LVecBase2d::length_squared 0 1 109 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline double LVecBase2d::length_squared(void) const;</span>

<span class="s0">2112 6 length 0 4 3609 18 LVecBase2d::length 0 1 110 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline double LVecBase2d::length(void) const;</span>

<span class="s0">2113 9 normalize 0 4 3609 21 LVecBase2d::normalize 0 1 111 127</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline bool LVecBase2d::normalize(void);</span>

<span class="s0">2114 10 normalized 0 4 3609 22 LVecBase2d::normalized 0 1 112 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase2d LVecBase2d::normalized(void) const;</span>

<span class="s0">2115 7 project 0 4 3609 19 LVecBase2d::project 0 1 113 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LVecBase2d LVecBase2d::project(LVecBase2d const &amp;onto) const;</span>

<span class="s0">2116 10 operator &lt; 0 4 3609 22 LVecBase2d::operator &lt; 0 1 114 0</span>
<span class="s0">66</span>
<span class="s0">inline bool LVecBase2d::operator &lt;(LVecBase2d const &amp;other) const;</span>

<span class="s0">2117 11 operator == 0 4 3609 23 LVecBase2d::operator == 0 1 115 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase2d::operator ==(LVecBase2d const &amp;other) const;</span>

<span class="s0">2118 11 operator != 0 4 3609 23 LVecBase2d::operator != 0 1 116 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase2d::operator !=(LVecBase2d const &amp;other) const;</span>

<span class="s0">2119 10 compare_to 0 4 3609 22 LVecBase2d::compare_to 0 2 117 118 332</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/</span>
<span class="s0">149</span>
<span class="s0">inline int LVecBase2d::compare_to(LVecBase2d const &amp;other) const;</span>
<span class="s0">inline int LVecBase2d::compare_to(LVecBase2d const &amp;other, double threshold) const;</span>

<span class="s0">2120 8 get_hash 0 4 3609 20 LVecBase2d::get_hash 0 2 119 120 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">inline std::size_t LVecBase2d::get_hash(void) const;</span>
<span class="s0">inline std::size_t LVecBase2d::get_hash(double threshold) const;</span>

<span class="s0">2121 8 add_hash 0 4 3609 20 LVecBase2d::add_hash 0 2 121 122 100</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">147</span>
<span class="s0">inline std::size_t LVecBase2d::add_hash(std::size_t hash) const;</span>
<span class="s0">inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const;</span>

<span class="s0">2122 13 generate_hash 0 4 3609 25 LVecBase2d::generate_hash 0 2 123 124 120</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">171</span>
<span class="s0">inline void LVecBase2d::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>
<span class="s0">inline void LVecBase2d::generate_hash(ChecksumHashGenerator &amp;hashgen, double threshold) const;</span>

<span class="s0">2123 10 operator - 0 68 3609 22 LVecBase2d::operator - 0 1 125 0</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase2d LVecBase2d::operator -(void) const;</span>

<span class="s0">2124 10 operator + 0 4 3609 22 LVecBase2d::operator + 0 1 126 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase2d LVecBase2d::operator +(LVecBase2d const &amp;other) const;</span>

<span class="s0">2125 10 operator - 0 4 3609 22 LVecBase2d::operator - 0 1 127 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase2d LVecBase2d::operator -(LVecBase2d const &amp;other) const;</span>

<span class="s0">2126 10 operator * 0 4 3609 22 LVecBase2d::operator * 0 1 128 0</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase2d LVecBase2d::operator *(double scalar) const;</span>

<span class="s0">2127 10 operator / 0 4 3609 22 LVecBase2d::operator / 0 1 129 0</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase2d LVecBase2d::operator /(double scalar) const;</span>

<span class="s0">2128 11 operator += 0 4 3609 23 LVecBase2d::operator += 0 1 130 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase2d::operator +=(LVecBase2d const &amp;other);</span>

<span class="s0">2129 11 operator -= 0 4 3609 23 LVecBase2d::operator -= 0 1 131 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase2d::operator -=(LVecBase2d const &amp;other);</span>

<span class="s0">2130 11 operator *= 0 4 3609 23 LVecBase2d::operator *= 0 1 132 0</span>
<span class="s0">51</span>
<span class="s0">inline void LVecBase2d::operator *=(double scalar);</span>

<span class="s0">2131 11 operator /= 0 4 3609 23 LVecBase2d::operator /= 0 1 133 0</span>
<span class="s0">51</span>
<span class="s0">inline void LVecBase2d::operator /=(double scalar);</span>

<span class="s0">2132 18 componentwise_mult 0 4 3609 30 LVecBase2d::componentwise_mult 0 1 134 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase2d::componentwise_mult(LVecBase2d const &amp;other);</span>

<span class="s0">2133 12 __floordiv__ 0 4 3609 24 LVecBase2d::__floordiv__ 0 1 135 0</span>
<span class="s0">79</span>
<span class="s0">inline PyObject *LVecBase2d::__floordiv__(PyObject *self, double scalar) const;</span>

<span class="s0">2134 13 __ifloordiv__ 0 4 3609 25 LVecBase2d::__ifloordiv__ 0 1 136 0</span>
<span class="s0">74</span>
<span class="s0">inline PyObject *LVecBase2d::__ifloordiv__(PyObject *self, double scalar);</span>

<span class="s0">2135 7 __pow__ 0 4 3609 19 LVecBase2d::__pow__ 0 1 137 0</span>
<span class="s0">76</span>
<span class="s0">inline PyObject *LVecBase2d::__pow__(PyObject *self, double exponent) const;</span>

<span class="s0">2136 8 __ipow__ 0 4 3609 20 LVecBase2d::__ipow__ 0 1 138 0</span>
<span class="s0">71</span>
<span class="s0">inline PyObject *LVecBase2d::__ipow__(PyObject *self, double exponent);</span>

<span class="s0">2137 9 __round__ 0 4 3609 21 LVecBase2d::__round__ 0 1 139 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase2d::__round__(PyObject *self);</span>

<span class="s0">2138 9 __floor__ 0 4 3609 21 LVecBase2d::__floor__ 0 1 140 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase2d::__floor__(PyObject *self);</span>

<span class="s0">2139 8 __ceil__ 0 4 3609 20 LVecBase2d::__ceil__ 0 1 141 0</span>
<span class="s0">54</span>
<span class="s0">inline PyObject *LVecBase2d::__ceil__(PyObject *self);</span>

<span class="s0">2140 4 fmax 0 4 3609 16 LVecBase2d::fmax 0 1 142 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &amp;other) const;</span>

<span class="s0">2141 4 fmin 0 4 3609 16 LVecBase2d::fmin 0 1 143 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &amp;other) const;</span>

<span class="s0">2142 12 almost_equal 0 4 3609 24 LVecBase2d::almost_equal 0 2 144 145 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">155</span>
<span class="s0">inline bool LVecBase2d::almost_equal(LVecBase2d const &amp;other, double threshold) const;</span>
<span class="s0">inline bool LVecBase2d::almost_equal(LVecBase2d const &amp;other) const;</span>

<span class="s0">2143 6 output 0 4 3609 18 LVecBase2d::output 0 1 146 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase2d::output(std::ostream &amp;out) const;</span>

<span class="s0">2144 8 __repr__ 0 4 3609 20 LVecBase2d::__repr__ 0 1 147 0</span>
<span class="s0">52</span>
<span class="s0">inline std::string LVecBase2d::__repr__(void) const;</span>

<span class="s0">2145 20 write_datagram_fixed 0 4 3609 32 LVecBase2d::write_datagram_fixed 0 1 148 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void LVecBase2d::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">2146 19 read_datagram_fixed 0 4 3609 31 LVecBase2d::read_datagram_fixed 0 1 149 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void LVecBase2d::read_datagram_fixed(DatagramIterator &amp;source);</span>

<span class="s0">2147 14 write_datagram 0 4 3609 26 LVecBase2d::write_datagram 0 1 150 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase2d::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">2148 13 read_datagram 0 4 3609 25 LVecBase2d::read_datagram 0 1 151 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LVecBase2d::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">2149 14 get_class_type 0 4 3609 26 LVecBase2d::get_class_type 0 1 152 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle LVecBase2d::get_class_type(void);</span>

<span class="s0">2150 11 ~LVecBase2d 0 516 3609 23 LVecBase2d::~LVecBase2d 0 0 0</span>
<span class="s0">30</span>
<span class="s0">LVecBase2d::~LVecBase2d(void);</span>

<span class="s0">2151 10 LVecBase2i 0 260 3612 22 LVecBase2i::LVecBase2i 0 4 153 154 155 156 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">199</span>
<span class="s0">inline LVecBase2i::LVecBase2i(void) = default;</span>
<span class="s0">inline LVecBase2i::LVecBase2i(int fill_value);</span>
<span class="s0">inline LVecBase2i::LVecBase2i(int x, int y);</span>
<span class="s0">inline LVecBase2i::LVecBase2i(LVecBase2i const &amp;) = default;</span>

<span class="s0">2152 12 operator new 0 4 3612 24 LVecBase2i::operator new 0 1 157 0</span>
<span class="s0">124</span>
<span class="s0">inline void *LVecBase2i::operator new(std::size_t size);</span>
<span class="s0">inline void *LVecBase2i::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2153 15 operator delete 0 4 3612 27 LVecBase2i::operator delete 0 0 0</span>
<span class="s0">108</span>
<span class="s0">inline void LVecBase2i::operator delete(void *ptr);</span>
<span class="s0">inline void LVecBase2i::operator delete(void *, void *);</span>

<span class="s0">2154 12 validate_ptr 0 4 3612 24 LVecBase2i::validate_ptr 0 0 0</span>
<span class="s0">61</span>
<span class="s0">static inline bool LVecBase2i::validate_ptr(void const *ptr);</span>

<span class="s0">2155 10 operator = 0 4 3612 22 LVecBase2i::operator = 0 2 158 159 0</span>
<span class="s0">117</span>
<span class="s0">void LVecBase2i::operator =(LVecBase2i const &amp;copy) = default;</span>
<span class="s0">void LVecBase2i::operator =(int fill_value) = default;</span>

<span class="s0">2156 4 zero 0 4 3612 16 LVecBase2i::zero 0 1 160 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVecBase2i const &amp;LVecBase2i::zero(void);</span>

<span class="s0">2157 6 unit_x 0 4 3612 18 LVecBase2i::unit_x 0 1 161 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase2i const &amp;LVecBase2i::unit_x(void);</span>

<span class="s0">2158 6 unit_y 0 4 3612 18 LVecBase2i::unit_y 0 1 162 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase2i const &amp;LVecBase2i::unit_y(void);</span>

<span class="s0">2159 10 __reduce__ 0 4 3612 22 LVecBase2i::__reduce__ 0 1 163 0</span>
<span class="s0">62</span>
<span class="s0">inline PyObject *LVecBase2i::__reduce__(PyObject *self) const;</span>

<span class="s0">2160 11 __getattr__ 0 4 3612 23 LVecBase2i::__getattr__ 0 1 164 0</span>
<span class="s0">93</span>
<span class="s0">inline PyObject *LVecBase2i::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2161 11 __setattr__ 0 4 3612 23 LVecBase2i::__setattr__ 0 1 165 0</span>
<span class="s0">99</span>
<span class="s0">inline int LVecBase2i::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2162 11 operator [] 0 4 3612 23 LVecBase2i::operator [] 0 2 166 167 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">inline int LVecBase2i::operator [](int i) const;</span>
<span class="s0">inline int &amp;LVecBase2i::operator [](int i);</span>

<span class="s0">2163 4 size 0 4 3612 16 LVecBase2i::size 0 1 168 0</span>
<span class="s0">44</span>
<span class="s0">static constexpr int LVecBase2i::size(void);</span>

<span class="s0">2164 6 is_nan 0 4 3612 18 LVecBase2i::is_nan 0 1 169 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool LVecBase2i::is_nan(void) const;</span>

<span class="s0">2165 8 get_cell 0 4 3612 20 LVecBase2i::get_cell 0 1 170 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline int LVecBase2i::get_cell(int i) const;</span>

<span class="s0">2166 8 set_cell 0 4 3612 20 LVecBase2i::set_cell 0 1 171 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void LVecBase2i::set_cell(int i, int value);</span>

<span class="s0">2167 5 get_x 0 4 3612 17 LVecBase2i::get_x 0 1 172 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline int LVecBase2i::get_x(void) const;</span>

<span class="s0">2168 5 get_y 0 4 3612 17 LVecBase2i::get_y 0 1 173 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline int LVecBase2i::get_y(void) const;</span>

<span class="s0">2169 5 set_x 0 4 3612 17 LVecBase2i::set_x 0 1 174 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase2i::set_x(int value);</span>

<span class="s0">2170 5 set_y 0 4 3612 17 LVecBase2i::set_y 0 1 175 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase2i::set_y(int value);</span>

<span class="s0">2171 11 add_to_cell 0 4 3612 23 LVecBase2i::add_to_cell 0 1 176 164</span>
<span class="s0">// These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages:</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void LVecBase2i::add_to_cell(int i, int value);</span>

<span class="s0">2172 5 add_x 0 4 3612 17 LVecBase2i::add_x 0 1 177 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase2i::add_x(int value);</span>

<span class="s0">2173 5 add_y 0 4 3612 17 LVecBase2i::add_y 0 1 178 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase2i::add_y(int value);</span>

<span class="s0">2174 8 get_data 0 4 3612 20 LVecBase2i::get_data 0 1 179 155</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the two data elements in the vector.</span>
 <span class="s0">* The next element occupies the next position consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int const *LVecBase2i::get_data(void) const;</span>

<span class="s0">2175 18 get_num_components 0 4 3612 30 LVecBase2i::get_num_components 0 1 180 0</span>
<span class="s0">58</span>
<span class="s0">static constexpr int LVecBase2i::get_num_components(void);</span>

<span class="s0">2176 4 fill 0 4 3612 16 LVecBase2i::fill 0 1 181 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void LVecBase2i::fill(int fill_value);</span>

<span class="s0">2177 3 set 0 4 3612 15 LVecBase2i::set 0 1 182 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void LVecBase2i::set(int x, int y);</span>

<span class="s0">2178 3 dot 0 4 3612 15 LVecBase2i::dot 0 1 183 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int LVecBase2i::dot(LVecBase2i const &amp;other) const;</span>

<span class="s0">2179 14 length_squared 0 4 3612 26 LVecBase2i::length_squared 0 1 184 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int LVecBase2i::length_squared(void) const;</span>

<span class="s0">2180 10 operator &lt; 0 4 3612 22 LVecBase2i::operator &lt; 0 1 185 0</span>
<span class="s0">66</span>
<span class="s0">inline bool LVecBase2i::operator &lt;(LVecBase2i const &amp;other) const;</span>

<span class="s0">2181 11 operator == 0 4 3612 23 LVecBase2i::operator == 0 1 186 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase2i::operator ==(LVecBase2i const &amp;other) const;</span>

<span class="s0">2182 11 operator != 0 4 3612 23 LVecBase2i::operator != 0 1 187 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase2i::operator !=(LVecBase2i const &amp;other) const;</span>

<span class="s0">2183 10 compare_to 0 4 3612 22 LVecBase2i::compare_to 0 1 188 97</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int LVecBase2i::compare_to(LVecBase2i const &amp;other) const;</span>

<span class="s0">2184 8 get_hash 0 4 3612 20 LVecBase2i::get_hash 0 1 189 49</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline std::size_t LVecBase2i::get_hash(void) const;</span>

<span class="s0">2185 8 add_hash 0 4 3612 20 LVecBase2i::add_hash 0 1 190 49</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::size_t LVecBase2i::add_hash(std::size_t hash) const;</span>

<span class="s0">2186 13 generate_hash 0 4 3612 25 LVecBase2i::generate_hash 0 1 191 59</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void LVecBase2i::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>

<span class="s0">2187 10 operator - 0 68 3612 22 LVecBase2i::operator - 0 1 192 0</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase2i LVecBase2i::operator -(void) const;</span>

<span class="s0">2188 10 operator + 0 4 3612 22 LVecBase2i::operator + 0 1 193 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase2i LVecBase2i::operator +(LVecBase2i const &amp;other) const;</span>

<span class="s0">2189 10 operator - 0 4 3612 22 LVecBase2i::operator - 0 1 194 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase2i LVecBase2i::operator -(LVecBase2i const &amp;other) const;</span>

<span class="s0">2190 10 operator * 0 4 3612 22 LVecBase2i::operator * 0 1 195 0</span>
<span class="s0">59</span>
<span class="s0">inline LVecBase2i LVecBase2i::operator *(int scalar) const;</span>

<span class="s0">2191 10 operator / 0 4 3612 22 LVecBase2i::operator / 0 1 196 0</span>
<span class="s0">59</span>
<span class="s0">inline LVecBase2i LVecBase2i::operator /(int scalar) const;</span>

<span class="s0">2192 11 operator += 0 4 3612 23 LVecBase2i::operator += 0 1 197 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase2i::operator +=(LVecBase2i const &amp;other);</span>

<span class="s0">2193 11 operator -= 0 4 3612 23 LVecBase2i::operator -= 0 1 198 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase2i::operator -=(LVecBase2i const &amp;other);</span>

<span class="s0">2194 11 operator *= 0 4 3612 23 LVecBase2i::operator *= 0 1 199 0</span>
<span class="s0">48</span>
<span class="s0">inline void LVecBase2i::operator *=(int scalar);</span>

<span class="s0">2195 11 operator /= 0 4 3612 23 LVecBase2i::operator /= 0 1 200 0</span>
<span class="s0">48</span>
<span class="s0">inline void LVecBase2i::operator /=(int scalar);</span>

<span class="s0">2196 18 componentwise_mult 0 4 3612 30 LVecBase2i::componentwise_mult 0 1 201 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase2i::componentwise_mult(LVecBase2i const &amp;other);</span>

<span class="s0">2197 12 __floordiv__ 0 4 3612 24 LVecBase2i::__floordiv__ 0 1 202 0</span>
<span class="s0">76</span>
<span class="s0">inline PyObject *LVecBase2i::__floordiv__(PyObject *self, int scalar) const;</span>

<span class="s0">2198 13 __ifloordiv__ 0 4 3612 25 LVecBase2i::__ifloordiv__ 0 1 203 0</span>
<span class="s0">71</span>
<span class="s0">inline PyObject *LVecBase2i::__ifloordiv__(PyObject *self, int scalar);</span>

<span class="s0">2199 7 __pow__ 0 4 3612 19 LVecBase2i::__pow__ 0 1 204 0</span>
<span class="s0">73</span>
<span class="s0">inline PyObject *LVecBase2i::__pow__(PyObject *self, int exponent) const;</span>

<span class="s0">2200 8 __ipow__ 0 4 3612 20 LVecBase2i::__ipow__ 0 1 205 0</span>
<span class="s0">68</span>
<span class="s0">inline PyObject *LVecBase2i::__ipow__(PyObject *self, int exponent);</span>

<span class="s0">2201 9 __round__ 0 4 3612 21 LVecBase2i::__round__ 0 1 206 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase2i::__round__(PyObject *self);</span>

<span class="s0">2202 9 __floor__ 0 4 3612 21 LVecBase2i::__floor__ 0 1 207 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase2i::__floor__(PyObject *self);</span>

<span class="s0">2203 8 __ceil__ 0 4 3612 20 LVecBase2i::__ceil__ 0 1 208 0</span>
<span class="s0">54</span>
<span class="s0">inline PyObject *LVecBase2i::__ceil__(PyObject *self);</span>

<span class="s0">2204 4 fmax 0 4 3612 16 LVecBase2i::fmax 0 1 209 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &amp;other) const;</span>

<span class="s0">2205 4 fmin 0 4 3612 16 LVecBase2i::fmin 0 1 210 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &amp;other) const;</span>

<span class="s0">2206 12 almost_equal 0 4 3612 24 LVecBase2i::almost_equal 0 2 211 212 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">152</span>
<span class="s0">inline bool LVecBase2i::almost_equal(LVecBase2i const &amp;other, int threshold) const;</span>
<span class="s0">inline bool LVecBase2i::almost_equal(LVecBase2i const &amp;other) const;</span>

<span class="s0">2207 6 output 0 4 3612 18 LVecBase2i::output 0 1 213 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase2i::output(std::ostream &amp;out) const;</span>

<span class="s0">2208 8 __repr__ 0 4 3612 20 LVecBase2i::__repr__ 0 1 214 0</span>
<span class="s0">52</span>
<span class="s0">inline std::string LVecBase2i::__repr__(void) const;</span>

<span class="s0">2209 20 write_datagram_fixed 0 4 3612 32 LVecBase2i::write_datagram_fixed 0 1 215 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void LVecBase2i::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">2210 19 read_datagram_fixed 0 4 3612 31 LVecBase2i::read_datagram_fixed 0 1 216 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void LVecBase2i::read_datagram_fixed(DatagramIterator &amp;source);</span>

<span class="s0">2211 14 write_datagram 0 4 3612 26 LVecBase2i::write_datagram 0 1 217 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase2i::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">2212 13 read_datagram 0 4 3612 25 LVecBase2i::read_datagram 0 1 218 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LVecBase2i::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">2213 14 get_class_type 0 4 3612 26 LVecBase2i::get_class_type 0 1 219 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle LVecBase2i::get_class_type(void);</span>

<span class="s0">2214 11 ~LVecBase2i 0 516 3612 23 LVecBase2i::~LVecBase2i 0 0 0</span>
<span class="s0">30</span>
<span class="s0">LVecBase2i::~LVecBase2i(void);</span>

<span class="s0">2215 9 LVector2f 0 260 3615 20 LVector2f::LVector2f 0 5 220 221 222 223 224 146</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LVector2 from a LVecBase2</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LVector2 with all components set to the fill value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">249</span>
<span class="s0">inline LVector2f::LVector2f(void) = default;</span>
<span class="s0">inline LVector2f::LVector2f(LVecBase2f const &amp;copy);</span>
<span class="s0">inline LVector2f::LVector2f(float fill_value);</span>
<span class="s0">inline LVector2f::LVector2f(float x, float y);</span>
<span class="s0">inline LVector2f::LVector2f(LVector2f const &amp;) = default;</span>

<span class="s0">2216 11 __getattr__ 0 4 3615 22 LVector2f::__getattr__ 0 1 225 0</span>
<span class="s0">92</span>
<span class="s0">inline PyObject *LVector2f::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2217 11 __setattr__ 0 4 3615 22 LVector2f::__setattr__ 0 1 226 0</span>
<span class="s0">98</span>
<span class="s0">inline int LVector2f::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2218 4 zero 0 4 3615 15 LVector2f::zero 0 1 227 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LVector2f const &amp;LVector2f::zero(void);</span>

<span class="s0">2219 6 unit_x 0 4 3615 17 LVector2f::unit_x 0 1 228 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector2f const &amp;LVector2f::unit_x(void);</span>

<span class="s0">2220 6 unit_y 0 4 3615 17 LVector2f::unit_y 0 1 229 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector2f const &amp;LVector2f::unit_y(void);</span>

<span class="s0">2221 10 operator - 0 68 3615 21 LVector2f::operator - 0 1 230 0</span>
<span class="s0">51</span>
<span class="s0">inline LVector2f LVector2f::operator -(void) const;</span>

<span class="s0">2222 10 operator + 0 4 3615 21 LVector2f::operator + 0 2 231 232 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase2f LVector2f::operator +(LVecBase2f const &amp;other) const;</span>
<span class="s0">inline LVector2f LVector2f::operator +(LVector2f const &amp;other) const;</span>

<span class="s0">2223 10 operator - 0 4 3615 21 LVector2f::operator - 0 2 233 234 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase2f LVector2f::operator -(LVecBase2f const &amp;other) const;</span>
<span class="s0">inline LVector2f LVector2f::operator -(LVector2f const &amp;other) const;</span>

<span class="s0">2224 10 operator * 0 4 3615 21 LVector2f::operator * 0 1 235 0</span>
<span class="s0">59</span>
<span class="s0">inline LVector2f LVector2f::operator *(float scalar) const;</span>

<span class="s0">2225 10 operator / 0 4 3615 21 LVector2f::operator / 0 1 236 0</span>
<span class="s0">59</span>
<span class="s0">inline LVector2f LVector2f::operator /(float scalar) const;</span>

<span class="s0">2226 10 normalized 0 4 3615 21 LVector2f::normalized 0 1 237 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline LVector2f LVector2f::normalized(void) const;</span>

<span class="s0">2227 7 project 0 4 3615 18 LVector2f::project 0 1 238 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVector2f LVector2f::project(LVecBase2f const &amp;onto) const;</span>

<span class="s0">2228 16 signed_angle_rad 0 4 3615 27 LVector2f::signed_angle_rad 0 1 239 92</span>
<span class="s0">/**</span>
 <span class="s0">* returns the signed angled between two vectors.  normalization is NOT</span>
 <span class="s0">* necessary</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline float LVector2f::signed_angle_rad(LVector2f const &amp;other) const;</span>

<span class="s0">2229 16 signed_angle_deg 0 4 3615 27 LVector2f::signed_angle_deg 0 1 240 92</span>
<span class="s0">/**</span>
 <span class="s0">* returns the signed angled between two vectors.  normalization is NOT</span>
 <span class="s0">* necessary</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline float LVector2f::signed_angle_deg(LVector2f const &amp;other) const;</span>

<span class="s0">2230 8 __repr__ 0 4 3615 19 LVector2f::__repr__ 0 1 241 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LVector2f::__repr__(void) const;</span>

<span class="s0">2231 14 get_class_type 0 4 3615 25 LVector2f::get_class_type 0 1 242 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LVector2f::get_class_type(void);</span>

<span class="s0">2232 10 ~LVector2f 0 516 3615 21 LVector2f::~LVector2f 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LVector2f::~LVector2f(void);</span>

<span class="s0">2233 9 LVector2d 0 260 3616 20 LVector2d::LVector2d 0 5 243 244 245 246 247 146</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LVector2 from a LVecBase2</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LVector2 with all components set to the fill value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">252</span>
<span class="s0">inline LVector2d::LVector2d(void) = default;</span>
<span class="s0">inline LVector2d::LVector2d(LVecBase2d const &amp;copy);</span>
<span class="s0">inline LVector2d::LVector2d(double fill_value);</span>
<span class="s0">inline LVector2d::LVector2d(double x, double y);</span>
<span class="s0">inline LVector2d::LVector2d(LVector2d const &amp;) = default;</span>

<span class="s0">2234 11 __getattr__ 0 4 3616 22 LVector2d::__getattr__ 0 1 248 0</span>
<span class="s0">92</span>
<span class="s0">inline PyObject *LVector2d::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2235 11 __setattr__ 0 4 3616 22 LVector2d::__setattr__ 0 1 249 0</span>
<span class="s0">98</span>
<span class="s0">inline int LVector2d::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2236 4 zero 0 4 3616 15 LVector2d::zero 0 1 250 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LVector2d const &amp;LVector2d::zero(void);</span>

<span class="s0">2237 6 unit_x 0 4 3616 17 LVector2d::unit_x 0 1 251 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector2d const &amp;LVector2d::unit_x(void);</span>

<span class="s0">2238 6 unit_y 0 4 3616 17 LVector2d::unit_y 0 1 252 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector2d const &amp;LVector2d::unit_y(void);</span>

<span class="s0">2239 10 operator - 0 68 3616 21 LVector2d::operator - 0 1 253 0</span>
<span class="s0">51</span>
<span class="s0">inline LVector2d LVector2d::operator -(void) const;</span>

<span class="s0">2240 10 operator + 0 4 3616 21 LVector2d::operator + 0 2 254 255 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase2d LVector2d::operator +(LVecBase2d const &amp;other) const;</span>
<span class="s0">inline LVector2d LVector2d::operator +(LVector2d const &amp;other) const;</span>

<span class="s0">2241 10 operator - 0 4 3616 21 LVector2d::operator - 0 2 256 257 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase2d LVector2d::operator -(LVecBase2d const &amp;other) const;</span>
<span class="s0">inline LVector2d LVector2d::operator -(LVector2d const &amp;other) const;</span>

<span class="s0">2242 10 operator * 0 4 3616 21 LVector2d::operator * 0 1 258 0</span>
<span class="s0">60</span>
<span class="s0">inline LVector2d LVector2d::operator *(double scalar) const;</span>

<span class="s0">2243 10 operator / 0 4 3616 21 LVector2d::operator / 0 1 259 0</span>
<span class="s0">60</span>
<span class="s0">inline LVector2d LVector2d::operator /(double scalar) const;</span>

<span class="s0">2244 10 normalized 0 4 3616 21 LVector2d::normalized 0 1 260 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline LVector2d LVector2d::normalized(void) const;</span>

<span class="s0">2245 7 project 0 4 3616 18 LVector2d::project 0 1 261 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVector2d LVector2d::project(LVecBase2d const &amp;onto) const;</span>

<span class="s0">2246 16 signed_angle_rad 0 4 3616 27 LVector2d::signed_angle_rad 0 1 262 92</span>
<span class="s0">/**</span>
 <span class="s0">* returns the signed angled between two vectors.  normalization is NOT</span>
 <span class="s0">* necessary</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline double LVector2d::signed_angle_rad(LVector2d const &amp;other) const;</span>

<span class="s0">2247 16 signed_angle_deg 0 4 3616 27 LVector2d::signed_angle_deg 0 1 263 92</span>
<span class="s0">/**</span>
 <span class="s0">* returns the signed angled between two vectors.  normalization is NOT</span>
 <span class="s0">* necessary</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline double LVector2d::signed_angle_deg(LVector2d const &amp;other) const;</span>

<span class="s0">2248 8 __repr__ 0 4 3616 19 LVector2d::__repr__ 0 1 264 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LVector2d::__repr__(void) const;</span>

<span class="s0">2249 14 get_class_type 0 4 3616 25 LVector2d::get_class_type 0 1 265 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LVector2d::get_class_type(void);</span>

<span class="s0">2250 10 ~LVector2d 0 516 3616 21 LVector2d::~LVector2d 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LVector2d::~LVector2d(void);</span>

<span class="s0">2251 9 LVector2i 0 260 3617 20 LVector2i::LVector2i 0 5 266 267 268 269 270 146</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LVector2 from a LVecBase2</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LVector2 with all components set to the fill value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">243</span>
<span class="s0">inline LVector2i::LVector2i(void) = default;</span>
<span class="s0">inline LVector2i::LVector2i(LVecBase2i const &amp;copy);</span>
<span class="s0">inline LVector2i::LVector2i(int fill_value);</span>
<span class="s0">inline LVector2i::LVector2i(int x, int y);</span>
<span class="s0">inline LVector2i::LVector2i(LVector2i const &amp;) = default;</span>

<span class="s0">2252 11 __getattr__ 0 4 3617 22 LVector2i::__getattr__ 0 1 271 0</span>
<span class="s0">92</span>
<span class="s0">inline PyObject *LVector2i::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2253 11 __setattr__ 0 4 3617 22 LVector2i::__setattr__ 0 1 272 0</span>
<span class="s0">98</span>
<span class="s0">inline int LVector2i::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2254 4 zero 0 4 3617 15 LVector2i::zero 0 1 273 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LVector2i const &amp;LVector2i::zero(void);</span>

<span class="s0">2255 6 unit_x 0 4 3617 17 LVector2i::unit_x 0 1 274 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector2i const &amp;LVector2i::unit_x(void);</span>

<span class="s0">2256 6 unit_y 0 4 3617 17 LVector2i::unit_y 0 1 275 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector2i const &amp;LVector2i::unit_y(void);</span>

<span class="s0">2257 10 operator - 0 68 3617 21 LVector2i::operator - 0 1 276 0</span>
<span class="s0">51</span>
<span class="s0">inline LVector2i LVector2i::operator -(void) const;</span>

<span class="s0">2258 10 operator + 0 4 3617 21 LVector2i::operator + 0 2 277 278 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase2i LVector2i::operator +(LVecBase2i const &amp;other) const;</span>
<span class="s0">inline LVector2i LVector2i::operator +(LVector2i const &amp;other) const;</span>

<span class="s0">2259 10 operator - 0 4 3617 21 LVector2i::operator - 0 2 279 280 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase2i LVector2i::operator -(LVecBase2i const &amp;other) const;</span>
<span class="s0">inline LVector2i LVector2i::operator -(LVector2i const &amp;other) const;</span>

<span class="s0">2260 10 operator * 0 4 3617 21 LVector2i::operator * 0 1 281 0</span>
<span class="s0">57</span>
<span class="s0">inline LVector2i LVector2i::operator *(int scalar) const;</span>

<span class="s0">2261 10 operator / 0 4 3617 21 LVector2i::operator / 0 1 282 0</span>
<span class="s0">57</span>
<span class="s0">inline LVector2i LVector2i::operator /(int scalar) const;</span>

<span class="s0">2262 8 __repr__ 0 4 3617 19 LVector2i::__repr__ 0 1 283 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LVector2i::__repr__(void) const;</span>

<span class="s0">2263 14 get_class_type 0 4 3617 25 LVector2i::get_class_type 0 1 284 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LVector2i::get_class_type(void);</span>

<span class="s0">2264 10 ~LVector2i 0 516 3617 21 LVector2i::~LVector2i 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LVector2i::~LVector2i(void);</span>

<span class="s0">2265 8 LPoint2f 0 260 3618 18 LPoint2f::LPoint2f 0 5 285 286 287 288 289 190</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LPoint2 from a LVecBase2</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LPoint2 all components set to the fill value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LPoint2 with the given components</span>
 <span class="s0">*/</span>
<span class="s0">238</span>
<span class="s0">inline LPoint2f::LPoint2f(void) = default;</span>
<span class="s0">inline LPoint2f::LPoint2f(LVecBase2f const &amp;copy);</span>
<span class="s0">inline LPoint2f::LPoint2f(float fill_value);</span>
<span class="s0">inline LPoint2f::LPoint2f(float x, float y);</span>
<span class="s0">inline LPoint2f::LPoint2f(LPoint2f const &amp;) = default;</span>

<span class="s0">2266 11 __getattr__ 0 4 3618 21 LPoint2f::__getattr__ 0 1 290 0</span>
<span class="s0">91</span>
<span class="s0">inline PyObject *LPoint2f::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2267 11 __setattr__ 0 4 3618 21 LPoint2f::__setattr__ 0 1 291 0</span>
<span class="s0">97</span>
<span class="s0">inline int LPoint2f::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2268 4 zero 0 4 3618 14 LPoint2f::zero 0 1 292 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline LPoint2f const &amp;LPoint2f::zero(void);</span>

<span class="s0">2269 6 unit_x 0 4 3618 16 LPoint2f::unit_x 0 1 293 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint2f const &amp;LPoint2f::unit_x(void);</span>

<span class="s0">2270 6 unit_y 0 4 3618 16 LPoint2f::unit_y 0 1 294 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint2f const &amp;LPoint2f::unit_y(void);</span>

<span class="s0">2271 10 operator - 0 68 3618 20 LPoint2f::operator - 0 1 295 0</span>
<span class="s0">49</span>
<span class="s0">inline LPoint2f LPoint2f::operator -(void) const;</span>

<span class="s0">2272 10 operator + 0 4 3618 20 LPoint2f::operator + 0 2 296 297 0</span>
<span class="s0">138</span>
<span class="s0">inline LVecBase2f LPoint2f::operator +(LVecBase2f const &amp;other) const;</span>
<span class="s0">inline LPoint2f LPoint2f::operator +(LVector2f const &amp;other) const;</span>

<span class="s0">2273 10 operator - 0 4 3618 20 LPoint2f::operator - 0 3 298 299 300 0</span>
<span class="s0">206</span>
<span class="s0">inline LVecBase2f LPoint2f::operator -(LVecBase2f const &amp;other) const;</span>
<span class="s0">inline LVector2f LPoint2f::operator -(LPoint2f const &amp;other) const;</span>
<span class="s0">inline LPoint2f LPoint2f::operator -(LVector2f const &amp;other) const;</span>

<span class="s0">2274 10 operator * 0 4 3618 20 LPoint2f::operator * 0 1 301 0</span>
<span class="s0">57</span>
<span class="s0">inline LPoint2f LPoint2f::operator *(float scalar) const;</span>

<span class="s0">2275 10 operator / 0 4 3618 20 LPoint2f::operator / 0 1 302 0</span>
<span class="s0">57</span>
<span class="s0">inline LPoint2f LPoint2f::operator /(float scalar) const;</span>

<span class="s0">2276 10 normalized 0 4 3618 20 LPoint2f::normalized 0 1 303 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LPoint2f LPoint2f::normalized(void) const;</span>

<span class="s0">2277 7 project 0 4 3618 17 LPoint2f::project 0 1 304 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LPoint2f LPoint2f::project(LVecBase2f const &amp;onto) const;</span>

<span class="s0">2278 8 __repr__ 0 4 3618 18 LPoint2f::__repr__ 0 1 305 0</span>
<span class="s0">50</span>
<span class="s0">inline std::string LPoint2f::__repr__(void) const;</span>

<span class="s0">2279 14 get_class_type 0 4 3618 24 LPoint2f::get_class_type 0 1 306 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle LPoint2f::get_class_type(void);</span>

<span class="s0">2280 9 ~LPoint2f 0 516 3618 19 LPoint2f::~LPoint2f 0 0 0</span>
<span class="s0">26</span>
<span class="s0">LPoint2f::~LPoint2f(void);</span>

<span class="s0">2281 8 LPoint2d 0 260 3619 18 LPoint2d::LPoint2d 0 5 307 308 309 310 311 190</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LPoint2 from a LVecBase2</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LPoint2 all components set to the fill value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LPoint2 with the given components</span>
 <span class="s0">*/</span>
<span class="s0">241</span>
<span class="s0">inline LPoint2d::LPoint2d(void) = default;</span>
<span class="s0">inline LPoint2d::LPoint2d(LVecBase2d const &amp;copy);</span>
<span class="s0">inline LPoint2d::LPoint2d(double fill_value);</span>
<span class="s0">inline LPoint2d::LPoint2d(double x, double y);</span>
<span class="s0">inline LPoint2d::LPoint2d(LPoint2d const &amp;) = default;</span>

<span class="s0">2282 11 __getattr__ 0 4 3619 21 LPoint2d::__getattr__ 0 1 312 0</span>
<span class="s0">91</span>
<span class="s0">inline PyObject *LPoint2d::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2283 11 __setattr__ 0 4 3619 21 LPoint2d::__setattr__ 0 1 313 0</span>
<span class="s0">97</span>
<span class="s0">inline int LPoint2d::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2284 4 zero 0 4 3619 14 LPoint2d::zero 0 1 314 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline LPoint2d const &amp;LPoint2d::zero(void);</span>

<span class="s0">2285 6 unit_x 0 4 3619 16 LPoint2d::unit_x 0 1 315 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint2d const &amp;LPoint2d::unit_x(void);</span>

<span class="s0">2286 6 unit_y 0 4 3619 16 LPoint2d::unit_y 0 1 316 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint2d const &amp;LPoint2d::unit_y(void);</span>

<span class="s0">2287 10 operator - 0 68 3619 20 LPoint2d::operator - 0 1 317 0</span>
<span class="s0">49</span>
<span class="s0">inline LPoint2d LPoint2d::operator -(void) const;</span>

<span class="s0">2288 10 operator + 0 4 3619 20 LPoint2d::operator + 0 2 318 319 0</span>
<span class="s0">138</span>
<span class="s0">inline LVecBase2d LPoint2d::operator +(LVecBase2d const &amp;other) const;</span>
<span class="s0">inline LPoint2d LPoint2d::operator +(LVector2d const &amp;other) const;</span>

<span class="s0">2289 10 operator - 0 4 3619 20 LPoint2d::operator - 0 3 320 321 322 0</span>
<span class="s0">206</span>
<span class="s0">inline LVecBase2d LPoint2d::operator -(LVecBase2d const &amp;other) const;</span>
<span class="s0">inline LVector2d LPoint2d::operator -(LPoint2d const &amp;other) const;</span>
<span class="s0">inline LPoint2d LPoint2d::operator -(LVector2d const &amp;other) const;</span>

<span class="s0">2290 10 operator * 0 4 3619 20 LPoint2d::operator * 0 1 323 0</span>
<span class="s0">58</span>
<span class="s0">inline LPoint2d LPoint2d::operator *(double scalar) const;</span>

<span class="s0">2291 10 operator / 0 4 3619 20 LPoint2d::operator / 0 1 324 0</span>
<span class="s0">58</span>
<span class="s0">inline LPoint2d LPoint2d::operator /(double scalar) const;</span>

<span class="s0">2292 10 normalized 0 4 3619 20 LPoint2d::normalized 0 1 325 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LPoint2d LPoint2d::normalized(void) const;</span>

<span class="s0">2293 7 project 0 4 3619 17 LPoint2d::project 0 1 326 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LPoint2d LPoint2d::project(LVecBase2d const &amp;onto) const;</span>

<span class="s0">2294 8 __repr__ 0 4 3619 18 LPoint2d::__repr__ 0 1 327 0</span>
<span class="s0">50</span>
<span class="s0">inline std::string LPoint2d::__repr__(void) const;</span>

<span class="s0">2295 14 get_class_type 0 4 3619 24 LPoint2d::get_class_type 0 1 328 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle LPoint2d::get_class_type(void);</span>

<span class="s0">2296 9 ~LPoint2d 0 516 3619 19 LPoint2d::~LPoint2d 0 0 0</span>
<span class="s0">26</span>
<span class="s0">LPoint2d::~LPoint2d(void);</span>

<span class="s0">2297 8 LPoint2i 0 260 3620 18 LPoint2i::LPoint2i 0 5 329 330 331 332 333 190</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LPoint2 from a LVecBase2</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LPoint2 all components set to the fill value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LPoint2 with the given components</span>
 <span class="s0">*/</span>
<span class="s0">232</span>
<span class="s0">inline LPoint2i::LPoint2i(void) = default;</span>
<span class="s0">inline LPoint2i::LPoint2i(LVecBase2i const &amp;copy);</span>
<span class="s0">inline LPoint2i::LPoint2i(int fill_value);</span>
<span class="s0">inline LPoint2i::LPoint2i(int x, int y);</span>
<span class="s0">inline LPoint2i::LPoint2i(LPoint2i const &amp;) = default;</span>

<span class="s0">2298 11 __getattr__ 0 4 3620 21 LPoint2i::__getattr__ 0 1 334 0</span>
<span class="s0">91</span>
<span class="s0">inline PyObject *LPoint2i::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2299 11 __setattr__ 0 4 3620 21 LPoint2i::__setattr__ 0 1 335 0</span>
<span class="s0">97</span>
<span class="s0">inline int LPoint2i::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2300 4 zero 0 4 3620 14 LPoint2i::zero 0 1 336 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline LPoint2i const &amp;LPoint2i::zero(void);</span>

<span class="s0">2301 6 unit_x 0 4 3620 16 LPoint2i::unit_x 0 1 337 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint2i const &amp;LPoint2i::unit_x(void);</span>

<span class="s0">2302 6 unit_y 0 4 3620 16 LPoint2i::unit_y 0 1 338 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint2i const &amp;LPoint2i::unit_y(void);</span>

<span class="s0">2303 10 operator - 0 68 3620 20 LPoint2i::operator - 0 1 339 0</span>
<span class="s0">49</span>
<span class="s0">inline LPoint2i LPoint2i::operator -(void) const;</span>

<span class="s0">2304 10 operator + 0 4 3620 20 LPoint2i::operator + 0 2 340 341 0</span>
<span class="s0">138</span>
<span class="s0">inline LVecBase2i LPoint2i::operator +(LVecBase2i const &amp;other) const;</span>
<span class="s0">inline LPoint2i LPoint2i::operator +(LVector2i const &amp;other) const;</span>

<span class="s0">2305 10 operator - 0 4 3620 20 LPoint2i::operator - 0 3 342 343 344 0</span>
<span class="s0">206</span>
<span class="s0">inline LVecBase2i LPoint2i::operator -(LVecBase2i const &amp;other) const;</span>
<span class="s0">inline LVector2i LPoint2i::operator -(LPoint2i const &amp;other) const;</span>
<span class="s0">inline LPoint2i LPoint2i::operator -(LVector2i const &amp;other) const;</span>

<span class="s0">2306 10 operator * 0 4 3620 20 LPoint2i::operator * 0 1 345 0</span>
<span class="s0">55</span>
<span class="s0">inline LPoint2i LPoint2i::operator *(int scalar) const;</span>

<span class="s0">2307 10 operator / 0 4 3620 20 LPoint2i::operator / 0 1 346 0</span>
<span class="s0">55</span>
<span class="s0">inline LPoint2i LPoint2i::operator /(int scalar) const;</span>

<span class="s0">2308 8 __repr__ 0 4 3620 18 LPoint2i::__repr__ 0 1 347 0</span>
<span class="s0">50</span>
<span class="s0">inline std::string LPoint2i::__repr__(void) const;</span>

<span class="s0">2309 14 get_class_type 0 4 3620 24 LPoint2i::get_class_type 0 1 348 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle LPoint2i::get_class_type(void);</span>

<span class="s0">2310 9 ~LPoint2i 0 516 3620 19 LPoint2i::~LPoint2i 0 0 0</span>
<span class="s0">26</span>
<span class="s0">LPoint2i::~LPoint2i(void);</span>

<span class="s0">2311 10 LVecBase3f 0 260 3621 22 LVecBase3f::LVecBase3f 0 5 349 350 351 352 353 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">278</span>
<span class="s0">inline LVecBase3f::LVecBase3f(void) = default;</span>
<span class="s0">inline LVecBase3f::LVecBase3f(float fill_value);</span>
<span class="s0">inline LVecBase3f::LVecBase3f(float x, float y, float z);</span>
<span class="s0">inline LVecBase3f::LVecBase3f(LVecBase2f const &amp;copy, float z);</span>
<span class="s0">inline LVecBase3f::LVecBase3f(LVecBase3f const &amp;) = default;</span>

<span class="s0">2312 12 operator new 0 4 3621 24 LVecBase3f::operator new 0 1 354 0</span>
<span class="s0">124</span>
<span class="s0">inline void *LVecBase3f::operator new(std::size_t size);</span>
<span class="s0">inline void *LVecBase3f::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2313 15 operator delete 0 4 3621 27 LVecBase3f::operator delete 0 0 0</span>
<span class="s0">108</span>
<span class="s0">inline void LVecBase3f::operator delete(void *ptr);</span>
<span class="s0">inline void LVecBase3f::operator delete(void *, void *);</span>

<span class="s0">2314 12 validate_ptr 0 4 3621 24 LVecBase3f::validate_ptr 0 0 0</span>
<span class="s0">61</span>
<span class="s0">static inline bool LVecBase3f::validate_ptr(void const *ptr);</span>

<span class="s0">2315 10 operator = 0 4 3621 22 LVecBase3f::operator = 0 2 355 356 0</span>
<span class="s0">119</span>
<span class="s0">void LVecBase3f::operator =(LVecBase3f const &amp;copy) = default;</span>
<span class="s0">void LVecBase3f::operator =(float fill_value) = default;</span>

<span class="s0">2316 4 zero 0 4 3621 16 LVecBase3f::zero 0 1 357 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVecBase3f const &amp;LVecBase3f::zero(void);</span>

<span class="s0">2317 6 unit_x 0 4 3621 18 LVecBase3f::unit_x 0 1 358 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase3f const &amp;LVecBase3f::unit_x(void);</span>

<span class="s0">2318 6 unit_y 0 4 3621 18 LVecBase3f::unit_y 0 1 359 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase3f const &amp;LVecBase3f::unit_y(void);</span>

<span class="s0">2319 6 unit_z 0 4 3621 18 LVecBase3f::unit_z 0 1 360 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase3f const &amp;LVecBase3f::unit_z(void);</span>

<span class="s0">2320 10 __reduce__ 0 4 3621 22 LVecBase3f::__reduce__ 0 1 361 0</span>
<span class="s0">62</span>
<span class="s0">inline PyObject *LVecBase3f::__reduce__(PyObject *self) const;</span>

<span class="s0">2321 11 __getattr__ 0 4 3621 23 LVecBase3f::__getattr__ 0 1 362 0</span>
<span class="s0">93</span>
<span class="s0">inline PyObject *LVecBase3f::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2322 11 __setattr__ 0 4 3621 23 LVecBase3f::__setattr__ 0 1 363 0</span>
<span class="s0">99</span>
<span class="s0">inline int LVecBase3f::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2323 11 operator [] 0 4 3621 23 LVecBase3f::operator [] 0 2 364 365 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline float LVecBase3f::operator [](int i) const;</span>
<span class="s0">inline float &amp;LVecBase3f::operator [](int i);</span>

<span class="s0">2324 4 size 0 4 3621 16 LVecBase3f::size 0 1 366 0</span>
<span class="s0">44</span>
<span class="s0">static constexpr int LVecBase3f::size(void);</span>

<span class="s0">2325 6 is_nan 0 4 3621 18 LVecBase3f::is_nan 0 1 367 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool LVecBase3f::is_nan(void) const;</span>

<span class="s0">2326 8 get_cell 0 4 3621 20 LVecBase3f::get_cell 0 1 368 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline float LVecBase3f::get_cell(int i) const;</span>

<span class="s0">2327 5 get_x 0 4 3621 17 LVecBase3f::get_x 0 1 369 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline float LVecBase3f::get_x(void) const;</span>

<span class="s0">2328 5 get_y 0 4 3621 17 LVecBase3f::get_y 0 1 370 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline float LVecBase3f::get_y(void) const;</span>

<span class="s0">2329 5 get_z 0 4 3621 17 LVecBase3f::get_z 0 1 371 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline float LVecBase3f::get_z(void) const;</span>

<span class="s0">2330 8 set_cell 0 4 3621 20 LVecBase3f::set_cell 0 1 372 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void LVecBase3f::set_cell(int i, float value);</span>

<span class="s0">2331 5 set_x 0 4 3621 17 LVecBase3f::set_x 0 1 373 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase3f::set_x(float value);</span>

<span class="s0">2332 5 set_y 0 4 3621 17 LVecBase3f::set_y 0 1 374 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase3f::set_y(float value);</span>

<span class="s0">2333 5 set_z 0 4 3621 17 LVecBase3f::set_z 0 1 375 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase3f::set_z(float value);</span>

<span class="s0">2334 6 get_xy 0 4 3621 18 LVecBase3f::get_xy 0 1 376 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2f LVecBase3f::get_xy(void) const;</span>

<span class="s0">2335 6 get_xz 0 4 3621 18 LVecBase3f::get_xz 0 1 377 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2f LVecBase3f::get_xz(void) const;</span>

<span class="s0">2336 6 get_yz 0 4 3621 18 LVecBase3f::get_yz 0 1 378 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2f LVecBase3f::get_yz(void) const;</span>

<span class="s0">2337 11 add_to_cell 0 4 3621 23 LVecBase3f::add_to_cell 0 1 379 164</span>
<span class="s0">// These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages:</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase3f::add_to_cell(int i, float value);</span>

<span class="s0">2338 5 add_x 0 4 3621 17 LVecBase3f::add_x 0 1 380 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase3f::add_x(float value);</span>

<span class="s0">2339 5 add_y 0 4 3621 17 LVecBase3f::add_y 0 1 381 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase3f::add_y(float value);</span>

<span class="s0">2340 5 add_z 0 4 3621 17 LVecBase3f::add_z 0 1 382 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase3f::add_z(float value);</span>

<span class="s0">2341 8 get_data 0 4 3621 20 LVecBase3f::get_data 0 1 383 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline float const *LVecBase3f::get_data(void) const;</span>

<span class="s0">2342 18 get_num_components 0 4 3621 30 LVecBase3f::get_num_components 0 1 384 0</span>
<span class="s0">58</span>
<span class="s0">static constexpr int LVecBase3f::get_num_components(void);</span>

<span class="s0">2343 4 fill 0 4 3621 16 LVecBase3f::fill 0 1 385 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void LVecBase3f::fill(float fill_value);</span>

<span class="s0">2344 3 set 0 4 3621 15 LVecBase3f::set 0 1 386 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void LVecBase3f::set(float x, float y, float z);</span>

<span class="s0">2345 3 dot 0 4 3621 15 LVecBase3f::dot 0 1 387 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline float LVecBase3f::dot(LVecBase3f const &amp;other) const;</span>

<span class="s0">2346 14 length_squared 0 4 3621 26 LVecBase3f::length_squared 0 1 388 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline float LVecBase3f::length_squared(void) const;</span>

<span class="s0">2347 6 length 0 4 3621 18 LVecBase3f::length 0 1 389 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline float LVecBase3f::length(void) const;</span>

<span class="s0">2348 9 normalize 0 4 3621 21 LVecBase3f::normalize 0 1 390 127</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline bool LVecBase3f::normalize(void);</span>

<span class="s0">2349 10 normalized 0 4 3621 22 LVecBase3f::normalized 0 1 391 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase3f LVecBase3f::normalized(void) const;</span>

<span class="s0">2350 7 project 0 4 3621 19 LVecBase3f::project 0 1 392 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LVecBase3f LVecBase3f::project(LVecBase3f const &amp;onto) const;</span>

<span class="s0">2351 5 cross 0 4 3621 17 LVecBase3f::cross 0 1 393 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline LVecBase3f LVecBase3f::cross(LVecBase3f const &amp;other) const;</span>

<span class="s0">2352 10 operator &lt; 0 4 3621 22 LVecBase3f::operator &lt; 0 1 394 0</span>
<span class="s0">66</span>
<span class="s0">inline bool LVecBase3f::operator &lt;(LVecBase3f const &amp;other) const;</span>

<span class="s0">2353 11 operator == 0 4 3621 23 LVecBase3f::operator == 0 1 395 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase3f::operator ==(LVecBase3f const &amp;other) const;</span>

<span class="s0">2354 11 operator != 0 4 3621 23 LVecBase3f::operator != 0 1 396 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase3f::operator !=(LVecBase3f const &amp;other) const;</span>

<span class="s0">2355 20 get_standardized_hpr 0 4 3621 32 LVecBase3f::get_standardized_hpr 0 1 397 623</span>
<span class="s0">/**</span>
 <span class="s0">* Try to un-spin the hpr to a standard form.  Like all standards, someone</span>
 <span class="s0">* decides between many arbitrary possible standards.  This function assumes</span>
 <span class="s0">* that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the</span>
 <span class="s0">* same.  Another example is -90 and 270. Each element will be in the range</span>
 <span class="s0">* -180.0 to 179.99999. The original usage of this function is for human</span>
 <span class="s0">* readable output.</span>
 <span class="s0">*</span>
 <span class="s0">* It doesn't work so well for asserting that foo_hpr is roughly equal to</span>
 <span class="s0">* bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:</span>
 <span class="s0">* get_standardized_rotation, LQuaternion::is_same_direction</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const;</span>

<span class="s0">2356 10 compare_to 0 4 3621 22 LVecBase3f::compare_to 0 2 398 399 332</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">inline int LVecBase3f::compare_to(LVecBase3f const &amp;other) const;</span>
<span class="s0">inline int LVecBase3f::compare_to(LVecBase3f const &amp;other, float threshold) const;</span>

<span class="s0">2357 8 get_hash 0 4 3621 20 LVecBase3f::get_hash 0 2 400 401 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">inline std::size_t LVecBase3f::get_hash(void) const;</span>
<span class="s0">inline std::size_t LVecBase3f::get_hash(float threshold) const;</span>

<span class="s0">2358 8 add_hash 0 4 3621 20 LVecBase3f::add_hash 0 2 402 403 100</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">146</span>
<span class="s0">inline std::size_t LVecBase3f::add_hash(std::size_t hash) const;</span>
<span class="s0">inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const;</span>

<span class="s0">2359 13 generate_hash 0 4 3621 25 LVecBase3f::generate_hash 0 2 404 405 120</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">170</span>
<span class="s0">inline void LVecBase3f::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>
<span class="s0">inline void LVecBase3f::generate_hash(ChecksumHashGenerator &amp;hashgen, float threshold) const;</span>

<span class="s0">2360 10 operator - 0 68 3621 22 LVecBase3f::operator - 0 1 406 0</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase3f LVecBase3f::operator -(void) const;</span>

<span class="s0">2361 10 operator + 0 4 3621 22 LVecBase3f::operator + 0 1 407 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase3f LVecBase3f::operator +(LVecBase3f const &amp;other) const;</span>

<span class="s0">2362 10 operator - 0 4 3621 22 LVecBase3f::operator - 0 1 408 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase3f LVecBase3f::operator -(LVecBase3f const &amp;other) const;</span>

<span class="s0">2363 10 operator * 0 4 3621 22 LVecBase3f::operator * 0 1 409 0</span>
<span class="s0">61</span>
<span class="s0">inline LVecBase3f LVecBase3f::operator *(float scalar) const;</span>

<span class="s0">2364 10 operator / 0 4 3621 22 LVecBase3f::operator / 0 1 410 0</span>
<span class="s0">61</span>
<span class="s0">inline LVecBase3f LVecBase3f::operator /(float scalar) const;</span>

<span class="s0">2365 11 operator += 0 4 3621 23 LVecBase3f::operator += 0 1 411 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase3f::operator +=(LVecBase3f const &amp;other);</span>

<span class="s0">2366 11 operator -= 0 4 3621 23 LVecBase3f::operator -= 0 1 412 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase3f::operator -=(LVecBase3f const &amp;other);</span>

<span class="s0">2367 11 operator *= 0 4 3621 23 LVecBase3f::operator *= 0 1 413 0</span>
<span class="s0">50</span>
<span class="s0">inline void LVecBase3f::operator *=(float scalar);</span>

<span class="s0">2368 11 operator /= 0 4 3621 23 LVecBase3f::operator /= 0 1 414 0</span>
<span class="s0">50</span>
<span class="s0">inline void LVecBase3f::operator /=(float scalar);</span>

<span class="s0">2369 18 componentwise_mult 0 4 3621 30 LVecBase3f::componentwise_mult 0 1 415 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase3f::componentwise_mult(LVecBase3f const &amp;other);</span>

<span class="s0">2370 12 __floordiv__ 0 4 3621 24 LVecBase3f::__floordiv__ 0 1 416 0</span>
<span class="s0">78</span>
<span class="s0">inline PyObject *LVecBase3f::__floordiv__(PyObject *self, float scalar) const;</span>

<span class="s0">2371 13 __ifloordiv__ 0 4 3621 25 LVecBase3f::__ifloordiv__ 0 1 417 0</span>
<span class="s0">73</span>
<span class="s0">inline PyObject *LVecBase3f::__ifloordiv__(PyObject *self, float scalar);</span>

<span class="s0">2372 7 __pow__ 0 4 3621 19 LVecBase3f::__pow__ 0 1 418 0</span>
<span class="s0">75</span>
<span class="s0">inline PyObject *LVecBase3f::__pow__(PyObject *self, float exponent) const;</span>

<span class="s0">2373 8 __ipow__ 0 4 3621 20 LVecBase3f::__ipow__ 0 1 419 0</span>
<span class="s0">70</span>
<span class="s0">inline PyObject *LVecBase3f::__ipow__(PyObject *self, float exponent);</span>

<span class="s0">2374 9 __round__ 0 4 3621 21 LVecBase3f::__round__ 0 1 420 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase3f::__round__(PyObject *self);</span>

<span class="s0">2375 9 __floor__ 0 4 3621 21 LVecBase3f::__floor__ 0 1 421 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase3f::__floor__(PyObject *self);</span>

<span class="s0">2376 8 __ceil__ 0 4 3621 20 LVecBase3f::__ceil__ 0 1 422 0</span>
<span class="s0">54</span>
<span class="s0">inline PyObject *LVecBase3f::__ceil__(PyObject *self);</span>

<span class="s0">2377 4 fmax 0 4 3621 16 LVecBase3f::fmax 0 1 423 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &amp;other) const;</span>

<span class="s0">2378 4 fmin 0 4 3621 16 LVecBase3f::fmin 0 1 424 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &amp;other) const;</span>

<span class="s0">2379 10 cross_into 0 4 3621 22 LVecBase3f::cross_into 0 1 425 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void LVecBase3f::cross_into(LVecBase3f const &amp;other);</span>

<span class="s0">2380 12 almost_equal 0 4 3621 24 LVecBase3f::almost_equal 0 2 426 427 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">154</span>
<span class="s0">inline bool LVecBase3f::almost_equal(LVecBase3f const &amp;other, float threshold) const;</span>
<span class="s0">inline bool LVecBase3f::almost_equal(LVecBase3f const &amp;other) const;</span>

<span class="s0">2381 6 output 0 4 3621 18 LVecBase3f::output 0 1 428 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase3f::output(std::ostream &amp;out) const;</span>

<span class="s0">2382 8 __repr__ 0 4 3621 20 LVecBase3f::__repr__ 0 1 429 0</span>
<span class="s0">52</span>
<span class="s0">inline std::string LVecBase3f::__repr__(void) const;</span>

<span class="s0">2383 20 write_datagram_fixed 0 4 3621 32 LVecBase3f::write_datagram_fixed 0 1 430 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void LVecBase3f::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">2384 19 read_datagram_fixed 0 4 3621 31 LVecBase3f::read_datagram_fixed 0 1 431 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void LVecBase3f::read_datagram_fixed(DatagramIterator &amp;source);</span>

<span class="s0">2385 14 write_datagram 0 4 3621 26 LVecBase3f::write_datagram 0 1 432 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase3f::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">2386 13 read_datagram 0 4 3621 25 LVecBase3f::read_datagram 0 1 433 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LVecBase3f::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">2387 14 get_class_type 0 4 3621 26 LVecBase3f::get_class_type 0 1 434 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle LVecBase3f::get_class_type(void);</span>

<span class="s0">2388 11 ~LVecBase3f 0 516 3621 23 LVecBase3f::~LVecBase3f 0 0 0</span>
<span class="s0">30</span>
<span class="s0">LVecBase3f::~LVecBase3f(void);</span>

<span class="s0">2389 10 LVecBase3d 0 260 3623 22 LVecBase3d::LVecBase3d 0 5 435 436 437 438 439 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">283</span>
<span class="s0">inline LVecBase3d::LVecBase3d(void) = default;</span>
<span class="s0">inline LVecBase3d::LVecBase3d(double fill_value);</span>
<span class="s0">inline LVecBase3d::LVecBase3d(double x, double y, double z);</span>
<span class="s0">inline LVecBase3d::LVecBase3d(LVecBase2d const &amp;copy, double z);</span>
<span class="s0">inline LVecBase3d::LVecBase3d(LVecBase3d const &amp;) = default;</span>

<span class="s0">2390 12 operator new 0 4 3623 24 LVecBase3d::operator new 0 1 440 0</span>
<span class="s0">124</span>
<span class="s0">inline void *LVecBase3d::operator new(std::size_t size);</span>
<span class="s0">inline void *LVecBase3d::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2391 15 operator delete 0 4 3623 27 LVecBase3d::operator delete 0 0 0</span>
<span class="s0">108</span>
<span class="s0">inline void LVecBase3d::operator delete(void *ptr);</span>
<span class="s0">inline void LVecBase3d::operator delete(void *, void *);</span>

<span class="s0">2392 12 validate_ptr 0 4 3623 24 LVecBase3d::validate_ptr 0 0 0</span>
<span class="s0">61</span>
<span class="s0">static inline bool LVecBase3d::validate_ptr(void const *ptr);</span>

<span class="s0">2393 10 operator = 0 4 3623 22 LVecBase3d::operator = 0 2 441 442 0</span>
<span class="s0">120</span>
<span class="s0">void LVecBase3d::operator =(LVecBase3d const &amp;copy) = default;</span>
<span class="s0">void LVecBase3d::operator =(double fill_value) = default;</span>

<span class="s0">2394 4 zero 0 4 3623 16 LVecBase3d::zero 0 1 443 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVecBase3d const &amp;LVecBase3d::zero(void);</span>

<span class="s0">2395 6 unit_x 0 4 3623 18 LVecBase3d::unit_x 0 1 444 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase3d const &amp;LVecBase3d::unit_x(void);</span>

<span class="s0">2396 6 unit_y 0 4 3623 18 LVecBase3d::unit_y 0 1 445 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase3d const &amp;LVecBase3d::unit_y(void);</span>

<span class="s0">2397 6 unit_z 0 4 3623 18 LVecBase3d::unit_z 0 1 446 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase3d const &amp;LVecBase3d::unit_z(void);</span>

<span class="s0">2398 10 __reduce__ 0 4 3623 22 LVecBase3d::__reduce__ 0 1 447 0</span>
<span class="s0">62</span>
<span class="s0">inline PyObject *LVecBase3d::__reduce__(PyObject *self) const;</span>

<span class="s0">2399 11 __getattr__ 0 4 3623 23 LVecBase3d::__getattr__ 0 1 448 0</span>
<span class="s0">93</span>
<span class="s0">inline PyObject *LVecBase3d::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2400 11 __setattr__ 0 4 3623 23 LVecBase3d::__setattr__ 0 1 449 0</span>
<span class="s0">99</span>
<span class="s0">inline int LVecBase3d::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2401 11 operator [] 0 4 3623 23 LVecBase3d::operator [] 0 2 450 451 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline double LVecBase3d::operator [](int i) const;</span>
<span class="s0">inline double &amp;LVecBase3d::operator [](int i);</span>

<span class="s0">2402 4 size 0 4 3623 16 LVecBase3d::size 0 1 452 0</span>
<span class="s0">44</span>
<span class="s0">static constexpr int LVecBase3d::size(void);</span>

<span class="s0">2403 6 is_nan 0 4 3623 18 LVecBase3d::is_nan 0 1 453 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool LVecBase3d::is_nan(void) const;</span>

<span class="s0">2404 8 get_cell 0 4 3623 20 LVecBase3d::get_cell 0 1 454 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline double LVecBase3d::get_cell(int i) const;</span>

<span class="s0">2405 5 get_x 0 4 3623 17 LVecBase3d::get_x 0 1 455 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double LVecBase3d::get_x(void) const;</span>

<span class="s0">2406 5 get_y 0 4 3623 17 LVecBase3d::get_y 0 1 456 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double LVecBase3d::get_y(void) const;</span>

<span class="s0">2407 5 get_z 0 4 3623 17 LVecBase3d::get_z 0 1 457 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double LVecBase3d::get_z(void) const;</span>

<span class="s0">2408 8 set_cell 0 4 3623 20 LVecBase3d::set_cell 0 1 458 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void LVecBase3d::set_cell(int i, double value);</span>

<span class="s0">2409 5 set_x 0 4 3623 17 LVecBase3d::set_x 0 1 459 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase3d::set_x(double value);</span>

<span class="s0">2410 5 set_y 0 4 3623 17 LVecBase3d::set_y 0 1 460 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase3d::set_y(double value);</span>

<span class="s0">2411 5 set_z 0 4 3623 17 LVecBase3d::set_z 0 1 461 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase3d::set_z(double value);</span>

<span class="s0">2412 6 get_xy 0 4 3623 18 LVecBase3d::get_xy 0 1 462 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2d LVecBase3d::get_xy(void) const;</span>

<span class="s0">2413 6 get_xz 0 4 3623 18 LVecBase3d::get_xz 0 1 463 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2d LVecBase3d::get_xz(void) const;</span>

<span class="s0">2414 6 get_yz 0 4 3623 18 LVecBase3d::get_yz 0 1 464 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2d LVecBase3d::get_yz(void) const;</span>

<span class="s0">2415 11 add_to_cell 0 4 3623 23 LVecBase3d::add_to_cell 0 1 465 164</span>
<span class="s0">// These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages:</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void LVecBase3d::add_to_cell(int i, double value);</span>

<span class="s0">2416 5 add_x 0 4 3623 17 LVecBase3d::add_x 0 1 466 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase3d::add_x(double value);</span>

<span class="s0">2417 5 add_y 0 4 3623 17 LVecBase3d::add_y 0 1 467 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase3d::add_y(double value);</span>

<span class="s0">2418 5 add_z 0 4 3623 17 LVecBase3d::add_z 0 1 468 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase3d::add_z(double value);</span>

<span class="s0">2419 8 get_data 0 4 3623 20 LVecBase3d::get_data 0 1 469 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline double const *LVecBase3d::get_data(void) const;</span>

<span class="s0">2420 18 get_num_components 0 4 3623 30 LVecBase3d::get_num_components 0 1 470 0</span>
<span class="s0">58</span>
<span class="s0">static constexpr int LVecBase3d::get_num_components(void);</span>

<span class="s0">2421 4 fill 0 4 3623 16 LVecBase3d::fill 0 1 471 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void LVecBase3d::fill(double fill_value);</span>

<span class="s0">2422 3 set 0 4 3623 15 LVecBase3d::set 0 1 472 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void LVecBase3d::set(double x, double y, double z);</span>

<span class="s0">2423 3 dot 0 4 3623 15 LVecBase3d::dot 0 1 473 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline double LVecBase3d::dot(LVecBase3d const &amp;other) const;</span>

<span class="s0">2424 14 length_squared 0 4 3623 26 LVecBase3d::length_squared 0 1 474 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline double LVecBase3d::length_squared(void) const;</span>

<span class="s0">2425 6 length 0 4 3623 18 LVecBase3d::length 0 1 475 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline double LVecBase3d::length(void) const;</span>

<span class="s0">2426 9 normalize 0 4 3623 21 LVecBase3d::normalize 0 1 476 127</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline bool LVecBase3d::normalize(void);</span>

<span class="s0">2427 10 normalized 0 4 3623 22 LVecBase3d::normalized 0 1 477 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase3d LVecBase3d::normalized(void) const;</span>

<span class="s0">2428 7 project 0 4 3623 19 LVecBase3d::project 0 1 478 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LVecBase3d LVecBase3d::project(LVecBase3d const &amp;onto) const;</span>

<span class="s0">2429 5 cross 0 4 3623 17 LVecBase3d::cross 0 1 479 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline LVecBase3d LVecBase3d::cross(LVecBase3d const &amp;other) const;</span>

<span class="s0">2430 10 operator &lt; 0 4 3623 22 LVecBase3d::operator &lt; 0 1 480 0</span>
<span class="s0">66</span>
<span class="s0">inline bool LVecBase3d::operator &lt;(LVecBase3d const &amp;other) const;</span>

<span class="s0">2431 11 operator == 0 4 3623 23 LVecBase3d::operator == 0 1 481 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase3d::operator ==(LVecBase3d const &amp;other) const;</span>

<span class="s0">2432 11 operator != 0 4 3623 23 LVecBase3d::operator != 0 1 482 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase3d::operator !=(LVecBase3d const &amp;other) const;</span>

<span class="s0">2433 20 get_standardized_hpr 0 4 3623 32 LVecBase3d::get_standardized_hpr 0 1 483 623</span>
<span class="s0">/**</span>
 <span class="s0">* Try to un-spin the hpr to a standard form.  Like all standards, someone</span>
 <span class="s0">* decides between many arbitrary possible standards.  This function assumes</span>
 <span class="s0">* that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the</span>
 <span class="s0">* same.  Another example is -90 and 270. Each element will be in the range</span>
 <span class="s0">* -180.0 to 179.99999. The original usage of this function is for human</span>
 <span class="s0">* readable output.</span>
 <span class="s0">*</span>
 <span class="s0">* It doesn't work so well for asserting that foo_hpr is roughly equal to</span>
 <span class="s0">* bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:</span>
 <span class="s0">* get_standardized_rotation, LQuaternion::is_same_direction</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const;</span>

<span class="s0">2434 10 compare_to 0 4 3623 22 LVecBase3d::compare_to 0 2 484 485 332</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/</span>
<span class="s0">149</span>
<span class="s0">inline int LVecBase3d::compare_to(LVecBase3d const &amp;other) const;</span>
<span class="s0">inline int LVecBase3d::compare_to(LVecBase3d const &amp;other, double threshold) const;</span>

<span class="s0">2435 8 get_hash 0 4 3623 20 LVecBase3d::get_hash 0 2 486 487 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">inline std::size_t LVecBase3d::get_hash(void) const;</span>
<span class="s0">inline std::size_t LVecBase3d::get_hash(double threshold) const;</span>

<span class="s0">2436 8 add_hash 0 4 3623 20 LVecBase3d::add_hash 0 2 488 489 100</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">147</span>
<span class="s0">inline std::size_t LVecBase3d::add_hash(std::size_t hash) const;</span>
<span class="s0">inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const;</span>

<span class="s0">2437 13 generate_hash 0 4 3623 25 LVecBase3d::generate_hash 0 2 490 491 120</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">171</span>
<span class="s0">inline void LVecBase3d::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>
<span class="s0">inline void LVecBase3d::generate_hash(ChecksumHashGenerator &amp;hashgen, double threshold) const;</span>

<span class="s0">2438 10 operator - 0 68 3623 22 LVecBase3d::operator - 0 1 492 0</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase3d LVecBase3d::operator -(void) const;</span>

<span class="s0">2439 10 operator + 0 4 3623 22 LVecBase3d::operator + 0 1 493 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase3d LVecBase3d::operator +(LVecBase3d const &amp;other) const;</span>

<span class="s0">2440 10 operator - 0 4 3623 22 LVecBase3d::operator - 0 1 494 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase3d LVecBase3d::operator -(LVecBase3d const &amp;other) const;</span>

<span class="s0">2441 10 operator * 0 4 3623 22 LVecBase3d::operator * 0 1 495 0</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase3d LVecBase3d::operator *(double scalar) const;</span>

<span class="s0">2442 10 operator / 0 4 3623 22 LVecBase3d::operator / 0 1 496 0</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase3d LVecBase3d::operator /(double scalar) const;</span>

<span class="s0">2443 11 operator += 0 4 3623 23 LVecBase3d::operator += 0 1 497 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase3d::operator +=(LVecBase3d const &amp;other);</span>

<span class="s0">2444 11 operator -= 0 4 3623 23 LVecBase3d::operator -= 0 1 498 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase3d::operator -=(LVecBase3d const &amp;other);</span>

<span class="s0">2445 11 operator *= 0 4 3623 23 LVecBase3d::operator *= 0 1 499 0</span>
<span class="s0">51</span>
<span class="s0">inline void LVecBase3d::operator *=(double scalar);</span>

<span class="s0">2446 11 operator /= 0 4 3623 23 LVecBase3d::operator /= 0 1 500 0</span>
<span class="s0">51</span>
<span class="s0">inline void LVecBase3d::operator /=(double scalar);</span>

<span class="s0">2447 18 componentwise_mult 0 4 3623 30 LVecBase3d::componentwise_mult 0 1 501 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase3d::componentwise_mult(LVecBase3d const &amp;other);</span>

<span class="s0">2448 12 __floordiv__ 0 4 3623 24 LVecBase3d::__floordiv__ 0 1 502 0</span>
<span class="s0">79</span>
<span class="s0">inline PyObject *LVecBase3d::__floordiv__(PyObject *self, double scalar) const;</span>

<span class="s0">2449 13 __ifloordiv__ 0 4 3623 25 LVecBase3d::__ifloordiv__ 0 1 503 0</span>
<span class="s0">74</span>
<span class="s0">inline PyObject *LVecBase3d::__ifloordiv__(PyObject *self, double scalar);</span>

<span class="s0">2450 7 __pow__ 0 4 3623 19 LVecBase3d::__pow__ 0 1 504 0</span>
<span class="s0">76</span>
<span class="s0">inline PyObject *LVecBase3d::__pow__(PyObject *self, double exponent) const;</span>

<span class="s0">2451 8 __ipow__ 0 4 3623 20 LVecBase3d::__ipow__ 0 1 505 0</span>
<span class="s0">71</span>
<span class="s0">inline PyObject *LVecBase3d::__ipow__(PyObject *self, double exponent);</span>

<span class="s0">2452 9 __round__ 0 4 3623 21 LVecBase3d::__round__ 0 1 506 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase3d::__round__(PyObject *self);</span>

<span class="s0">2453 9 __floor__ 0 4 3623 21 LVecBase3d::__floor__ 0 1 507 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase3d::__floor__(PyObject *self);</span>

<span class="s0">2454 8 __ceil__ 0 4 3623 20 LVecBase3d::__ceil__ 0 1 508 0</span>
<span class="s0">54</span>
<span class="s0">inline PyObject *LVecBase3d::__ceil__(PyObject *self);</span>

<span class="s0">2455 4 fmax 0 4 3623 16 LVecBase3d::fmax 0 1 509 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &amp;other) const;</span>

<span class="s0">2456 4 fmin 0 4 3623 16 LVecBase3d::fmin 0 1 510 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &amp;other) const;</span>

<span class="s0">2457 10 cross_into 0 4 3623 22 LVecBase3d::cross_into 0 1 511 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void LVecBase3d::cross_into(LVecBase3d const &amp;other);</span>

<span class="s0">2458 12 almost_equal 0 4 3623 24 LVecBase3d::almost_equal 0 2 512 513 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">155</span>
<span class="s0">inline bool LVecBase3d::almost_equal(LVecBase3d const &amp;other, double threshold) const;</span>
<span class="s0">inline bool LVecBase3d::almost_equal(LVecBase3d const &amp;other) const;</span>

<span class="s0">2459 6 output 0 4 3623 18 LVecBase3d::output 0 1 514 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase3d::output(std::ostream &amp;out) const;</span>

<span class="s0">2460 8 __repr__ 0 4 3623 20 LVecBase3d::__repr__ 0 1 515 0</span>
<span class="s0">52</span>
<span class="s0">inline std::string LVecBase3d::__repr__(void) const;</span>

<span class="s0">2461 20 write_datagram_fixed 0 4 3623 32 LVecBase3d::write_datagram_fixed 0 1 516 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void LVecBase3d::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">2462 19 read_datagram_fixed 0 4 3623 31 LVecBase3d::read_datagram_fixed 0 1 517 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void LVecBase3d::read_datagram_fixed(DatagramIterator &amp;source);</span>

<span class="s0">2463 14 write_datagram 0 4 3623 26 LVecBase3d::write_datagram 0 1 518 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase3d::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">2464 13 read_datagram 0 4 3623 25 LVecBase3d::read_datagram 0 1 519 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LVecBase3d::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">2465 14 get_class_type 0 4 3623 26 LVecBase3d::get_class_type 0 1 520 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle LVecBase3d::get_class_type(void);</span>

<span class="s0">2466 11 ~LVecBase3d 0 516 3623 23 LVecBase3d::~LVecBase3d 0 0 0</span>
<span class="s0">30</span>
<span class="s0">LVecBase3d::~LVecBase3d(void);</span>

<span class="s0">2467 10 LVecBase3i 0 260 3625 22 LVecBase3i::LVecBase3i 0 5 521 522 523 524 525 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">268</span>
<span class="s0">inline LVecBase3i::LVecBase3i(void) = default;</span>
<span class="s0">inline LVecBase3i::LVecBase3i(int fill_value);</span>
<span class="s0">inline LVecBase3i::LVecBase3i(int x, int y, int z);</span>
<span class="s0">inline LVecBase3i::LVecBase3i(LVecBase2i const &amp;copy, int z);</span>
<span class="s0">inline LVecBase3i::LVecBase3i(LVecBase3i const &amp;) = default;</span>

<span class="s0">2468 12 operator new 0 4 3625 24 LVecBase3i::operator new 0 1 526 0</span>
<span class="s0">124</span>
<span class="s0">inline void *LVecBase3i::operator new(std::size_t size);</span>
<span class="s0">inline void *LVecBase3i::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2469 15 operator delete 0 4 3625 27 LVecBase3i::operator delete 0 0 0</span>
<span class="s0">108</span>
<span class="s0">inline void LVecBase3i::operator delete(void *ptr);</span>
<span class="s0">inline void LVecBase3i::operator delete(void *, void *);</span>

<span class="s0">2470 12 validate_ptr 0 4 3625 24 LVecBase3i::validate_ptr 0 0 0</span>
<span class="s0">61</span>
<span class="s0">static inline bool LVecBase3i::validate_ptr(void const *ptr);</span>

<span class="s0">2471 10 operator = 0 4 3625 22 LVecBase3i::operator = 0 2 527 528 0</span>
<span class="s0">117</span>
<span class="s0">void LVecBase3i::operator =(LVecBase3i const &amp;copy) = default;</span>
<span class="s0">void LVecBase3i::operator =(int fill_value) = default;</span>

<span class="s0">2472 4 zero 0 4 3625 16 LVecBase3i::zero 0 1 529 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVecBase3i const &amp;LVecBase3i::zero(void);</span>

<span class="s0">2473 6 unit_x 0 4 3625 18 LVecBase3i::unit_x 0 1 530 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase3i const &amp;LVecBase3i::unit_x(void);</span>

<span class="s0">2474 6 unit_y 0 4 3625 18 LVecBase3i::unit_y 0 1 531 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase3i const &amp;LVecBase3i::unit_y(void);</span>

<span class="s0">2475 6 unit_z 0 4 3625 18 LVecBase3i::unit_z 0 1 532 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase3i const &amp;LVecBase3i::unit_z(void);</span>

<span class="s0">2476 10 __reduce__ 0 4 3625 22 LVecBase3i::__reduce__ 0 1 533 0</span>
<span class="s0">62</span>
<span class="s0">inline PyObject *LVecBase3i::__reduce__(PyObject *self) const;</span>

<span class="s0">2477 11 __getattr__ 0 4 3625 23 LVecBase3i::__getattr__ 0 1 534 0</span>
<span class="s0">93</span>
<span class="s0">inline PyObject *LVecBase3i::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2478 11 __setattr__ 0 4 3625 23 LVecBase3i::__setattr__ 0 1 535 0</span>
<span class="s0">99</span>
<span class="s0">inline int LVecBase3i::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2479 11 operator [] 0 4 3625 23 LVecBase3i::operator [] 0 2 536 537 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">inline int LVecBase3i::operator [](int i) const;</span>
<span class="s0">inline int &amp;LVecBase3i::operator [](int i);</span>

<span class="s0">2480 4 size 0 4 3625 16 LVecBase3i::size 0 1 538 0</span>
<span class="s0">44</span>
<span class="s0">static constexpr int LVecBase3i::size(void);</span>

<span class="s0">2481 6 is_nan 0 4 3625 18 LVecBase3i::is_nan 0 1 539 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool LVecBase3i::is_nan(void) const;</span>

<span class="s0">2482 8 get_cell 0 4 3625 20 LVecBase3i::get_cell 0 1 540 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline int LVecBase3i::get_cell(int i) const;</span>

<span class="s0">2483 5 get_x 0 4 3625 17 LVecBase3i::get_x 0 1 541 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline int LVecBase3i::get_x(void) const;</span>

<span class="s0">2484 5 get_y 0 4 3625 17 LVecBase3i::get_y 0 1 542 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline int LVecBase3i::get_y(void) const;</span>

<span class="s0">2485 5 get_z 0 4 3625 17 LVecBase3i::get_z 0 1 543 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline int LVecBase3i::get_z(void) const;</span>

<span class="s0">2486 8 set_cell 0 4 3625 20 LVecBase3i::set_cell 0 1 544 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void LVecBase3i::set_cell(int i, int value);</span>

<span class="s0">2487 5 set_x 0 4 3625 17 LVecBase3i::set_x 0 1 545 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase3i::set_x(int value);</span>

<span class="s0">2488 5 set_y 0 4 3625 17 LVecBase3i::set_y 0 1 546 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase3i::set_y(int value);</span>

<span class="s0">2489 5 set_z 0 4 3625 17 LVecBase3i::set_z 0 1 547 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase3i::set_z(int value);</span>

<span class="s0">2490 6 get_xy 0 4 3625 18 LVecBase3i::get_xy 0 1 548 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2i LVecBase3i::get_xy(void) const;</span>

<span class="s0">2491 6 get_xz 0 4 3625 18 LVecBase3i::get_xz 0 1 549 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2i LVecBase3i::get_xz(void) const;</span>

<span class="s0">2492 6 get_yz 0 4 3625 18 LVecBase3i::get_yz 0 1 550 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2i LVecBase3i::get_yz(void) const;</span>

<span class="s0">2493 11 add_to_cell 0 4 3625 23 LVecBase3i::add_to_cell 0 1 551 164</span>
<span class="s0">// These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages:</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void LVecBase3i::add_to_cell(int i, int value);</span>

<span class="s0">2494 5 add_x 0 4 3625 17 LVecBase3i::add_x 0 1 552 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase3i::add_x(int value);</span>

<span class="s0">2495 5 add_y 0 4 3625 17 LVecBase3i::add_y 0 1 553 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase3i::add_y(int value);</span>

<span class="s0">2496 5 add_z 0 4 3625 17 LVecBase3i::add_z 0 1 554 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase3i::add_z(int value);</span>

<span class="s0">2497 8 get_data 0 4 3625 20 LVecBase3i::get_data 0 1 555 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int const *LVecBase3i::get_data(void) const;</span>

<span class="s0">2498 18 get_num_components 0 4 3625 30 LVecBase3i::get_num_components 0 1 556 0</span>
<span class="s0">58</span>
<span class="s0">static constexpr int LVecBase3i::get_num_components(void);</span>

<span class="s0">2499 4 fill 0 4 3625 16 LVecBase3i::fill 0 1 557 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void LVecBase3i::fill(int fill_value);</span>

<span class="s0">2500 3 set 0 4 3625 15 LVecBase3i::set 0 1 558 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void LVecBase3i::set(int x, int y, int z);</span>

<span class="s0">2501 3 dot 0 4 3625 15 LVecBase3i::dot 0 1 559 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int LVecBase3i::dot(LVecBase3i const &amp;other) const;</span>

<span class="s0">2502 14 length_squared 0 4 3625 26 LVecBase3i::length_squared 0 1 560 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int LVecBase3i::length_squared(void) const;</span>

<span class="s0">2503 5 cross 0 4 3625 17 LVecBase3i::cross 0 1 561 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline LVecBase3i LVecBase3i::cross(LVecBase3i const &amp;other) const;</span>

<span class="s0">2504 10 operator &lt; 0 4 3625 22 LVecBase3i::operator &lt; 0 1 562 0</span>
<span class="s0">66</span>
<span class="s0">inline bool LVecBase3i::operator &lt;(LVecBase3i const &amp;other) const;</span>

<span class="s0">2505 11 operator == 0 4 3625 23 LVecBase3i::operator == 0 1 563 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase3i::operator ==(LVecBase3i const &amp;other) const;</span>

<span class="s0">2506 11 operator != 0 4 3625 23 LVecBase3i::operator != 0 1 564 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase3i::operator !=(LVecBase3i const &amp;other) const;</span>

<span class="s0">2507 10 compare_to 0 4 3625 22 LVecBase3i::compare_to 0 1 565 97</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int LVecBase3i::compare_to(LVecBase3i const &amp;other) const;</span>

<span class="s0">2508 8 get_hash 0 4 3625 20 LVecBase3i::get_hash 0 1 566 49</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline std::size_t LVecBase3i::get_hash(void) const;</span>

<span class="s0">2509 8 add_hash 0 4 3625 20 LVecBase3i::add_hash 0 1 567 49</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::size_t LVecBase3i::add_hash(std::size_t hash) const;</span>

<span class="s0">2510 13 generate_hash 0 4 3625 25 LVecBase3i::generate_hash 0 1 568 59</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void LVecBase3i::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>

<span class="s0">2511 10 operator - 0 68 3625 22 LVecBase3i::operator - 0 1 569 0</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase3i LVecBase3i::operator -(void) const;</span>

<span class="s0">2512 10 operator + 0 4 3625 22 LVecBase3i::operator + 0 1 570 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase3i LVecBase3i::operator +(LVecBase3i const &amp;other) const;</span>

<span class="s0">2513 10 operator - 0 4 3625 22 LVecBase3i::operator - 0 1 571 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase3i LVecBase3i::operator -(LVecBase3i const &amp;other) const;</span>

<span class="s0">2514 10 operator * 0 4 3625 22 LVecBase3i::operator * 0 1 572 0</span>
<span class="s0">59</span>
<span class="s0">inline LVecBase3i LVecBase3i::operator *(int scalar) const;</span>

<span class="s0">2515 10 operator / 0 4 3625 22 LVecBase3i::operator / 0 1 573 0</span>
<span class="s0">59</span>
<span class="s0">inline LVecBase3i LVecBase3i::operator /(int scalar) const;</span>

<span class="s0">2516 11 operator += 0 4 3625 23 LVecBase3i::operator += 0 1 574 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase3i::operator +=(LVecBase3i const &amp;other);</span>

<span class="s0">2517 11 operator -= 0 4 3625 23 LVecBase3i::operator -= 0 1 575 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase3i::operator -=(LVecBase3i const &amp;other);</span>

<span class="s0">2518 11 operator *= 0 4 3625 23 LVecBase3i::operator *= 0 1 576 0</span>
<span class="s0">48</span>
<span class="s0">inline void LVecBase3i::operator *=(int scalar);</span>

<span class="s0">2519 11 operator /= 0 4 3625 23 LVecBase3i::operator /= 0 1 577 0</span>
<span class="s0">48</span>
<span class="s0">inline void LVecBase3i::operator /=(int scalar);</span>

<span class="s0">2520 18 componentwise_mult 0 4 3625 30 LVecBase3i::componentwise_mult 0 1 578 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase3i::componentwise_mult(LVecBase3i const &amp;other);</span>

<span class="s0">2521 12 __floordiv__ 0 4 3625 24 LVecBase3i::__floordiv__ 0 1 579 0</span>
<span class="s0">76</span>
<span class="s0">inline PyObject *LVecBase3i::__floordiv__(PyObject *self, int scalar) const;</span>

<span class="s0">2522 13 __ifloordiv__ 0 4 3625 25 LVecBase3i::__ifloordiv__ 0 1 580 0</span>
<span class="s0">71</span>
<span class="s0">inline PyObject *LVecBase3i::__ifloordiv__(PyObject *self, int scalar);</span>

<span class="s0">2523 7 __pow__ 0 4 3625 19 LVecBase3i::__pow__ 0 1 581 0</span>
<span class="s0">73</span>
<span class="s0">inline PyObject *LVecBase3i::__pow__(PyObject *self, int exponent) const;</span>

<span class="s0">2524 8 __ipow__ 0 4 3625 20 LVecBase3i::__ipow__ 0 1 582 0</span>
<span class="s0">68</span>
<span class="s0">inline PyObject *LVecBase3i::__ipow__(PyObject *self, int exponent);</span>

<span class="s0">2525 9 __round__ 0 4 3625 21 LVecBase3i::__round__ 0 1 583 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase3i::__round__(PyObject *self);</span>

<span class="s0">2526 9 __floor__ 0 4 3625 21 LVecBase3i::__floor__ 0 1 584 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase3i::__floor__(PyObject *self);</span>

<span class="s0">2527 8 __ceil__ 0 4 3625 20 LVecBase3i::__ceil__ 0 1 585 0</span>
<span class="s0">54</span>
<span class="s0">inline PyObject *LVecBase3i::__ceil__(PyObject *self);</span>

<span class="s0">2528 4 fmax 0 4 3625 16 LVecBase3i::fmax 0 1 586 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &amp;other) const;</span>

<span class="s0">2529 4 fmin 0 4 3625 16 LVecBase3i::fmin 0 1 587 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &amp;other) const;</span>

<span class="s0">2530 10 cross_into 0 4 3625 22 LVecBase3i::cross_into 0 1 588 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void LVecBase3i::cross_into(LVecBase3i const &amp;other);</span>

<span class="s0">2531 12 almost_equal 0 4 3625 24 LVecBase3i::almost_equal 0 2 589 590 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">152</span>
<span class="s0">inline bool LVecBase3i::almost_equal(LVecBase3i const &amp;other, int threshold) const;</span>
<span class="s0">inline bool LVecBase3i::almost_equal(LVecBase3i const &amp;other) const;</span>

<span class="s0">2532 6 output 0 4 3625 18 LVecBase3i::output 0 1 591 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase3i::output(std::ostream &amp;out) const;</span>

<span class="s0">2533 8 __repr__ 0 4 3625 20 LVecBase3i::__repr__ 0 1 592 0</span>
<span class="s0">52</span>
<span class="s0">inline std::string LVecBase3i::__repr__(void) const;</span>

<span class="s0">2534 20 write_datagram_fixed 0 4 3625 32 LVecBase3i::write_datagram_fixed 0 1 593 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void LVecBase3i::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">2535 19 read_datagram_fixed 0 4 3625 31 LVecBase3i::read_datagram_fixed 0 1 594 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void LVecBase3i::read_datagram_fixed(DatagramIterator &amp;source);</span>

<span class="s0">2536 14 write_datagram 0 4 3625 26 LVecBase3i::write_datagram 0 1 595 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase3i::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">2537 13 read_datagram 0 4 3625 25 LVecBase3i::read_datagram 0 1 596 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LVecBase3i::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">2538 14 get_class_type 0 4 3625 26 LVecBase3i::get_class_type 0 1 597 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle LVecBase3i::get_class_type(void);</span>

<span class="s0">2539 11 ~LVecBase3i 0 516 3625 23 LVecBase3i::~LVecBase3i 0 0 0</span>
<span class="s0">30</span>
<span class="s0">LVecBase3i::~LVecBase3i(void);</span>

<span class="s0">2540 29 get_default_coordinate_system 0 1 0 29 get_default_coordinate_system 0 1 1925 0</span>
<span class="s0">53</span>
<span class="s0">CoordinateSystem get_default_coordinate_system(void);</span>

<span class="s0">2541 30 parse_coordinate_system_string 0 1 0 30 parse_coordinate_system_string 0 1 1926 0</span>
<span class="s0">72</span>
<span class="s0">CoordinateSystem parse_coordinate_system_string(std::string const &amp;str);</span>

<span class="s0">2542 24 format_coordinate_system 0 1 0 24 format_coordinate_system 0 1 1927 0</span>
<span class="s0">58</span>
<span class="s0">std::string format_coordinate_system(CoordinateSystem cs);</span>

<span class="s0">2543 15 is_right_handed 0 1 0 15 is_right_handed 0 1 1928 0</span>
<span class="s0">57</span>
<span class="s0">bool is_right_handed(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2544 9 LVector3f 0 260 3628 20 LVector3f::LVector3f 0 6 598 599 600 601 602 603 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">320</span>
<span class="s0">inline LVector3f::LVector3f(void) = default;</span>
<span class="s0">inline LVector3f::LVector3f(LVecBase3f const &amp;copy);</span>
<span class="s0">inline LVector3f::LVector3f(float fill_value);</span>
<span class="s0">inline LVector3f::LVector3f(float x, float y, float z);</span>
<span class="s0">inline LVector3f::LVector3f(LVecBase2f const &amp;copy, float z);</span>
<span class="s0">inline LVector3f::LVector3f(LVector3f const &amp;) = default;</span>

<span class="s0">2545 11 __getattr__ 0 4 3628 22 LVector3f::__getattr__ 0 1 604 0</span>
<span class="s0">92</span>
<span class="s0">inline PyObject *LVector3f::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2546 11 __setattr__ 0 4 3628 22 LVector3f::__setattr__ 0 1 605 0</span>
<span class="s0">98</span>
<span class="s0">inline int LVector3f::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2547 4 zero 0 4 3628 15 LVector3f::zero 0 1 606 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LVector3f const &amp;LVector3f::zero(void);</span>

<span class="s0">2548 6 unit_x 0 4 3628 17 LVector3f::unit_x 0 1 607 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector3f const &amp;LVector3f::unit_x(void);</span>

<span class="s0">2549 6 unit_y 0 4 3628 17 LVector3f::unit_y 0 1 608 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector3f const &amp;LVector3f::unit_y(void);</span>

<span class="s0">2550 6 unit_z 0 4 3628 17 LVector3f::unit_z 0 1 609 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector3f const &amp;LVector3f::unit_z(void);</span>

<span class="s0">2551 6 get_xy 0 4 3628 17 LVector3f::get_xy 0 1 610 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2f LVector3f::get_xy(void) const;</span>

<span class="s0">2552 6 get_xz 0 4 3628 17 LVector3f::get_xz 0 1 611 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2f LVector3f::get_xz(void) const;</span>

<span class="s0">2553 6 get_yz 0 4 3628 17 LVector3f::get_yz 0 1 612 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2f LVector3f::get_yz(void) const;</span>

<span class="s0">2554 10 operator - 0 68 3628 21 LVector3f::operator - 0 1 613 0</span>
<span class="s0">51</span>
<span class="s0">inline LVector3f LVector3f::operator -(void) const;</span>

<span class="s0">2555 10 operator + 0 4 3628 21 LVector3f::operator + 0 2 614 615 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase3f LVector3f::operator +(LVecBase3f const &amp;other) const;</span>
<span class="s0">inline LVector3f LVector3f::operator +(LVector3f const &amp;other) const;</span>

<span class="s0">2556 10 operator - 0 4 3628 21 LVector3f::operator - 0 2 616 617 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase3f LVector3f::operator -(LVecBase3f const &amp;other) const;</span>
<span class="s0">inline LVector3f LVector3f::operator -(LVector3f const &amp;other) const;</span>

<span class="s0">2557 5 cross 0 4 3628 16 LVector3f::cross 0 1 618 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LVector3f LVector3f::cross(LVecBase3f const &amp;other) const;</span>

<span class="s0">2558 10 normalized 0 4 3628 21 LVector3f::normalized 0 1 619 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline LVector3f LVector3f::normalized(void) const;</span>

<span class="s0">2559 7 project 0 4 3628 18 LVector3f::project 0 1 620 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVector3f LVector3f::project(LVecBase3f const &amp;onto) const;</span>

<span class="s0">2560 9 angle_rad 0 4 3628 20 LVector3f::angle_rad 0 1 621 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the unsigned angle between this vector and the other one, expressed</span>
 <span class="s0">* in radians.  Both vectors should be initially normalized.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline float LVector3f::angle_rad(LVector3f const &amp;other) const;</span>

<span class="s0">2561 9 angle_deg 0 4 3628 20 LVector3f::angle_deg 0 1 622 138</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the angle between this vector and the other one, expressed in</span>
 <span class="s0">* degrees.  Both vectors should be initially normalized.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline float LVector3f::angle_deg(LVector3f const &amp;other) const;</span>

<span class="s0">2562 16 signed_angle_rad 0 4 3628 27 LVector3f::signed_angle_rad 0 1 623 259</span>
<span class="s0">/**</span>
 <span class="s0">* returns the signed angle between two vectors.  The angle is positive if the</span>
 <span class="s0">* rotation from this vector to other is clockwise when looking in the</span>
 <span class="s0">* direction of the ref vector.</span>
 <span class="s0">*</span>
 <span class="s0">* Vectors (except the ref vector) should be initially normalized.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">inline float LVector3f::signed_angle_rad(LVector3f const &amp;other, LVector3f const &amp;ref) const;</span>

<span class="s0">2563 16 signed_angle_deg 0 4 3628 27 LVector3f::signed_angle_deg 0 1 624 259</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the signed angle between two vectors.  The angle is positive if the</span>
 <span class="s0">* rotation from this vector to other is clockwise when looking in the</span>
 <span class="s0">* direction of the ref vector.</span>
 <span class="s0">*</span>
 <span class="s0">* Vectors (except the ref vector) should be initially normalized.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">inline float LVector3f::signed_angle_deg(LVector3f const &amp;other, LVector3f const &amp;ref) const;</span>

<span class="s0">2564 18 relative_angle_rad 0 4 3628 29 LVector3f::relative_angle_rad 0 1 625 34</span>
<span class="s0">/**</span>
 <span class="s0">* @deprecated Do not use.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline float LVector3f::relative_angle_rad(LVector3f const &amp;other) const;</span>

<span class="s0">2565 18 relative_angle_deg 0 4 3628 29 LVector3f::relative_angle_deg 0 1 626 34</span>
<span class="s0">/**</span>
 <span class="s0">* @deprecated Do not use.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline float LVector3f::relative_angle_deg(LVector3f const &amp;other) const;</span>

<span class="s0">2566 10 operator * 0 4 3628 21 LVector3f::operator * 0 1 627 0</span>
<span class="s0">59</span>
<span class="s0">inline LVector3f LVector3f::operator *(float scalar) const;</span>

<span class="s0">2567 10 operator / 0 4 3628 21 LVector3f::operator / 0 1 628 0</span>
<span class="s0">59</span>
<span class="s0">inline LVector3f LVector3f::operator /(float scalar) const;</span>

<span class="s0">2568 2 up 0 4 3628 13 LVector3f::up 0 1 629 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the up vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2569 5 right 0 4 3628 16 LVector3f::right 0 1 630 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the right vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2570 7 forward 0 4 3628 18 LVector3f::forward 0 1 631 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the forward vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2571 4 down 0 4 3628 15 LVector3f::down 0 1 632 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the down vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2572 4 left 0 4 3628 15 LVector3f::left 0 1 633 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the left vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2573 4 back 0 4 3628 15 LVector3f::back 0 1 634 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the back vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2574 3 rfu 0 4 3628 14 LVector3f::rfu 0 1 635 221</span>
<span class="s0">// INLINE_LINMATH static FLOATNAME(LVector3) &amp; rfu(FLOATTYPE right,</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a vector that is described by its right, forward, and up</span>
 <span class="s0">* components, in whatever way the coordinate system represents that vector.</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2575 8 __repr__ 0 4 3628 19 LVector3f::__repr__ 0 1 636 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LVector3f::__repr__(void) const;</span>

<span class="s0">2576 14 get_class_type 0 4 3628 25 LVector3f::get_class_type 0 1 637 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LVector3f::get_class_type(void);</span>

<span class="s0">2577 10 ~LVector3f 0 516 3628 21 LVector3f::~LVector3f 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LVector3f::~LVector3f(void);</span>

<span class="s0">2578 9 LVector3d 0 260 3629 20 LVector3d::LVector3d 0 6 638 639 640 641 642 643 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">325</span>
<span class="s0">inline LVector3d::LVector3d(void) = default;</span>
<span class="s0">inline LVector3d::LVector3d(LVecBase3d const &amp;copy);</span>
<span class="s0">inline LVector3d::LVector3d(double fill_value);</span>
<span class="s0">inline LVector3d::LVector3d(double x, double y, double z);</span>
<span class="s0">inline LVector3d::LVector3d(LVecBase2d const &amp;copy, double z);</span>
<span class="s0">inline LVector3d::LVector3d(LVector3d const &amp;) = default;</span>

<span class="s0">2579 11 __getattr__ 0 4 3629 22 LVector3d::__getattr__ 0 1 644 0</span>
<span class="s0">92</span>
<span class="s0">inline PyObject *LVector3d::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2580 11 __setattr__ 0 4 3629 22 LVector3d::__setattr__ 0 1 645 0</span>
<span class="s0">98</span>
<span class="s0">inline int LVector3d::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2581 4 zero 0 4 3629 15 LVector3d::zero 0 1 646 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LVector3d const &amp;LVector3d::zero(void);</span>

<span class="s0">2582 6 unit_x 0 4 3629 17 LVector3d::unit_x 0 1 647 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector3d const &amp;LVector3d::unit_x(void);</span>

<span class="s0">2583 6 unit_y 0 4 3629 17 LVector3d::unit_y 0 1 648 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector3d const &amp;LVector3d::unit_y(void);</span>

<span class="s0">2584 6 unit_z 0 4 3629 17 LVector3d::unit_z 0 1 649 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector3d const &amp;LVector3d::unit_z(void);</span>

<span class="s0">2585 6 get_xy 0 4 3629 17 LVector3d::get_xy 0 1 650 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2d LVector3d::get_xy(void) const;</span>

<span class="s0">2586 6 get_xz 0 4 3629 17 LVector3d::get_xz 0 1 651 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2d LVector3d::get_xz(void) const;</span>

<span class="s0">2587 6 get_yz 0 4 3629 17 LVector3d::get_yz 0 1 652 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2d LVector3d::get_yz(void) const;</span>

<span class="s0">2588 10 operator - 0 68 3629 21 LVector3d::operator - 0 1 653 0</span>
<span class="s0">51</span>
<span class="s0">inline LVector3d LVector3d::operator -(void) const;</span>

<span class="s0">2589 10 operator + 0 4 3629 21 LVector3d::operator + 0 2 654 655 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase3d LVector3d::operator +(LVecBase3d const &amp;other) const;</span>
<span class="s0">inline LVector3d LVector3d::operator +(LVector3d const &amp;other) const;</span>

<span class="s0">2590 10 operator - 0 4 3629 21 LVector3d::operator - 0 2 656 657 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase3d LVector3d::operator -(LVecBase3d const &amp;other) const;</span>
<span class="s0">inline LVector3d LVector3d::operator -(LVector3d const &amp;other) const;</span>

<span class="s0">2591 5 cross 0 4 3629 16 LVector3d::cross 0 1 658 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LVector3d LVector3d::cross(LVecBase3d const &amp;other) const;</span>

<span class="s0">2592 10 normalized 0 4 3629 21 LVector3d::normalized 0 1 659 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline LVector3d LVector3d::normalized(void) const;</span>

<span class="s0">2593 7 project 0 4 3629 18 LVector3d::project 0 1 660 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVector3d LVector3d::project(LVecBase3d const &amp;onto) const;</span>

<span class="s0">2594 9 angle_rad 0 4 3629 20 LVector3d::angle_rad 0 1 661 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the unsigned angle between this vector and the other one, expressed</span>
 <span class="s0">* in radians.  Both vectors should be initially normalized.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline double LVector3d::angle_rad(LVector3d const &amp;other) const;</span>

<span class="s0">2595 9 angle_deg 0 4 3629 20 LVector3d::angle_deg 0 1 662 138</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the angle between this vector and the other one, expressed in</span>
 <span class="s0">* degrees.  Both vectors should be initially normalized.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline double LVector3d::angle_deg(LVector3d const &amp;other) const;</span>

<span class="s0">2596 16 signed_angle_rad 0 4 3629 27 LVector3d::signed_angle_rad 0 1 663 259</span>
<span class="s0">/**</span>
 <span class="s0">* returns the signed angle between two vectors.  The angle is positive if the</span>
 <span class="s0">* rotation from this vector to other is clockwise when looking in the</span>
 <span class="s0">* direction of the ref vector.</span>
 <span class="s0">*</span>
 <span class="s0">* Vectors (except the ref vector) should be initially normalized.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">inline double LVector3d::signed_angle_rad(LVector3d const &amp;other, LVector3d const &amp;ref) const;</span>

<span class="s0">2597 16 signed_angle_deg 0 4 3629 27 LVector3d::signed_angle_deg 0 1 664 259</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the signed angle between two vectors.  The angle is positive if the</span>
 <span class="s0">* rotation from this vector to other is clockwise when looking in the</span>
 <span class="s0">* direction of the ref vector.</span>
 <span class="s0">*</span>
 <span class="s0">* Vectors (except the ref vector) should be initially normalized.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">inline double LVector3d::signed_angle_deg(LVector3d const &amp;other, LVector3d const &amp;ref) const;</span>

<span class="s0">2598 18 relative_angle_rad 0 4 3629 29 LVector3d::relative_angle_rad 0 1 665 34</span>
<span class="s0">/**</span>
 <span class="s0">* @deprecated Do not use.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline double LVector3d::relative_angle_rad(LVector3d const &amp;other) const;</span>

<span class="s0">2599 18 relative_angle_deg 0 4 3629 29 LVector3d::relative_angle_deg 0 1 666 34</span>
<span class="s0">/**</span>
 <span class="s0">* @deprecated Do not use.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline double LVector3d::relative_angle_deg(LVector3d const &amp;other) const;</span>

<span class="s0">2600 10 operator * 0 4 3629 21 LVector3d::operator * 0 1 667 0</span>
<span class="s0">60</span>
<span class="s0">inline LVector3d LVector3d::operator *(double scalar) const;</span>

<span class="s0">2601 10 operator / 0 4 3629 21 LVector3d::operator / 0 1 668 0</span>
<span class="s0">60</span>
<span class="s0">inline LVector3d LVector3d::operator /(double scalar) const;</span>

<span class="s0">2602 2 up 0 4 3629 13 LVector3d::up 0 1 669 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the up vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2603 5 right 0 4 3629 16 LVector3d::right 0 1 670 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the right vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2604 7 forward 0 4 3629 18 LVector3d::forward 0 1 671 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the forward vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2605 4 down 0 4 3629 15 LVector3d::down 0 1 672 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the down vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2606 4 left 0 4 3629 15 LVector3d::left 0 1 673 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the left vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2607 4 back 0 4 3629 15 LVector3d::back 0 1 674 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the back vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2608 3 rfu 0 4 3629 14 LVector3d::rfu 0 1 675 221</span>
<span class="s0">// INLINE_LINMATH static FLOATNAME(LVector3) &amp; rfu(FLOATTYPE right,</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a vector that is described by its right, forward, and up</span>
 <span class="s0">* components, in whatever way the coordinate system represents that vector.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2609 8 __repr__ 0 4 3629 19 LVector3d::__repr__ 0 1 676 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LVector3d::__repr__(void) const;</span>

<span class="s0">2610 14 get_class_type 0 4 3629 25 LVector3d::get_class_type 0 1 677 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LVector3d::get_class_type(void);</span>

<span class="s0">2611 10 ~LVector3d 0 516 3629 21 LVector3d::~LVector3d 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LVector3d::~LVector3d(void);</span>

<span class="s0">2612 9 LVector3i 0 260 3630 20 LVector3i::LVector3i 0 6 678 679 680 681 682 683 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">310</span>
<span class="s0">inline LVector3i::LVector3i(void) = default;</span>
<span class="s0">inline LVector3i::LVector3i(LVecBase3i const &amp;copy);</span>
<span class="s0">inline LVector3i::LVector3i(int fill_value);</span>
<span class="s0">inline LVector3i::LVector3i(int x, int y, int z);</span>
<span class="s0">inline LVector3i::LVector3i(LVecBase2i const &amp;copy, int z);</span>
<span class="s0">inline LVector3i::LVector3i(LVector3i const &amp;) = default;</span>

<span class="s0">2613 11 __getattr__ 0 4 3630 22 LVector3i::__getattr__ 0 1 684 0</span>
<span class="s0">92</span>
<span class="s0">inline PyObject *LVector3i::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2614 11 __setattr__ 0 4 3630 22 LVector3i::__setattr__ 0 1 685 0</span>
<span class="s0">98</span>
<span class="s0">inline int LVector3i::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2615 4 zero 0 4 3630 15 LVector3i::zero 0 1 686 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LVector3i const &amp;LVector3i::zero(void);</span>

<span class="s0">2616 6 unit_x 0 4 3630 17 LVector3i::unit_x 0 1 687 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector3i const &amp;LVector3i::unit_x(void);</span>

<span class="s0">2617 6 unit_y 0 4 3630 17 LVector3i::unit_y 0 1 688 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector3i const &amp;LVector3i::unit_y(void);</span>

<span class="s0">2618 6 unit_z 0 4 3630 17 LVector3i::unit_z 0 1 689 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector3i const &amp;LVector3i::unit_z(void);</span>

<span class="s0">2619 6 get_xy 0 4 3630 17 LVector3i::get_xy 0 1 690 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2i LVector3i::get_xy(void) const;</span>

<span class="s0">2620 6 get_xz 0 4 3630 17 LVector3i::get_xz 0 1 691 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2i LVector3i::get_xz(void) const;</span>

<span class="s0">2621 6 get_yz 0 4 3630 17 LVector3i::get_yz 0 1 692 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2i LVector3i::get_yz(void) const;</span>

<span class="s0">2622 10 operator - 0 68 3630 21 LVector3i::operator - 0 1 693 0</span>
<span class="s0">51</span>
<span class="s0">inline LVector3i LVector3i::operator -(void) const;</span>

<span class="s0">2623 10 operator + 0 4 3630 21 LVector3i::operator + 0 2 694 695 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase3i LVector3i::operator +(LVecBase3i const &amp;other) const;</span>
<span class="s0">inline LVector3i LVector3i::operator +(LVector3i const &amp;other) const;</span>

<span class="s0">2624 10 operator - 0 4 3630 21 LVector3i::operator - 0 2 696 697 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase3i LVector3i::operator -(LVecBase3i const &amp;other) const;</span>
<span class="s0">inline LVector3i LVector3i::operator -(LVector3i const &amp;other) const;</span>

<span class="s0">2625 5 cross 0 4 3630 16 LVector3i::cross 0 1 698 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LVector3i LVector3i::cross(LVecBase3i const &amp;other) const;</span>

<span class="s0">2626 10 operator * 0 4 3630 21 LVector3i::operator * 0 1 699 0</span>
<span class="s0">57</span>
<span class="s0">inline LVector3i LVector3i::operator *(int scalar) const;</span>

<span class="s0">2627 10 operator / 0 4 3630 21 LVector3i::operator / 0 1 700 0</span>
<span class="s0">57</span>
<span class="s0">inline LVector3i LVector3i::operator /(int scalar) const;</span>

<span class="s0">2628 2 up 0 4 3630 13 LVector3i::up 0 1 701 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the up vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2629 5 right 0 4 3630 16 LVector3i::right 0 1 702 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the right vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2630 7 forward 0 4 3630 18 LVector3i::forward 0 1 703 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the forward vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2631 4 down 0 4 3630 15 LVector3i::down 0 1 704 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the down vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2632 4 left 0 4 3630 15 LVector3i::left 0 1 705 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the left vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2633 4 back 0 4 3630 15 LVector3i::back 0 1 706 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the back vector for the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2634 3 rfu 0 4 3630 14 LVector3i::rfu 0 1 707 221</span>
<span class="s0">// INLINE_LINMATH static FLOATNAME(LVector3) &amp; rfu(FLOATTYPE right,</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a vector that is described by its right, forward, and up</span>
 <span class="s0">* components, in whatever way the coordinate system represents that vector.</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2635 8 __repr__ 0 4 3630 19 LVector3i::__repr__ 0 1 708 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LVector3i::__repr__(void) const;</span>

<span class="s0">2636 14 get_class_type 0 4 3630 25 LVector3i::get_class_type 0 1 709 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LVector3i::get_class_type(void);</span>

<span class="s0">2637 10 ~LVector3i 0 516 3630 21 LVector3i::~LVector3i 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LVector3i::~LVector3i(void);</span>

<span class="s0">2638 8 LPoint3f 0 260 3631 18 LPoint3f::LPoint3f 0 6 710 711 712 713 714 715 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">307</span>
<span class="s0">inline LPoint3f::LPoint3f(void) = default;</span>
<span class="s0">inline LPoint3f::LPoint3f(LVecBase3f const &amp;copy);</span>
<span class="s0">inline LPoint3f::LPoint3f(float fill_value);</span>
<span class="s0">inline LPoint3f::LPoint3f(float x, float y, float z);</span>
<span class="s0">inline LPoint3f::LPoint3f(LVecBase2f const &amp;copy, float z);</span>
<span class="s0">inline LPoint3f::LPoint3f(LPoint3f const &amp;) = default;</span>

<span class="s0">2639 11 __getattr__ 0 4 3631 21 LPoint3f::__getattr__ 0 1 716 0</span>
<span class="s0">91</span>
<span class="s0">inline PyObject *LPoint3f::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2640 11 __setattr__ 0 4 3631 21 LPoint3f::__setattr__ 0 1 717 0</span>
<span class="s0">97</span>
<span class="s0">inline int LPoint3f::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2641 4 zero 0 4 3631 14 LPoint3f::zero 0 1 718 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline LPoint3f const &amp;LPoint3f::zero(void);</span>

<span class="s0">2642 6 unit_x 0 4 3631 16 LPoint3f::unit_x 0 1 719 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint3f const &amp;LPoint3f::unit_x(void);</span>

<span class="s0">2643 6 unit_y 0 4 3631 16 LPoint3f::unit_y 0 1 720 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint3f const &amp;LPoint3f::unit_y(void);</span>

<span class="s0">2644 6 unit_z 0 4 3631 16 LPoint3f::unit_z 0 1 721 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint3f const &amp;LPoint3f::unit_z(void);</span>

<span class="s0">2645 6 get_xy 0 4 3631 16 LPoint3f::get_xy 0 1 722 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2f LPoint3f::get_xy(void) const;</span>

<span class="s0">2646 6 get_xz 0 4 3631 16 LPoint3f::get_xz 0 1 723 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2f LPoint3f::get_xz(void) const;</span>

<span class="s0">2647 6 get_yz 0 4 3631 16 LPoint3f::get_yz 0 1 724 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2f LPoint3f::get_yz(void) const;</span>

<span class="s0">2648 10 operator - 0 68 3631 20 LPoint3f::operator - 0 1 725 0</span>
<span class="s0">49</span>
<span class="s0">inline LPoint3f LPoint3f::operator -(void) const;</span>

<span class="s0">2649 10 operator + 0 4 3631 20 LPoint3f::operator + 0 2 726 727 0</span>
<span class="s0">138</span>
<span class="s0">inline LVecBase3f LPoint3f::operator +(LVecBase3f const &amp;other) const;</span>
<span class="s0">inline LPoint3f LPoint3f::operator +(LVector3f const &amp;other) const;</span>

<span class="s0">2650 10 operator - 0 4 3631 20 LPoint3f::operator - 0 3 728 729 730 0</span>
<span class="s0">206</span>
<span class="s0">inline LVecBase3f LPoint3f::operator -(LVecBase3f const &amp;other) const;</span>
<span class="s0">inline LVector3f LPoint3f::operator -(LPoint3f const &amp;other) const;</span>
<span class="s0">inline LPoint3f LPoint3f::operator -(LVector3f const &amp;other) const;</span>

<span class="s0">2651 5 cross 0 4 3631 15 LPoint3f::cross 0 1 731 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LPoint3f LPoint3f::cross(LVecBase3f const &amp;other) const;</span>

<span class="s0">2652 10 normalized 0 4 3631 20 LPoint3f::normalized 0 1 732 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LPoint3f LPoint3f::normalized(void) const;</span>

<span class="s0">2653 7 project 0 4 3631 17 LPoint3f::project 0 1 733 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LPoint3f LPoint3f::project(LVecBase3f const &amp;onto) const;</span>

<span class="s0">2654 10 operator * 0 4 3631 20 LPoint3f::operator * 0 1 734 0</span>
<span class="s0">57</span>
<span class="s0">inline LPoint3f LPoint3f::operator *(float scalar) const;</span>

<span class="s0">2655 10 operator / 0 4 3631 20 LPoint3f::operator / 0 1 735 0</span>
<span class="s0">57</span>
<span class="s0">inline LPoint3f LPoint3f::operator /(float scalar) const;</span>

<span class="s0">2656 6 origin 0 4 3631 16 LPoint3f::origin 0 1 736 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the origin of the indicated coordinate system.  This is always 0,</span>
 <span class="s0">* 0, 0 with all of our existing coordinate systems; it's hard to imagine it</span>
 <span class="s0">* ever being different.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">static inline LPoint3f const &amp;LPoint3f::origin(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2657 3 rfu 0 4 3631 13 LPoint3f::rfu 0 1 737 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a point described by right, forward, up displacements from the</span>
 <span class="s0">* origin, wherever that maps to in the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2658 8 __repr__ 0 4 3631 18 LPoint3f::__repr__ 0 1 738 0</span>
<span class="s0">50</span>
<span class="s0">inline std::string LPoint3f::__repr__(void) const;</span>

<span class="s0">2659 14 get_class_type 0 4 3631 24 LPoint3f::get_class_type 0 1 739 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle LPoint3f::get_class_type(void);</span>

<span class="s0">2660 9 ~LPoint3f 0 516 3631 19 LPoint3f::~LPoint3f 0 0 0</span>
<span class="s0">26</span>
<span class="s0">LPoint3f::~LPoint3f(void);</span>

<span class="s0">2661 8 LPoint3d 0 260 3632 18 LPoint3d::LPoint3d 0 6 740 741 742 743 744 745 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">312</span>
<span class="s0">inline LPoint3d::LPoint3d(void) = default;</span>
<span class="s0">inline LPoint3d::LPoint3d(LVecBase3d const &amp;copy);</span>
<span class="s0">inline LPoint3d::LPoint3d(double fill_value);</span>
<span class="s0">inline LPoint3d::LPoint3d(double x, double y, double z);</span>
<span class="s0">inline LPoint3d::LPoint3d(LVecBase2d const &amp;copy, double z);</span>
<span class="s0">inline LPoint3d::LPoint3d(LPoint3d const &amp;) = default;</span>

<span class="s0">2662 11 __getattr__ 0 4 3632 21 LPoint3d::__getattr__ 0 1 746 0</span>
<span class="s0">91</span>
<span class="s0">inline PyObject *LPoint3d::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2663 11 __setattr__ 0 4 3632 21 LPoint3d::__setattr__ 0 1 747 0</span>
<span class="s0">97</span>
<span class="s0">inline int LPoint3d::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2664 4 zero 0 4 3632 14 LPoint3d::zero 0 1 748 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline LPoint3d const &amp;LPoint3d::zero(void);</span>

<span class="s0">2665 6 unit_x 0 4 3632 16 LPoint3d::unit_x 0 1 749 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint3d const &amp;LPoint3d::unit_x(void);</span>

<span class="s0">2666 6 unit_y 0 4 3632 16 LPoint3d::unit_y 0 1 750 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint3d const &amp;LPoint3d::unit_y(void);</span>

<span class="s0">2667 6 unit_z 0 4 3632 16 LPoint3d::unit_z 0 1 751 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint3d const &amp;LPoint3d::unit_z(void);</span>

<span class="s0">2668 6 get_xy 0 4 3632 16 LPoint3d::get_xy 0 1 752 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2d LPoint3d::get_xy(void) const;</span>

<span class="s0">2669 6 get_xz 0 4 3632 16 LPoint3d::get_xz 0 1 753 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2d LPoint3d::get_xz(void) const;</span>

<span class="s0">2670 6 get_yz 0 4 3632 16 LPoint3d::get_yz 0 1 754 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2d LPoint3d::get_yz(void) const;</span>

<span class="s0">2671 10 operator - 0 68 3632 20 LPoint3d::operator - 0 1 755 0</span>
<span class="s0">49</span>
<span class="s0">inline LPoint3d LPoint3d::operator -(void) const;</span>

<span class="s0">2672 10 operator + 0 4 3632 20 LPoint3d::operator + 0 2 756 757 0</span>
<span class="s0">138</span>
<span class="s0">inline LVecBase3d LPoint3d::operator +(LVecBase3d const &amp;other) const;</span>
<span class="s0">inline LPoint3d LPoint3d::operator +(LVector3d const &amp;other) const;</span>

<span class="s0">2673 10 operator - 0 4 3632 20 LPoint3d::operator - 0 3 758 759 760 0</span>
<span class="s0">206</span>
<span class="s0">inline LVecBase3d LPoint3d::operator -(LVecBase3d const &amp;other) const;</span>
<span class="s0">inline LVector3d LPoint3d::operator -(LPoint3d const &amp;other) const;</span>
<span class="s0">inline LPoint3d LPoint3d::operator -(LVector3d const &amp;other) const;</span>

<span class="s0">2674 5 cross 0 4 3632 15 LPoint3d::cross 0 1 761 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LPoint3d LPoint3d::cross(LVecBase3d const &amp;other) const;</span>

<span class="s0">2675 10 normalized 0 4 3632 20 LPoint3d::normalized 0 1 762 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LPoint3d LPoint3d::normalized(void) const;</span>

<span class="s0">2676 7 project 0 4 3632 17 LPoint3d::project 0 1 763 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LPoint3d LPoint3d::project(LVecBase3d const &amp;onto) const;</span>

<span class="s0">2677 10 operator * 0 4 3632 20 LPoint3d::operator * 0 1 764 0</span>
<span class="s0">58</span>
<span class="s0">inline LPoint3d LPoint3d::operator *(double scalar) const;</span>

<span class="s0">2678 10 operator / 0 4 3632 20 LPoint3d::operator / 0 1 765 0</span>
<span class="s0">58</span>
<span class="s0">inline LPoint3d LPoint3d::operator /(double scalar) const;</span>

<span class="s0">2679 6 origin 0 4 3632 16 LPoint3d::origin 0 1 766 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the origin of the indicated coordinate system.  This is always 0,</span>
 <span class="s0">* 0, 0 with all of our existing coordinate systems; it's hard to imagine it</span>
 <span class="s0">* ever being different.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">static inline LPoint3d const &amp;LPoint3d::origin(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2680 3 rfu 0 4 3632 13 LPoint3d::rfu 0 1 767 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a point described by right, forward, up displacements from the</span>
 <span class="s0">* origin, wherever that maps to in the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2681 8 __repr__ 0 4 3632 18 LPoint3d::__repr__ 0 1 768 0</span>
<span class="s0">50</span>
<span class="s0">inline std::string LPoint3d::__repr__(void) const;</span>

<span class="s0">2682 14 get_class_type 0 4 3632 24 LPoint3d::get_class_type 0 1 769 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle LPoint3d::get_class_type(void);</span>

<span class="s0">2683 9 ~LPoint3d 0 516 3632 19 LPoint3d::~LPoint3d 0 0 0</span>
<span class="s0">26</span>
<span class="s0">LPoint3d::~LPoint3d(void);</span>

<span class="s0">2684 8 LPoint3i 0 260 3633 18 LPoint3i::LPoint3i 0 6 770 771 772 773 774 775 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">297</span>
<span class="s0">inline LPoint3i::LPoint3i(void) = default;</span>
<span class="s0">inline LPoint3i::LPoint3i(LVecBase3i const &amp;copy);</span>
<span class="s0">inline LPoint3i::LPoint3i(int fill_value);</span>
<span class="s0">inline LPoint3i::LPoint3i(int x, int y, int z);</span>
<span class="s0">inline LPoint3i::LPoint3i(LVecBase2i const &amp;copy, int z);</span>
<span class="s0">inline LPoint3i::LPoint3i(LPoint3i const &amp;) = default;</span>

<span class="s0">2685 11 __getattr__ 0 4 3633 21 LPoint3i::__getattr__ 0 1 776 0</span>
<span class="s0">91</span>
<span class="s0">inline PyObject *LPoint3i::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2686 11 __setattr__ 0 4 3633 21 LPoint3i::__setattr__ 0 1 777 0</span>
<span class="s0">97</span>
<span class="s0">inline int LPoint3i::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2687 4 zero 0 4 3633 14 LPoint3i::zero 0 1 778 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline LPoint3i const &amp;LPoint3i::zero(void);</span>

<span class="s0">2688 6 unit_x 0 4 3633 16 LPoint3i::unit_x 0 1 779 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint3i const &amp;LPoint3i::unit_x(void);</span>

<span class="s0">2689 6 unit_y 0 4 3633 16 LPoint3i::unit_y 0 1 780 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint3i const &amp;LPoint3i::unit_y(void);</span>

<span class="s0">2690 6 unit_z 0 4 3633 16 LPoint3i::unit_z 0 1 781 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint3i const &amp;LPoint3i::unit_z(void);</span>

<span class="s0">2691 6 get_xy 0 4 3633 16 LPoint3i::get_xy 0 1 782 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2i LPoint3i::get_xy(void) const;</span>

<span class="s0">2692 6 get_xz 0 4 3633 16 LPoint3i::get_xz 0 1 783 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2i LPoint3i::get_xz(void) const;</span>

<span class="s0">2693 6 get_yz 0 4 3633 16 LPoint3i::get_yz 0 1 784 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2i LPoint3i::get_yz(void) const;</span>

<span class="s0">2694 10 operator - 0 68 3633 20 LPoint3i::operator - 0 1 785 0</span>
<span class="s0">49</span>
<span class="s0">inline LPoint3i LPoint3i::operator -(void) const;</span>

<span class="s0">2695 10 operator + 0 4 3633 20 LPoint3i::operator + 0 2 786 787 0</span>
<span class="s0">138</span>
<span class="s0">inline LVecBase3i LPoint3i::operator +(LVecBase3i const &amp;other) const;</span>
<span class="s0">inline LPoint3i LPoint3i::operator +(LVector3i const &amp;other) const;</span>

<span class="s0">2696 10 operator - 0 4 3633 20 LPoint3i::operator - 0 3 788 789 790 0</span>
<span class="s0">206</span>
<span class="s0">inline LVecBase3i LPoint3i::operator -(LVecBase3i const &amp;other) const;</span>
<span class="s0">inline LVector3i LPoint3i::operator -(LPoint3i const &amp;other) const;</span>
<span class="s0">inline LPoint3i LPoint3i::operator -(LVector3i const &amp;other) const;</span>

<span class="s0">2697 5 cross 0 4 3633 15 LPoint3i::cross 0 1 791 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LPoint3i LPoint3i::cross(LVecBase3i const &amp;other) const;</span>

<span class="s0">2698 10 operator * 0 4 3633 20 LPoint3i::operator * 0 1 792 0</span>
<span class="s0">55</span>
<span class="s0">inline LPoint3i LPoint3i::operator *(int scalar) const;</span>

<span class="s0">2699 10 operator / 0 4 3633 20 LPoint3i::operator / 0 1 793 0</span>
<span class="s0">55</span>
<span class="s0">inline LPoint3i LPoint3i::operator /(int scalar) const;</span>

<span class="s0">2700 6 origin 0 4 3633 16 LPoint3i::origin 0 1 794 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the origin of the indicated coordinate system.  This is always 0,</span>
 <span class="s0">* 0, 0 with all of our existing coordinate systems; it's hard to imagine it</span>
 <span class="s0">* ever being different.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">static inline LPoint3i const &amp;LPoint3i::origin(CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2701 3 rfu 0 4 3633 13 LPoint3i::rfu 0 1 795 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a point described by right, forward, up displacements from the</span>
 <span class="s0">* origin, wherever that maps to in the given coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">2702 8 __repr__ 0 4 3633 18 LPoint3i::__repr__ 0 1 796 0</span>
<span class="s0">50</span>
<span class="s0">inline std::string LPoint3i::__repr__(void) const;</span>

<span class="s0">2703 14 get_class_type 0 4 3633 24 LPoint3i::get_class_type 0 1 797 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle LPoint3i::get_class_type(void);</span>

<span class="s0">2704 9 ~LPoint3i 0 516 3633 19 LPoint3i::~LPoint3i 0 0 0</span>
<span class="s0">26</span>
<span class="s0">LPoint3i::~LPoint3i(void);</span>

<span class="s0">2705 10 LVecBase4f 0 260 3634 22 LVecBase4f::LVecBase4f 0 8 798 799 800 801 802 803 804 805 219</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.</span>
 <span class="s0">*/</span>
<span class="s0">461</span>
<span class="s0">inline LVecBase4f::LVecBase4f(void) = default;</span>
<span class="s0">inline LVecBase4f::LVecBase4f(float fill_value);</span>
<span class="s0">inline LVecBase4f::LVecBase4f(float x, float y, float z, float w);</span>
<span class="s0">inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &amp;copy);</span>
<span class="s0">inline LVecBase4f::LVecBase4f(LVecBase3f const &amp;copy, float w);</span>
<span class="s0">inline LVecBase4f::LVecBase4f(LPoint3f const &amp;point);</span>
<span class="s0">inline LVecBase4f::LVecBase4f(LVector3f const &amp;vector);</span>
<span class="s0">inline LVecBase4f::LVecBase4f(LVecBase4f const &amp;) = default;</span>

<span class="s0">2706 12 operator new 0 4 3634 24 LVecBase4f::operator new 0 1 806 0</span>
<span class="s0">124</span>
<span class="s0">inline void *LVecBase4f::operator new(std::size_t size);</span>
<span class="s0">inline void *LVecBase4f::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2707 15 operator delete 0 4 3634 27 LVecBase4f::operator delete 0 0 0</span>
<span class="s0">108</span>
<span class="s0">inline void LVecBase4f::operator delete(void *ptr);</span>
<span class="s0">inline void LVecBase4f::operator delete(void *, void *);</span>

<span class="s0">2708 12 validate_ptr 0 4 3634 24 LVecBase4f::validate_ptr 0 0 0</span>
<span class="s0">61</span>
<span class="s0">static inline bool LVecBase4f::validate_ptr(void const *ptr);</span>

<span class="s0">2709 10 operator = 0 4 3634 22 LVecBase4f::operator = 0 2 807 808 0</span>
<span class="s0">119</span>
<span class="s0">void LVecBase4f::operator =(LVecBase4f const &amp;copy) = default;</span>
<span class="s0">void LVecBase4f::operator =(float fill_value) = default;</span>

<span class="s0">2710 4 zero 0 4 3634 16 LVecBase4f::zero 0 1 809 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVecBase4f const &amp;LVecBase4f::zero(void);</span>

<span class="s0">2711 6 unit_x 0 4 3634 18 LVecBase4f::unit_x 0 1 810 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4f const &amp;LVecBase4f::unit_x(void);</span>

<span class="s0">2712 6 unit_y 0 4 3634 18 LVecBase4f::unit_y 0 1 811 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4f const &amp;LVecBase4f::unit_y(void);</span>

<span class="s0">2713 6 unit_z 0 4 3634 18 LVecBase4f::unit_z 0 1 812 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4f const &amp;LVecBase4f::unit_z(void);</span>

<span class="s0">2714 6 unit_w 0 4 3634 18 LVecBase4f::unit_w 0 1 813 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4f const &amp;LVecBase4f::unit_w(void);</span>

<span class="s0">2715 10 __reduce__ 0 4 3634 22 LVecBase4f::__reduce__ 0 1 814 0</span>
<span class="s0">62</span>
<span class="s0">inline PyObject *LVecBase4f::__reduce__(PyObject *self) const;</span>

<span class="s0">2716 11 __getattr__ 0 4 3634 23 LVecBase4f::__getattr__ 0 1 815 0</span>
<span class="s0">93</span>
<span class="s0">inline PyObject *LVecBase4f::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2717 11 __setattr__ 0 4 3634 23 LVecBase4f::__setattr__ 0 1 816 0</span>
<span class="s0">99</span>
<span class="s0">inline int LVecBase4f::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2718 11 operator [] 0 4 3634 23 LVecBase4f::operator [] 0 2 817 818 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline float LVecBase4f::operator [](int i) const;</span>
<span class="s0">inline float &amp;LVecBase4f::operator [](int i);</span>

<span class="s0">2719 4 size 0 4 3634 16 LVecBase4f::size 0 1 819 0</span>
<span class="s0">44</span>
<span class="s0">static constexpr int LVecBase4f::size(void);</span>

<span class="s0">2720 6 is_nan 0 4 3634 18 LVecBase4f::is_nan 0 1 820 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool LVecBase4f::is_nan(void) const;</span>

<span class="s0">2721 8 get_cell 0 4 3634 20 LVecBase4f::get_cell 0 1 821 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline float LVecBase4f::get_cell(int i) const;</span>

<span class="s0">2722 8 set_cell 0 4 3634 20 LVecBase4f::set_cell 0 1 822 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void LVecBase4f::set_cell(int i, float value);</span>

<span class="s0">2723 5 get_x 0 4 3634 17 LVecBase4f::get_x 0 1 823 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline float LVecBase4f::get_x(void) const;</span>

<span class="s0">2724 5 get_y 0 4 3634 17 LVecBase4f::get_y 0 1 824 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline float LVecBase4f::get_y(void) const;</span>

<span class="s0">2725 5 get_z 0 4 3634 17 LVecBase4f::get_z 0 1 825 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline float LVecBase4f::get_z(void) const;</span>

<span class="s0">2726 5 get_w 0 4 3634 17 LVecBase4f::get_w 0 1 826 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline float LVecBase4f::get_w(void) const;</span>

<span class="s0">2727 7 get_xyz 0 4 3634 19 LVecBase4f::get_xyz 0 1 827 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline LVecBase3f LVecBase4f::get_xyz(void) const;</span>

<span class="s0">2728 6 get_xy 0 4 3634 18 LVecBase4f::get_xy 0 1 828 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2f LVecBase4f::get_xy(void) const;</span>

<span class="s0">2729 5 set_x 0 4 3634 17 LVecBase4f::set_x 0 1 829 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase4f::set_x(float value);</span>

<span class="s0">2730 5 set_y 0 4 3634 17 LVecBase4f::set_y 0 1 830 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase4f::set_y(float value);</span>

<span class="s0">2731 5 set_z 0 4 3634 17 LVecBase4f::set_z 0 1 831 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase4f::set_z(float value);</span>

<span class="s0">2732 5 set_w 0 4 3634 17 LVecBase4f::set_w 0 1 832 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase4f::set_w(float value);</span>

<span class="s0">2733 11 add_to_cell 0 4 3634 23 LVecBase4f::add_to_cell 0 1 833 164</span>
<span class="s0">// These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages:</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase4f::add_to_cell(int i, float value);</span>

<span class="s0">2734 5 add_x 0 4 3634 17 LVecBase4f::add_x 0 1 834 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase4f::add_x(float value);</span>

<span class="s0">2735 5 add_y 0 4 3634 17 LVecBase4f::add_y 0 1 835 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase4f::add_y(float value);</span>

<span class="s0">2736 5 add_z 0 4 3634 17 LVecBase4f::add_z 0 1 836 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase4f::add_z(float value);</span>

<span class="s0">2737 5 add_w 0 4 3634 17 LVecBase4f::add_w 0 1 837 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void LVecBase4f::add_w(float value);</span>

<span class="s0">2738 8 get_data 0 4 3634 20 LVecBase4f::get_data 0 1 838 161</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the four data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline float const *LVecBase4f::get_data(void) const;</span>

<span class="s0">2739 18 get_num_components 0 4 3634 30 LVecBase4f::get_num_components 0 1 839 0</span>
<span class="s0">58</span>
<span class="s0">static constexpr int LVecBase4f::get_num_components(void);</span>

<span class="s0">2740 12 extract_data 0 4 3634 24 LVecBase4f::extract_data 0 0 0</span>
<span class="s0">46</span>
<span class="s0">inline void LVecBase4f::extract_data(float *);</span>

<span class="s0">2741 4 fill 0 4 3634 16 LVecBase4f::fill 0 1 840 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void LVecBase4f::fill(float fill_value);</span>

<span class="s0">2742 3 set 0 4 3634 15 LVecBase4f::set 0 1 841 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LVecBase4f::set(float x, float y, float z, float w);</span>

<span class="s0">2743 3 dot 0 4 3634 15 LVecBase4f::dot 0 1 842 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline float LVecBase4f::dot(LVecBase4f const &amp;other) const;</span>

<span class="s0">2744 14 length_squared 0 4 3634 26 LVecBase4f::length_squared 0 1 843 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline float LVecBase4f::length_squared(void) const;</span>

<span class="s0">2745 6 length 0 4 3634 18 LVecBase4f::length 0 1 844 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline float LVecBase4f::length(void) const;</span>

<span class="s0">2746 9 normalize 0 4 3634 21 LVecBase4f::normalize 0 1 845 127</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline bool LVecBase4f::normalize(void);</span>

<span class="s0">2747 10 normalized 0 4 3634 22 LVecBase4f::normalized 0 1 846 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase4f LVecBase4f::normalized(void) const;</span>

<span class="s0">2748 7 project 0 4 3634 19 LVecBase4f::project 0 1 847 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LVecBase4f LVecBase4f::project(LVecBase4f const &amp;onto) const;</span>

<span class="s0">2749 10 operator &lt; 0 4 3634 22 LVecBase4f::operator &lt; 0 1 848 0</span>
<span class="s0">66</span>
<span class="s0">inline bool LVecBase4f::operator &lt;(LVecBase4f const &amp;other) const;</span>

<span class="s0">2750 11 operator == 0 4 3634 23 LVecBase4f::operator == 0 1 849 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase4f::operator ==(LVecBase4f const &amp;other) const;</span>

<span class="s0">2751 11 operator != 0 4 3634 23 LVecBase4f::operator != 0 1 850 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase4f::operator !=(LVecBase4f const &amp;other) const;</span>

<span class="s0">2752 10 compare_to 0 4 3634 22 LVecBase4f::compare_to 0 2 851 852 332</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">inline int LVecBase4f::compare_to(LVecBase4f const &amp;other) const;</span>
<span class="s0">inline int LVecBase4f::compare_to(LVecBase4f const &amp;other, float threshold) const;</span>

<span class="s0">2753 8 get_hash 0 4 3634 20 LVecBase4f::get_hash 0 2 853 854 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">inline std::size_t LVecBase4f::get_hash(void) const;</span>
<span class="s0">inline std::size_t LVecBase4f::get_hash(float threshold) const;</span>

<span class="s0">2754 8 add_hash 0 4 3634 20 LVecBase4f::add_hash 0 2 855 856 100</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">146</span>
<span class="s0">inline std::size_t LVecBase4f::add_hash(std::size_t hash) const;</span>
<span class="s0">inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const;</span>

<span class="s0">2755 13 generate_hash 0 4 3634 25 LVecBase4f::generate_hash 0 2 857 858 120</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">170</span>
<span class="s0">inline void LVecBase4f::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>
<span class="s0">inline void LVecBase4f::generate_hash(ChecksumHashGenerator &amp;hashgen, float threshold) const;</span>

<span class="s0">2756 10 operator - 0 68 3634 22 LVecBase4f::operator - 0 1 859 0</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase4f LVecBase4f::operator -(void) const;</span>

<span class="s0">2757 10 operator + 0 4 3634 22 LVecBase4f::operator + 0 1 860 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase4f LVecBase4f::operator +(LVecBase4f const &amp;other) const;</span>

<span class="s0">2758 10 operator - 0 4 3634 22 LVecBase4f::operator - 0 1 861 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase4f LVecBase4f::operator -(LVecBase4f const &amp;other) const;</span>

<span class="s0">2759 10 operator * 0 4 3634 22 LVecBase4f::operator * 0 1 862 0</span>
<span class="s0">61</span>
<span class="s0">inline LVecBase4f LVecBase4f::operator *(float scalar) const;</span>

<span class="s0">2760 10 operator / 0 4 3634 22 LVecBase4f::operator / 0 1 863 0</span>
<span class="s0">61</span>
<span class="s0">inline LVecBase4f LVecBase4f::operator /(float scalar) const;</span>

<span class="s0">2761 11 operator += 0 4 3634 23 LVecBase4f::operator += 0 1 864 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase4f::operator +=(LVecBase4f const &amp;other);</span>

<span class="s0">2762 11 operator -= 0 4 3634 23 LVecBase4f::operator -= 0 1 865 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase4f::operator -=(LVecBase4f const &amp;other);</span>

<span class="s0">2763 11 operator *= 0 4 3634 23 LVecBase4f::operator *= 0 1 866 0</span>
<span class="s0">50</span>
<span class="s0">inline void LVecBase4f::operator *=(float scalar);</span>

<span class="s0">2764 11 operator /= 0 4 3634 23 LVecBase4f::operator /= 0 1 867 0</span>
<span class="s0">50</span>
<span class="s0">inline void LVecBase4f::operator /=(float scalar);</span>

<span class="s0">2765 18 componentwise_mult 0 4 3634 30 LVecBase4f::componentwise_mult 0 1 868 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase4f::componentwise_mult(LVecBase4f const &amp;other);</span>

<span class="s0">2766 12 __floordiv__ 0 4 3634 24 LVecBase4f::__floordiv__ 0 1 869 0</span>
<span class="s0">78</span>
<span class="s0">inline PyObject *LVecBase4f::__floordiv__(PyObject *self, float scalar) const;</span>

<span class="s0">2767 13 __ifloordiv__ 0 4 3634 25 LVecBase4f::__ifloordiv__ 0 1 870 0</span>
<span class="s0">73</span>
<span class="s0">inline PyObject *LVecBase4f::__ifloordiv__(PyObject *self, float scalar);</span>

<span class="s0">2768 7 __pow__ 0 4 3634 19 LVecBase4f::__pow__ 0 1 871 0</span>
<span class="s0">75</span>
<span class="s0">inline PyObject *LVecBase4f::__pow__(PyObject *self, float exponent) const;</span>

<span class="s0">2769 8 __ipow__ 0 4 3634 20 LVecBase4f::__ipow__ 0 1 872 0</span>
<span class="s0">70</span>
<span class="s0">inline PyObject *LVecBase4f::__ipow__(PyObject *self, float exponent);</span>

<span class="s0">2770 9 __round__ 0 4 3634 21 LVecBase4f::__round__ 0 1 873 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase4f::__round__(PyObject *self);</span>

<span class="s0">2771 9 __floor__ 0 4 3634 21 LVecBase4f::__floor__ 0 1 874 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase4f::__floor__(PyObject *self);</span>

<span class="s0">2772 8 __ceil__ 0 4 3634 20 LVecBase4f::__ceil__ 0 1 875 0</span>
<span class="s0">54</span>
<span class="s0">inline PyObject *LVecBase4f::__ceil__(PyObject *self);</span>

<span class="s0">2773 4 fmax 0 4 3634 16 LVecBase4f::fmax 0 1 876 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &amp;other) const;</span>

<span class="s0">2774 4 fmin 0 4 3634 16 LVecBase4f::fmin 0 1 877 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &amp;other) const;</span>

<span class="s0">2775 12 almost_equal 0 4 3634 24 LVecBase4f::almost_equal 0 2 878 879 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">154</span>
<span class="s0">inline bool LVecBase4f::almost_equal(LVecBase4f const &amp;other, float threshold) const;</span>
<span class="s0">inline bool LVecBase4f::almost_equal(LVecBase4f const &amp;other) const;</span>

<span class="s0">2776 6 output 0 4 3634 18 LVecBase4f::output 0 1 880 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase4f::output(std::ostream &amp;out) const;</span>

<span class="s0">2777 8 __repr__ 0 4 3634 20 LVecBase4f::__repr__ 0 1 881 0</span>
<span class="s0">52</span>
<span class="s0">inline std::string LVecBase4f::__repr__(void) const;</span>

<span class="s0">2778 20 write_datagram_fixed 0 4 3634 32 LVecBase4f::write_datagram_fixed 0 1 882 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void LVecBase4f::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">2779 19 read_datagram_fixed 0 4 3634 31 LVecBase4f::read_datagram_fixed 0 1 883 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void LVecBase4f::read_datagram_fixed(DatagramIterator &amp;source);</span>

<span class="s0">2780 14 write_datagram 0 4 3634 26 LVecBase4f::write_datagram 0 1 884 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase4f::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">2781 13 read_datagram 0 4 3634 25 LVecBase4f::read_datagram 0 1 885 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LVecBase4f::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">2782 14 get_class_type 0 4 3634 26 LVecBase4f::get_class_type 0 1 886 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle LVecBase4f::get_class_type(void);</span>

<span class="s0">2783 11 ~LVecBase4f 0 516 3634 23 LVecBase4f::~LVecBase4f 0 0 0</span>
<span class="s0">30</span>
<span class="s0">LVecBase4f::~LVecBase4f(void);</span>

<span class="s0">2784 19 UnalignedLVecBase4f 0 260 3636 40 UnalignedLVecBase4f::UnalignedLVecBase4f 0 5 887 888 889 890 891 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">377</span>
<span class="s0">inline UnalignedLVecBase4f::UnalignedLVecBase4f(void) = default;</span>
<span class="s0">inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &amp;copy);</span>
<span class="s0">inline UnalignedLVecBase4f::UnalignedLVecBase4f(float fill_value);</span>
<span class="s0">inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w);</span>
<span class="s0">inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &amp;) = default;</span>

<span class="s0">2785 4 fill 0 4 3636 25 UnalignedLVecBase4f::fill 0 1 892 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void UnalignedLVecBase4f::fill(float fill_value);</span>

<span class="s0">2786 3 set 0 4 3636 24 UnalignedLVecBase4f::set 0 1 893 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void UnalignedLVecBase4f::set(float x, float y, float z, float w);</span>

<span class="s0">2787 11 operator [] 0 4 3636 32 UnalignedLVecBase4f::operator [] 0 2 894 895 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">inline float UnalignedLVecBase4f::operator [](int i) const;</span>
<span class="s0">inline float &amp;UnalignedLVecBase4f::operator [](int i);</span>

<span class="s0">2788 4 size 0 4 3636 25 UnalignedLVecBase4f::size 0 1 896 0</span>
<span class="s0">53</span>
<span class="s0">static constexpr int UnalignedLVecBase4f::size(void);</span>

<span class="s0">2789 8 get_data 0 4 3636 29 UnalignedLVecBase4f::get_data 0 1 897 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline float const *UnalignedLVecBase4f::get_data(void) const;</span>

<span class="s0">2790 18 get_num_components 0 4 3636 39 UnalignedLVecBase4f::get_num_components 0 1 898 0</span>
<span class="s0">67</span>
<span class="s0">static constexpr int UnalignedLVecBase4f::get_num_components(void);</span>

<span class="s0">2791 11 operator == 0 4 3636 32 UnalignedLVecBase4f::operator == 0 1 899 0</span>
<span class="s0">85</span>
<span class="s0">inline bool UnalignedLVecBase4f::operator ==(UnalignedLVecBase4f const &amp;other) const;</span>

<span class="s0">2792 11 operator != 0 4 3636 32 UnalignedLVecBase4f::operator != 0 1 900 0</span>
<span class="s0">85</span>
<span class="s0">inline bool UnalignedLVecBase4f::operator !=(UnalignedLVecBase4f const &amp;other) const;</span>

<span class="s0">2793 14 get_class_type 0 4 3636 35 UnalignedLVecBase4f::get_class_type 0 1 901 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle UnalignedLVecBase4f::get_class_type(void);</span>

<span class="s0">2794 20 ~UnalignedLVecBase4f 0 516 3636 41 UnalignedLVecBase4f::~UnalignedLVecBase4f 0 0 0</span>
<span class="s0">48</span>
<span class="s0">UnalignedLVecBase4f::~UnalignedLVecBase4f(void);</span>

<span class="s0">2795 10 LVecBase4d 0 260 3638 22 LVecBase4d::LVecBase4d 0 8 902 903 904 905 906 907 908 909 219</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.</span>
 <span class="s0">*/</span>
<span class="s0">467</span>
<span class="s0">inline LVecBase4d::LVecBase4d(void) = default;</span>
<span class="s0">inline LVecBase4d::LVecBase4d(double fill_value);</span>
<span class="s0">inline LVecBase4d::LVecBase4d(double x, double y, double z, double w);</span>
<span class="s0">inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &amp;copy);</span>
<span class="s0">inline LVecBase4d::LVecBase4d(LVecBase3d const &amp;copy, double w);</span>
<span class="s0">inline LVecBase4d::LVecBase4d(LPoint3d const &amp;point);</span>
<span class="s0">inline LVecBase4d::LVecBase4d(LVector3d const &amp;vector);</span>
<span class="s0">inline LVecBase4d::LVecBase4d(LVecBase4d const &amp;) = default;</span>

<span class="s0">2796 12 operator new 0 4 3638 24 LVecBase4d::operator new 0 1 910 0</span>
<span class="s0">124</span>
<span class="s0">inline void *LVecBase4d::operator new(std::size_t size);</span>
<span class="s0">inline void *LVecBase4d::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2797 15 operator delete 0 4 3638 27 LVecBase4d::operator delete 0 0 0</span>
<span class="s0">108</span>
<span class="s0">inline void LVecBase4d::operator delete(void *ptr);</span>
<span class="s0">inline void LVecBase4d::operator delete(void *, void *);</span>

<span class="s0">2798 12 validate_ptr 0 4 3638 24 LVecBase4d::validate_ptr 0 0 0</span>
<span class="s0">61</span>
<span class="s0">static inline bool LVecBase4d::validate_ptr(void const *ptr);</span>

<span class="s0">2799 10 operator = 0 4 3638 22 LVecBase4d::operator = 0 2 911 912 0</span>
<span class="s0">120</span>
<span class="s0">void LVecBase4d::operator =(LVecBase4d const &amp;copy) = default;</span>
<span class="s0">void LVecBase4d::operator =(double fill_value) = default;</span>

<span class="s0">2800 4 zero 0 4 3638 16 LVecBase4d::zero 0 1 913 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVecBase4d const &amp;LVecBase4d::zero(void);</span>

<span class="s0">2801 6 unit_x 0 4 3638 18 LVecBase4d::unit_x 0 1 914 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4d const &amp;LVecBase4d::unit_x(void);</span>

<span class="s0">2802 6 unit_y 0 4 3638 18 LVecBase4d::unit_y 0 1 915 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4d const &amp;LVecBase4d::unit_y(void);</span>

<span class="s0">2803 6 unit_z 0 4 3638 18 LVecBase4d::unit_z 0 1 916 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4d const &amp;LVecBase4d::unit_z(void);</span>

<span class="s0">2804 6 unit_w 0 4 3638 18 LVecBase4d::unit_w 0 1 917 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4d const &amp;LVecBase4d::unit_w(void);</span>

<span class="s0">2805 10 __reduce__ 0 4 3638 22 LVecBase4d::__reduce__ 0 1 918 0</span>
<span class="s0">62</span>
<span class="s0">inline PyObject *LVecBase4d::__reduce__(PyObject *self) const;</span>

<span class="s0">2806 11 __getattr__ 0 4 3638 23 LVecBase4d::__getattr__ 0 1 919 0</span>
<span class="s0">93</span>
<span class="s0">inline PyObject *LVecBase4d::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2807 11 __setattr__ 0 4 3638 23 LVecBase4d::__setattr__ 0 1 920 0</span>
<span class="s0">99</span>
<span class="s0">inline int LVecBase4d::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2808 11 operator [] 0 4 3638 23 LVecBase4d::operator [] 0 2 921 922 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline double LVecBase4d::operator [](int i) const;</span>
<span class="s0">inline double &amp;LVecBase4d::operator [](int i);</span>

<span class="s0">2809 4 size 0 4 3638 16 LVecBase4d::size 0 1 923 0</span>
<span class="s0">44</span>
<span class="s0">static constexpr int LVecBase4d::size(void);</span>

<span class="s0">2810 6 is_nan 0 4 3638 18 LVecBase4d::is_nan 0 1 924 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool LVecBase4d::is_nan(void) const;</span>

<span class="s0">2811 8 get_cell 0 4 3638 20 LVecBase4d::get_cell 0 1 925 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline double LVecBase4d::get_cell(int i) const;</span>

<span class="s0">2812 8 set_cell 0 4 3638 20 LVecBase4d::set_cell 0 1 926 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void LVecBase4d::set_cell(int i, double value);</span>

<span class="s0">2813 5 get_x 0 4 3638 17 LVecBase4d::get_x 0 1 927 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double LVecBase4d::get_x(void) const;</span>

<span class="s0">2814 5 get_y 0 4 3638 17 LVecBase4d::get_y 0 1 928 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double LVecBase4d::get_y(void) const;</span>

<span class="s0">2815 5 get_z 0 4 3638 17 LVecBase4d::get_z 0 1 929 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double LVecBase4d::get_z(void) const;</span>

<span class="s0">2816 5 get_w 0 4 3638 17 LVecBase4d::get_w 0 1 930 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double LVecBase4d::get_w(void) const;</span>

<span class="s0">2817 7 get_xyz 0 4 3638 19 LVecBase4d::get_xyz 0 1 931 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline LVecBase3d LVecBase4d::get_xyz(void) const;</span>

<span class="s0">2818 6 get_xy 0 4 3638 18 LVecBase4d::get_xy 0 1 932 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2d LVecBase4d::get_xy(void) const;</span>

<span class="s0">2819 5 set_x 0 4 3638 17 LVecBase4d::set_x 0 1 933 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase4d::set_x(double value);</span>

<span class="s0">2820 5 set_y 0 4 3638 17 LVecBase4d::set_y 0 1 934 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase4d::set_y(double value);</span>

<span class="s0">2821 5 set_z 0 4 3638 17 LVecBase4d::set_z 0 1 935 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase4d::set_z(double value);</span>

<span class="s0">2822 5 set_w 0 4 3638 17 LVecBase4d::set_w 0 1 936 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase4d::set_w(double value);</span>

<span class="s0">2823 11 add_to_cell 0 4 3638 23 LVecBase4d::add_to_cell 0 1 937 164</span>
<span class="s0">// These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages:</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void LVecBase4d::add_to_cell(int i, double value);</span>

<span class="s0">2824 5 add_x 0 4 3638 17 LVecBase4d::add_x 0 1 938 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase4d::add_x(double value);</span>

<span class="s0">2825 5 add_y 0 4 3638 17 LVecBase4d::add_y 0 1 939 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase4d::add_y(double value);</span>

<span class="s0">2826 5 add_z 0 4 3638 17 LVecBase4d::add_z 0 1 940 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase4d::add_z(double value);</span>

<span class="s0">2827 5 add_w 0 4 3638 17 LVecBase4d::add_w 0 1 941 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void LVecBase4d::add_w(double value);</span>

<span class="s0">2828 8 get_data 0 4 3638 20 LVecBase4d::get_data 0 1 942 161</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the four data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline double const *LVecBase4d::get_data(void) const;</span>

<span class="s0">2829 18 get_num_components 0 4 3638 30 LVecBase4d::get_num_components 0 1 943 0</span>
<span class="s0">58</span>
<span class="s0">static constexpr int LVecBase4d::get_num_components(void);</span>

<span class="s0">2830 12 extract_data 0 4 3638 24 LVecBase4d::extract_data 0 0 0</span>
<span class="s0">46</span>
<span class="s0">inline void LVecBase4d::extract_data(float *);</span>

<span class="s0">2831 4 fill 0 4 3638 16 LVecBase4d::fill 0 1 944 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void LVecBase4d::fill(double fill_value);</span>

<span class="s0">2832 3 set 0 4 3638 15 LVecBase4d::set 0 1 945 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase4d::set(double x, double y, double z, double w);</span>

<span class="s0">2833 3 dot 0 4 3638 15 LVecBase4d::dot 0 1 946 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline double LVecBase4d::dot(LVecBase4d const &amp;other) const;</span>

<span class="s0">2834 14 length_squared 0 4 3638 26 LVecBase4d::length_squared 0 1 947 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline double LVecBase4d::length_squared(void) const;</span>

<span class="s0">2835 6 length 0 4 3638 18 LVecBase4d::length 0 1 948 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline double LVecBase4d::length(void) const;</span>

<span class="s0">2836 9 normalize 0 4 3638 21 LVecBase4d::normalize 0 1 949 127</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline bool LVecBase4d::normalize(void);</span>

<span class="s0">2837 10 normalized 0 4 3638 22 LVecBase4d::normalized 0 1 950 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase4d LVecBase4d::normalized(void) const;</span>

<span class="s0">2838 7 project 0 4 3638 19 LVecBase4d::project 0 1 951 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LVecBase4d LVecBase4d::project(LVecBase4d const &amp;onto) const;</span>

<span class="s0">2839 10 operator &lt; 0 4 3638 22 LVecBase4d::operator &lt; 0 1 952 0</span>
<span class="s0">66</span>
<span class="s0">inline bool LVecBase4d::operator &lt;(LVecBase4d const &amp;other) const;</span>

<span class="s0">2840 11 operator == 0 4 3638 23 LVecBase4d::operator == 0 1 953 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase4d::operator ==(LVecBase4d const &amp;other) const;</span>

<span class="s0">2841 11 operator != 0 4 3638 23 LVecBase4d::operator != 0 1 954 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase4d::operator !=(LVecBase4d const &amp;other) const;</span>

<span class="s0">2842 10 compare_to 0 4 3638 22 LVecBase4d::compare_to 0 2 955 956 332</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/</span>
<span class="s0">149</span>
<span class="s0">inline int LVecBase4d::compare_to(LVecBase4d const &amp;other) const;</span>
<span class="s0">inline int LVecBase4d::compare_to(LVecBase4d const &amp;other, double threshold) const;</span>

<span class="s0">2843 8 get_hash 0 4 3638 20 LVecBase4d::get_hash 0 2 957 958 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">inline std::size_t LVecBase4d::get_hash(void) const;</span>
<span class="s0">inline std::size_t LVecBase4d::get_hash(double threshold) const;</span>

<span class="s0">2844 8 add_hash 0 4 3638 20 LVecBase4d::add_hash 0 2 959 960 100</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">147</span>
<span class="s0">inline std::size_t LVecBase4d::add_hash(std::size_t hash) const;</span>
<span class="s0">inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const;</span>

<span class="s0">2845 13 generate_hash 0 4 3638 25 LVecBase4d::generate_hash 0 2 961 962 120</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">171</span>
<span class="s0">inline void LVecBase4d::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>
<span class="s0">inline void LVecBase4d::generate_hash(ChecksumHashGenerator &amp;hashgen, double threshold) const;</span>

<span class="s0">2846 10 operator - 0 68 3638 22 LVecBase4d::operator - 0 1 963 0</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase4d LVecBase4d::operator -(void) const;</span>

<span class="s0">2847 10 operator + 0 4 3638 22 LVecBase4d::operator + 0 1 964 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase4d LVecBase4d::operator +(LVecBase4d const &amp;other) const;</span>

<span class="s0">2848 10 operator - 0 4 3638 22 LVecBase4d::operator - 0 1 965 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase4d LVecBase4d::operator -(LVecBase4d const &amp;other) const;</span>

<span class="s0">2849 10 operator * 0 4 3638 22 LVecBase4d::operator * 0 1 966 0</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase4d LVecBase4d::operator *(double scalar) const;</span>

<span class="s0">2850 10 operator / 0 4 3638 22 LVecBase4d::operator / 0 1 967 0</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase4d LVecBase4d::operator /(double scalar) const;</span>

<span class="s0">2851 11 operator += 0 4 3638 23 LVecBase4d::operator += 0 1 968 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase4d::operator +=(LVecBase4d const &amp;other);</span>

<span class="s0">2852 11 operator -= 0 4 3638 23 LVecBase4d::operator -= 0 1 969 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase4d::operator -=(LVecBase4d const &amp;other);</span>

<span class="s0">2853 11 operator *= 0 4 3638 23 LVecBase4d::operator *= 0 1 970 0</span>
<span class="s0">51</span>
<span class="s0">inline void LVecBase4d::operator *=(double scalar);</span>

<span class="s0">2854 11 operator /= 0 4 3638 23 LVecBase4d::operator /= 0 1 971 0</span>
<span class="s0">51</span>
<span class="s0">inline void LVecBase4d::operator /=(double scalar);</span>

<span class="s0">2855 18 componentwise_mult 0 4 3638 30 LVecBase4d::componentwise_mult 0 1 972 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase4d::componentwise_mult(LVecBase4d const &amp;other);</span>

<span class="s0">2856 12 __floordiv__ 0 4 3638 24 LVecBase4d::__floordiv__ 0 1 973 0</span>
<span class="s0">79</span>
<span class="s0">inline PyObject *LVecBase4d::__floordiv__(PyObject *self, double scalar) const;</span>

<span class="s0">2857 13 __ifloordiv__ 0 4 3638 25 LVecBase4d::__ifloordiv__ 0 1 974 0</span>
<span class="s0">74</span>
<span class="s0">inline PyObject *LVecBase4d::__ifloordiv__(PyObject *self, double scalar);</span>

<span class="s0">2858 7 __pow__ 0 4 3638 19 LVecBase4d::__pow__ 0 1 975 0</span>
<span class="s0">76</span>
<span class="s0">inline PyObject *LVecBase4d::__pow__(PyObject *self, double exponent) const;</span>

<span class="s0">2859 8 __ipow__ 0 4 3638 20 LVecBase4d::__ipow__ 0 1 976 0</span>
<span class="s0">71</span>
<span class="s0">inline PyObject *LVecBase4d::__ipow__(PyObject *self, double exponent);</span>

<span class="s0">2860 9 __round__ 0 4 3638 21 LVecBase4d::__round__ 0 1 977 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase4d::__round__(PyObject *self);</span>

<span class="s0">2861 9 __floor__ 0 4 3638 21 LVecBase4d::__floor__ 0 1 978 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase4d::__floor__(PyObject *self);</span>

<span class="s0">2862 8 __ceil__ 0 4 3638 20 LVecBase4d::__ceil__ 0 1 979 0</span>
<span class="s0">54</span>
<span class="s0">inline PyObject *LVecBase4d::__ceil__(PyObject *self);</span>

<span class="s0">2863 4 fmax 0 4 3638 16 LVecBase4d::fmax 0 1 980 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &amp;other) const;</span>

<span class="s0">2864 4 fmin 0 4 3638 16 LVecBase4d::fmin 0 1 981 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &amp;other) const;</span>

<span class="s0">2865 12 almost_equal 0 4 3638 24 LVecBase4d::almost_equal 0 2 982 983 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">155</span>
<span class="s0">inline bool LVecBase4d::almost_equal(LVecBase4d const &amp;other, double threshold) const;</span>
<span class="s0">inline bool LVecBase4d::almost_equal(LVecBase4d const &amp;other) const;</span>

<span class="s0">2866 6 output 0 4 3638 18 LVecBase4d::output 0 1 984 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase4d::output(std::ostream &amp;out) const;</span>

<span class="s0">2867 8 __repr__ 0 4 3638 20 LVecBase4d::__repr__ 0 1 985 0</span>
<span class="s0">52</span>
<span class="s0">inline std::string LVecBase4d::__repr__(void) const;</span>

<span class="s0">2868 20 write_datagram_fixed 0 4 3638 32 LVecBase4d::write_datagram_fixed 0 1 986 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void LVecBase4d::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">2869 19 read_datagram_fixed 0 4 3638 31 LVecBase4d::read_datagram_fixed 0 1 987 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void LVecBase4d::read_datagram_fixed(DatagramIterator &amp;source);</span>

<span class="s0">2870 14 write_datagram 0 4 3638 26 LVecBase4d::write_datagram 0 1 988 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase4d::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">2871 13 read_datagram 0 4 3638 25 LVecBase4d::read_datagram 0 1 989 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LVecBase4d::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">2872 14 get_class_type 0 4 3638 26 LVecBase4d::get_class_type 0 1 990 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle LVecBase4d::get_class_type(void);</span>

<span class="s0">2873 11 ~LVecBase4d 0 516 3638 23 LVecBase4d::~LVecBase4d 0 0 0</span>
<span class="s0">30</span>
<span class="s0">LVecBase4d::~LVecBase4d(void);</span>

<span class="s0">2874 19 UnalignedLVecBase4d 0 260 3640 40 UnalignedLVecBase4d::UnalignedLVecBase4d 0 5 991 992 993 994 995 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">382</span>
<span class="s0">inline UnalignedLVecBase4d::UnalignedLVecBase4d(void) = default;</span>
<span class="s0">inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &amp;copy);</span>
<span class="s0">inline UnalignedLVecBase4d::UnalignedLVecBase4d(double fill_value);</span>
<span class="s0">inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w);</span>
<span class="s0">inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &amp;) = default;</span>

<span class="s0">2875 4 fill 0 4 3640 25 UnalignedLVecBase4d::fill 0 1 996 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void UnalignedLVecBase4d::fill(double fill_value);</span>

<span class="s0">2876 3 set 0 4 3640 24 UnalignedLVecBase4d::set 0 1 997 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void UnalignedLVecBase4d::set(double x, double y, double z, double w);</span>

<span class="s0">2877 11 operator [] 0 4 3640 32 UnalignedLVecBase4d::operator [] 0 2 998 999 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">inline double UnalignedLVecBase4d::operator [](int i) const;</span>
<span class="s0">inline double &amp;UnalignedLVecBase4d::operator [](int i);</span>

<span class="s0">2878 4 size 0 4 3640 25 UnalignedLVecBase4d::size 0 1 1000 0</span>
<span class="s0">53</span>
<span class="s0">static constexpr int UnalignedLVecBase4d::size(void);</span>

<span class="s0">2879 8 get_data 0 4 3640 29 UnalignedLVecBase4d::get_data 0 1 1001 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline double const *UnalignedLVecBase4d::get_data(void) const;</span>

<span class="s0">2880 18 get_num_components 0 4 3640 39 UnalignedLVecBase4d::get_num_components 0 1 1002 0</span>
<span class="s0">67</span>
<span class="s0">static constexpr int UnalignedLVecBase4d::get_num_components(void);</span>

<span class="s0">2881 11 operator == 0 4 3640 32 UnalignedLVecBase4d::operator == 0 1 1003 0</span>
<span class="s0">85</span>
<span class="s0">inline bool UnalignedLVecBase4d::operator ==(UnalignedLVecBase4d const &amp;other) const;</span>

<span class="s0">2882 11 operator != 0 4 3640 32 UnalignedLVecBase4d::operator != 0 1 1004 0</span>
<span class="s0">85</span>
<span class="s0">inline bool UnalignedLVecBase4d::operator !=(UnalignedLVecBase4d const &amp;other) const;</span>

<span class="s0">2883 14 get_class_type 0 4 3640 35 UnalignedLVecBase4d::get_class_type 0 1 1005 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle UnalignedLVecBase4d::get_class_type(void);</span>

<span class="s0">2884 20 ~UnalignedLVecBase4d 0 516 3640 41 UnalignedLVecBase4d::~UnalignedLVecBase4d 0 0 0</span>
<span class="s0">48</span>
<span class="s0">UnalignedLVecBase4d::~UnalignedLVecBase4d(void);</span>

<span class="s0">2885 10 LVecBase4i 0 260 3642 22 LVecBase4i::LVecBase4i 0 8 1006 1007 1008 1009 1010 1011 1012 1013 219</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.</span>
 <span class="s0">*/</span>
<span class="s0">449</span>
<span class="s0">inline LVecBase4i::LVecBase4i(void) = default;</span>
<span class="s0">inline LVecBase4i::LVecBase4i(int fill_value);</span>
<span class="s0">inline LVecBase4i::LVecBase4i(int x, int y, int z, int w);</span>
<span class="s0">inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &amp;copy);</span>
<span class="s0">inline LVecBase4i::LVecBase4i(LVecBase3i const &amp;copy, int w);</span>
<span class="s0">inline LVecBase4i::LVecBase4i(LPoint3i const &amp;point);</span>
<span class="s0">inline LVecBase4i::LVecBase4i(LVector3i const &amp;vector);</span>
<span class="s0">inline LVecBase4i::LVecBase4i(LVecBase4i const &amp;) = default;</span>

<span class="s0">2886 12 operator new 0 4 3642 24 LVecBase4i::operator new 0 1 1014 0</span>
<span class="s0">124</span>
<span class="s0">inline void *LVecBase4i::operator new(std::size_t size);</span>
<span class="s0">inline void *LVecBase4i::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2887 15 operator delete 0 4 3642 27 LVecBase4i::operator delete 0 0 0</span>
<span class="s0">108</span>
<span class="s0">inline void LVecBase4i::operator delete(void *ptr);</span>
<span class="s0">inline void LVecBase4i::operator delete(void *, void *);</span>

<span class="s0">2888 12 validate_ptr 0 4 3642 24 LVecBase4i::validate_ptr 0 0 0</span>
<span class="s0">61</span>
<span class="s0">static inline bool LVecBase4i::validate_ptr(void const *ptr);</span>

<span class="s0">2889 10 operator = 0 4 3642 22 LVecBase4i::operator = 0 2 1015 1016 0</span>
<span class="s0">117</span>
<span class="s0">void LVecBase4i::operator =(LVecBase4i const &amp;copy) = default;</span>
<span class="s0">void LVecBase4i::operator =(int fill_value) = default;</span>

<span class="s0">2890 4 zero 0 4 3642 16 LVecBase4i::zero 0 1 1017 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVecBase4i const &amp;LVecBase4i::zero(void);</span>

<span class="s0">2891 6 unit_x 0 4 3642 18 LVecBase4i::unit_x 0 1 1018 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4i const &amp;LVecBase4i::unit_x(void);</span>

<span class="s0">2892 6 unit_y 0 4 3642 18 LVecBase4i::unit_y 0 1 1019 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4i const &amp;LVecBase4i::unit_y(void);</span>

<span class="s0">2893 6 unit_z 0 4 3642 18 LVecBase4i::unit_z 0 1 1020 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4i const &amp;LVecBase4i::unit_z(void);</span>

<span class="s0">2894 6 unit_w 0 4 3642 18 LVecBase4i::unit_w 0 1 1021 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LVecBase4i const &amp;LVecBase4i::unit_w(void);</span>

<span class="s0">2895 10 __reduce__ 0 4 3642 22 LVecBase4i::__reduce__ 0 1 1022 0</span>
<span class="s0">62</span>
<span class="s0">inline PyObject *LVecBase4i::__reduce__(PyObject *self) const;</span>

<span class="s0">2896 11 __getattr__ 0 4 3642 23 LVecBase4i::__getattr__ 0 1 1023 0</span>
<span class="s0">93</span>
<span class="s0">inline PyObject *LVecBase4i::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2897 11 __setattr__ 0 4 3642 23 LVecBase4i::__setattr__ 0 1 1024 0</span>
<span class="s0">99</span>
<span class="s0">inline int LVecBase4i::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2898 11 operator [] 0 4 3642 23 LVecBase4i::operator [] 0 2 1025 1026 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">inline int LVecBase4i::operator [](int i) const;</span>
<span class="s0">inline int &amp;LVecBase4i::operator [](int i);</span>

<span class="s0">2899 4 size 0 4 3642 16 LVecBase4i::size 0 1 1027 0</span>
<span class="s0">44</span>
<span class="s0">static constexpr int LVecBase4i::size(void);</span>

<span class="s0">2900 6 is_nan 0 4 3642 18 LVecBase4i::is_nan 0 1 1028 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool LVecBase4i::is_nan(void) const;</span>

<span class="s0">2901 8 get_cell 0 4 3642 20 LVecBase4i::get_cell 0 1 1029 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline int LVecBase4i::get_cell(int i) const;</span>

<span class="s0">2902 8 set_cell 0 4 3642 20 LVecBase4i::set_cell 0 1 1030 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void LVecBase4i::set_cell(int i, int value);</span>

<span class="s0">2903 5 get_x 0 4 3642 17 LVecBase4i::get_x 0 1 1031 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline int LVecBase4i::get_x(void) const;</span>

<span class="s0">2904 5 get_y 0 4 3642 17 LVecBase4i::get_y 0 1 1032 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline int LVecBase4i::get_y(void) const;</span>

<span class="s0">2905 5 get_z 0 4 3642 17 LVecBase4i::get_z 0 1 1033 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline int LVecBase4i::get_z(void) const;</span>

<span class="s0">2906 5 get_w 0 4 3642 17 LVecBase4i::get_w 0 1 1034 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline int LVecBase4i::get_w(void) const;</span>

<span class="s0">2907 7 get_xyz 0 4 3642 19 LVecBase4i::get_xyz 0 1 1035 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline LVecBase3i LVecBase4i::get_xyz(void) const;</span>

<span class="s0">2908 6 get_xy 0 4 3642 18 LVecBase4i::get_xy 0 1 1036 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LVecBase2i LVecBase4i::get_xy(void) const;</span>

<span class="s0">2909 5 set_x 0 4 3642 17 LVecBase4i::set_x 0 1 1037 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase4i::set_x(int value);</span>

<span class="s0">2910 5 set_y 0 4 3642 17 LVecBase4i::set_y 0 1 1038 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase4i::set_y(int value);</span>

<span class="s0">2911 5 set_z 0 4 3642 17 LVecBase4i::set_z 0 1 1039 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase4i::set_z(int value);</span>

<span class="s0">2912 5 set_w 0 4 3642 17 LVecBase4i::set_w 0 1 1040 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase4i::set_w(int value);</span>

<span class="s0">2913 11 add_to_cell 0 4 3642 23 LVecBase4i::add_to_cell 0 1 1041 164</span>
<span class="s0">// These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages:</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void LVecBase4i::add_to_cell(int i, int value);</span>

<span class="s0">2914 5 add_x 0 4 3642 17 LVecBase4i::add_x 0 1 1042 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase4i::add_x(int value);</span>

<span class="s0">2915 5 add_y 0 4 3642 17 LVecBase4i::add_y 0 1 1043 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase4i::add_y(int value);</span>

<span class="s0">2916 5 add_z 0 4 3642 17 LVecBase4i::add_z 0 1 1044 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase4i::add_z(int value);</span>

<span class="s0">2917 5 add_w 0 4 3642 17 LVecBase4i::add_w 0 1 1045 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LVecBase4i::add_w(int value);</span>

<span class="s0">2918 8 get_data 0 4 3642 20 LVecBase4i::get_data 0 1 1046 161</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the four data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int const *LVecBase4i::get_data(void) const;</span>

<span class="s0">2919 18 get_num_components 0 4 3642 30 LVecBase4i::get_num_components 0 1 1047 0</span>
<span class="s0">58</span>
<span class="s0">static constexpr int LVecBase4i::get_num_components(void);</span>

<span class="s0">2920 12 extract_data 0 4 3642 24 LVecBase4i::extract_data 0 0 0</span>
<span class="s0">46</span>
<span class="s0">inline void LVecBase4i::extract_data(float *);</span>

<span class="s0">2921 4 fill 0 4 3642 16 LVecBase4i::fill 0 1 1048 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void LVecBase4i::fill(int fill_value);</span>

<span class="s0">2922 3 set 0 4 3642 15 LVecBase4i::set 0 1 1049 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase4i::set(int x, int y, int z, int w);</span>

<span class="s0">2923 3 dot 0 4 3642 15 LVecBase4i::dot 0 1 1050 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int LVecBase4i::dot(LVecBase4i const &amp;other) const;</span>

<span class="s0">2924 14 length_squared 0 4 3642 26 LVecBase4i::length_squared 0 1 1051 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int LVecBase4i::length_squared(void) const;</span>

<span class="s0">2925 10 operator &lt; 0 4 3642 22 LVecBase4i::operator &lt; 0 1 1052 0</span>
<span class="s0">66</span>
<span class="s0">inline bool LVecBase4i::operator &lt;(LVecBase4i const &amp;other) const;</span>

<span class="s0">2926 11 operator == 0 4 3642 23 LVecBase4i::operator == 0 1 1053 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase4i::operator ==(LVecBase4i const &amp;other) const;</span>

<span class="s0">2927 11 operator != 0 4 3642 23 LVecBase4i::operator != 0 1 1054 0</span>
<span class="s0">67</span>
<span class="s0">inline bool LVecBase4i::operator !=(LVecBase4i const &amp;other) const;</span>

<span class="s0">2928 10 compare_to 0 4 3642 22 LVecBase4i::compare_to 0 1 1055 97</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int LVecBase4i::compare_to(LVecBase4i const &amp;other) const;</span>

<span class="s0">2929 8 get_hash 0 4 3642 20 LVecBase4i::get_hash 0 1 1056 49</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline std::size_t LVecBase4i::get_hash(void) const;</span>

<span class="s0">2930 8 add_hash 0 4 3642 20 LVecBase4i::add_hash 0 1 1057 49</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::size_t LVecBase4i::add_hash(std::size_t hash) const;</span>

<span class="s0">2931 13 generate_hash 0 4 3642 25 LVecBase4i::generate_hash 0 1 1058 59</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void LVecBase4i::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>

<span class="s0">2932 10 operator - 0 68 3642 22 LVecBase4i::operator - 0 1 1059 0</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase4i LVecBase4i::operator -(void) const;</span>

<span class="s0">2933 10 operator + 0 4 3642 22 LVecBase4i::operator + 0 1 1060 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase4i LVecBase4i::operator +(LVecBase4i const &amp;other) const;</span>

<span class="s0">2934 10 operator - 0 4 3642 22 LVecBase4i::operator - 0 1 1061 0</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase4i LVecBase4i::operator -(LVecBase4i const &amp;other) const;</span>

<span class="s0">2935 10 operator * 0 4 3642 22 LVecBase4i::operator * 0 1 1062 0</span>
<span class="s0">59</span>
<span class="s0">inline LVecBase4i LVecBase4i::operator *(int scalar) const;</span>

<span class="s0">2936 10 operator / 0 4 3642 22 LVecBase4i::operator / 0 1 1063 0</span>
<span class="s0">59</span>
<span class="s0">inline LVecBase4i LVecBase4i::operator /(int scalar) const;</span>

<span class="s0">2937 11 operator += 0 4 3642 23 LVecBase4i::operator += 0 1 1064 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase4i::operator +=(LVecBase4i const &amp;other);</span>

<span class="s0">2938 11 operator -= 0 4 3642 23 LVecBase4i::operator -= 0 1 1065 0</span>
<span class="s0">61</span>
<span class="s0">inline void LVecBase4i::operator -=(LVecBase4i const &amp;other);</span>

<span class="s0">2939 11 operator *= 0 4 3642 23 LVecBase4i::operator *= 0 1 1066 0</span>
<span class="s0">48</span>
<span class="s0">inline void LVecBase4i::operator *=(int scalar);</span>

<span class="s0">2940 11 operator /= 0 4 3642 23 LVecBase4i::operator /= 0 1 1067 0</span>
<span class="s0">48</span>
<span class="s0">inline void LVecBase4i::operator /=(int scalar);</span>

<span class="s0">2941 18 componentwise_mult 0 4 3642 30 LVecBase4i::componentwise_mult 0 1 1068 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase4i::componentwise_mult(LVecBase4i const &amp;other);</span>

<span class="s0">2942 12 __floordiv__ 0 4 3642 24 LVecBase4i::__floordiv__ 0 1 1069 0</span>
<span class="s0">76</span>
<span class="s0">inline PyObject *LVecBase4i::__floordiv__(PyObject *self, int scalar) const;</span>

<span class="s0">2943 13 __ifloordiv__ 0 4 3642 25 LVecBase4i::__ifloordiv__ 0 1 1070 0</span>
<span class="s0">71</span>
<span class="s0">inline PyObject *LVecBase4i::__ifloordiv__(PyObject *self, int scalar);</span>

<span class="s0">2944 7 __pow__ 0 4 3642 19 LVecBase4i::__pow__ 0 1 1071 0</span>
<span class="s0">73</span>
<span class="s0">inline PyObject *LVecBase4i::__pow__(PyObject *self, int exponent) const;</span>

<span class="s0">2945 8 __ipow__ 0 4 3642 20 LVecBase4i::__ipow__ 0 1 1072 0</span>
<span class="s0">68</span>
<span class="s0">inline PyObject *LVecBase4i::__ipow__(PyObject *self, int exponent);</span>

<span class="s0">2946 9 __round__ 0 4 3642 21 LVecBase4i::__round__ 0 1 1073 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase4i::__round__(PyObject *self);</span>

<span class="s0">2947 9 __floor__ 0 4 3642 21 LVecBase4i::__floor__ 0 1 1074 0</span>
<span class="s0">55</span>
<span class="s0">inline PyObject *LVecBase4i::__floor__(PyObject *self);</span>

<span class="s0">2948 8 __ceil__ 0 4 3642 20 LVecBase4i::__ceil__ 0 1 1075 0</span>
<span class="s0">54</span>
<span class="s0">inline PyObject *LVecBase4i::__ceil__(PyObject *self);</span>

<span class="s0">2949 4 fmax 0 4 3642 16 LVecBase4i::fmax 0 1 1076 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &amp;other) const;</span>

<span class="s0">2950 4 fmin 0 4 3642 16 LVecBase4i::fmin 0 1 1077 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &amp;other) const;</span>

<span class="s0">2951 12 almost_equal 0 4 3642 24 LVecBase4i::almost_equal 0 2 1078 1079 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">152</span>
<span class="s0">inline bool LVecBase4i::almost_equal(LVecBase4i const &amp;other, int threshold) const;</span>
<span class="s0">inline bool LVecBase4i::almost_equal(LVecBase4i const &amp;other) const;</span>

<span class="s0">2952 6 output 0 4 3642 18 LVecBase4i::output 0 1 1080 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LVecBase4i::output(std::ostream &amp;out) const;</span>

<span class="s0">2953 8 __repr__ 0 4 3642 20 LVecBase4i::__repr__ 0 1 1081 0</span>
<span class="s0">52</span>
<span class="s0">inline std::string LVecBase4i::__repr__(void) const;</span>

<span class="s0">2954 20 write_datagram_fixed 0 4 3642 32 LVecBase4i::write_datagram_fixed 0 1 1082 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void LVecBase4i::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">2955 19 read_datagram_fixed 0 4 3642 31 LVecBase4i::read_datagram_fixed 0 1 1083 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void LVecBase4i::read_datagram_fixed(DatagramIterator &amp;source);</span>

<span class="s0">2956 14 write_datagram 0 4 3642 26 LVecBase4i::write_datagram 0 1 1084 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void LVecBase4i::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">2957 13 read_datagram 0 4 3642 25 LVecBase4i::read_datagram 0 1 1085 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LVecBase4i::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">2958 14 get_class_type 0 4 3642 26 LVecBase4i::get_class_type 0 1 1086 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle LVecBase4i::get_class_type(void);</span>

<span class="s0">2959 11 ~LVecBase4i 0 516 3642 23 LVecBase4i::~LVecBase4i 0 0 0</span>
<span class="s0">30</span>
<span class="s0">LVecBase4i::~LVecBase4i(void);</span>

<span class="s0">2960 19 UnalignedLVecBase4i 0 260 3644 40 UnalignedLVecBase4i::UnalignedLVecBase4i 0 5 1087 1088 1089 1090 1091 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">367</span>
<span class="s0">inline UnalignedLVecBase4i::UnalignedLVecBase4i(void) = default;</span>
<span class="s0">inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &amp;copy);</span>
<span class="s0">inline UnalignedLVecBase4i::UnalignedLVecBase4i(int fill_value);</span>
<span class="s0">inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w);</span>
<span class="s0">inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &amp;) = default;</span>

<span class="s0">2961 4 fill 0 4 3644 25 UnalignedLVecBase4i::fill 0 1 1092 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void UnalignedLVecBase4i::fill(int fill_value);</span>

<span class="s0">2962 3 set 0 4 3644 24 UnalignedLVecBase4i::set 0 1 1093 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void UnalignedLVecBase4i::set(int x, int y, int z, int w);</span>

<span class="s0">2963 11 operator [] 0 4 3644 32 UnalignedLVecBase4i::operator [] 0 2 1094 1095 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">inline int UnalignedLVecBase4i::operator [](int i) const;</span>
<span class="s0">inline int &amp;UnalignedLVecBase4i::operator [](int i);</span>

<span class="s0">2964 4 size 0 4 3644 25 UnalignedLVecBase4i::size 0 1 1096 0</span>
<span class="s0">53</span>
<span class="s0">static constexpr int UnalignedLVecBase4i::size(void);</span>

<span class="s0">2965 8 get_data 0 4 3644 29 UnalignedLVecBase4i::get_data 0 1 1097 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int const *UnalignedLVecBase4i::get_data(void) const;</span>

<span class="s0">2966 18 get_num_components 0 4 3644 39 UnalignedLVecBase4i::get_num_components 0 1 1098 0</span>
<span class="s0">67</span>
<span class="s0">static constexpr int UnalignedLVecBase4i::get_num_components(void);</span>

<span class="s0">2967 11 operator == 0 4 3644 32 UnalignedLVecBase4i::operator == 0 1 1099 0</span>
<span class="s0">85</span>
<span class="s0">inline bool UnalignedLVecBase4i::operator ==(UnalignedLVecBase4i const &amp;other) const;</span>

<span class="s0">2968 11 operator != 0 4 3644 32 UnalignedLVecBase4i::operator != 0 1 1100 0</span>
<span class="s0">85</span>
<span class="s0">inline bool UnalignedLVecBase4i::operator !=(UnalignedLVecBase4i const &amp;other) const;</span>

<span class="s0">2969 14 get_class_type 0 4 3644 35 UnalignedLVecBase4i::get_class_type 0 1 1101 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle UnalignedLVecBase4i::get_class_type(void);</span>

<span class="s0">2970 20 ~UnalignedLVecBase4i 0 516 3644 41 UnalignedLVecBase4i::~UnalignedLVecBase4i 0 0 0</span>
<span class="s0">48</span>
<span class="s0">UnalignedLVecBase4i::~UnalignedLVecBase4i(void);</span>

<span class="s0">2971 9 LVector4f 0 260 3646 20 LVector4f::LVector4f 0 6 1102 1103 1104 1105 1106 1107 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">329</span>
<span class="s0">inline LVector4f::LVector4f(void) = default;</span>
<span class="s0">inline LVector4f::LVector4f(LVecBase4f const &amp;copy);</span>
<span class="s0">inline LVector4f::LVector4f(float fill_value);</span>
<span class="s0">inline LVector4f::LVector4f(float x, float y, float z, float w);</span>
<span class="s0">inline LVector4f::LVector4f(LVecBase3f const &amp;copy, float w);</span>
<span class="s0">inline LVector4f::LVector4f(LVector4f const &amp;) = default;</span>

<span class="s0">2972 11 __getattr__ 0 4 3646 22 LVector4f::__getattr__ 0 1 1108 0</span>
<span class="s0">92</span>
<span class="s0">inline PyObject *LVector4f::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2973 11 __setattr__ 0 4 3646 22 LVector4f::__setattr__ 0 1 1109 0</span>
<span class="s0">98</span>
<span class="s0">inline int LVector4f::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2974 4 zero 0 4 3646 15 LVector4f::zero 0 1 1110 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LVector4f const &amp;LVector4f::zero(void);</span>

<span class="s0">2975 6 unit_x 0 4 3646 17 LVector4f::unit_x 0 1 1111 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4f const &amp;LVector4f::unit_x(void);</span>

<span class="s0">2976 6 unit_y 0 4 3646 17 LVector4f::unit_y 0 1 1112 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4f const &amp;LVector4f::unit_y(void);</span>

<span class="s0">2977 6 unit_z 0 4 3646 17 LVector4f::unit_z 0 1 1113 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4f const &amp;LVector4f::unit_z(void);</span>

<span class="s0">2978 6 unit_w 0 4 3646 17 LVector4f::unit_w 0 1 1114 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4f const &amp;LVector4f::unit_w(void);</span>

<span class="s0">2979 7 get_xyz 0 4 3646 18 LVector4f::get_xyz 0 1 1115 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline LVector3f LVector4f::get_xyz(void) const;</span>

<span class="s0">2980 6 get_xy 0 4 3646 17 LVector4f::get_xy 0 1 1116 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2f LVector4f::get_xy(void) const;</span>

<span class="s0">2981 10 operator - 0 68 3646 21 LVector4f::operator - 0 1 1117 0</span>
<span class="s0">51</span>
<span class="s0">inline LVector4f LVector4f::operator -(void) const;</span>

<span class="s0">2982 10 operator + 0 4 3646 21 LVector4f::operator + 0 2 1118 1119 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase4f LVector4f::operator +(LVecBase4f const &amp;other) const;</span>
<span class="s0">inline LVector4f LVector4f::operator +(LVector4f const &amp;other) const;</span>

<span class="s0">2983 10 operator - 0 4 3646 21 LVector4f::operator - 0 2 1120 1121 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase4f LVector4f::operator -(LVecBase4f const &amp;other) const;</span>
<span class="s0">inline LVector4f LVector4f::operator -(LVector4f const &amp;other) const;</span>

<span class="s0">2984 10 operator * 0 4 3646 21 LVector4f::operator * 0 1 1122 0</span>
<span class="s0">59</span>
<span class="s0">inline LVector4f LVector4f::operator *(float scalar) const;</span>

<span class="s0">2985 10 operator / 0 4 3646 21 LVector4f::operator / 0 1 1123 0</span>
<span class="s0">59</span>
<span class="s0">inline LVector4f LVector4f::operator /(float scalar) const;</span>

<span class="s0">2986 10 normalized 0 4 3646 21 LVector4f::normalized 0 1 1124 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline LVector4f LVector4f::normalized(void) const;</span>

<span class="s0">2987 7 project 0 4 3646 18 LVector4f::project 0 1 1125 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVector4f LVector4f::project(LVecBase4f const &amp;onto) const;</span>

<span class="s0">2988 8 __repr__ 0 4 3646 19 LVector4f::__repr__ 0 1 1126 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LVector4f::__repr__(void) const;</span>

<span class="s0">2989 14 get_class_type 0 4 3646 25 LVector4f::get_class_type 0 1 1127 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LVector4f::get_class_type(void);</span>

<span class="s0">2990 10 ~LVector4f 0 516 3646 21 LVector4f::~LVector4f 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LVector4f::~LVector4f(void);</span>

<span class="s0">2991 9 LVector4d 0 260 3647 20 LVector4d::LVector4d 0 6 1128 1129 1130 1131 1132 1133 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">335</span>
<span class="s0">inline LVector4d::LVector4d(void) = default;</span>
<span class="s0">inline LVector4d::LVector4d(LVecBase4d const &amp;copy);</span>
<span class="s0">inline LVector4d::LVector4d(double fill_value);</span>
<span class="s0">inline LVector4d::LVector4d(double x, double y, double z, double w);</span>
<span class="s0">inline LVector4d::LVector4d(LVecBase3d const &amp;copy, double w);</span>
<span class="s0">inline LVector4d::LVector4d(LVector4d const &amp;) = default;</span>

<span class="s0">2992 11 __getattr__ 0 4 3647 22 LVector4d::__getattr__ 0 1 1134 0</span>
<span class="s0">92</span>
<span class="s0">inline PyObject *LVector4d::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">2993 11 __setattr__ 0 4 3647 22 LVector4d::__setattr__ 0 1 1135 0</span>
<span class="s0">98</span>
<span class="s0">inline int LVector4d::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">2994 4 zero 0 4 3647 15 LVector4d::zero 0 1 1136 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LVector4d const &amp;LVector4d::zero(void);</span>

<span class="s0">2995 6 unit_x 0 4 3647 17 LVector4d::unit_x 0 1 1137 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4d const &amp;LVector4d::unit_x(void);</span>

<span class="s0">2996 6 unit_y 0 4 3647 17 LVector4d::unit_y 0 1 1138 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4d const &amp;LVector4d::unit_y(void);</span>

<span class="s0">2997 6 unit_z 0 4 3647 17 LVector4d::unit_z 0 1 1139 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4d const &amp;LVector4d::unit_z(void);</span>

<span class="s0">2998 6 unit_w 0 4 3647 17 LVector4d::unit_w 0 1 1140 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4d const &amp;LVector4d::unit_w(void);</span>

<span class="s0">2999 7 get_xyz 0 4 3647 18 LVector4d::get_xyz 0 1 1141 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline LVector3d LVector4d::get_xyz(void) const;</span>

<span class="s0">3000 6 get_xy 0 4 3647 17 LVector4d::get_xy 0 1 1142 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2d LVector4d::get_xy(void) const;</span>

<span class="s0">3001 10 operator - 0 68 3647 21 LVector4d::operator - 0 1 1143 0</span>
<span class="s0">51</span>
<span class="s0">inline LVector4d LVector4d::operator -(void) const;</span>

<span class="s0">3002 10 operator + 0 4 3647 21 LVector4d::operator + 0 2 1144 1145 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase4d LVector4d::operator +(LVecBase4d const &amp;other) const;</span>
<span class="s0">inline LVector4d LVector4d::operator +(LVector4d const &amp;other) const;</span>

<span class="s0">3003 10 operator - 0 4 3647 21 LVector4d::operator - 0 2 1146 1147 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase4d LVector4d::operator -(LVecBase4d const &amp;other) const;</span>
<span class="s0">inline LVector4d LVector4d::operator -(LVector4d const &amp;other) const;</span>

<span class="s0">3004 10 operator * 0 4 3647 21 LVector4d::operator * 0 1 1148 0</span>
<span class="s0">60</span>
<span class="s0">inline LVector4d LVector4d::operator *(double scalar) const;</span>

<span class="s0">3005 10 operator / 0 4 3647 21 LVector4d::operator / 0 1 1149 0</span>
<span class="s0">60</span>
<span class="s0">inline LVector4d LVector4d::operator /(double scalar) const;</span>

<span class="s0">3006 10 normalized 0 4 3647 21 LVector4d::normalized 0 1 1150 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline LVector4d LVector4d::normalized(void) const;</span>

<span class="s0">3007 7 project 0 4 3647 18 LVector4d::project 0 1 1151 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVector4d LVector4d::project(LVecBase4d const &amp;onto) const;</span>

<span class="s0">3008 8 __repr__ 0 4 3647 19 LVector4d::__repr__ 0 1 1152 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LVector4d::__repr__(void) const;</span>

<span class="s0">3009 14 get_class_type 0 4 3647 25 LVector4d::get_class_type 0 1 1153 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LVector4d::get_class_type(void);</span>

<span class="s0">3010 10 ~LVector4d 0 516 3647 21 LVector4d::~LVector4d 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LVector4d::~LVector4d(void);</span>

<span class="s0">3011 9 LVector4i 0 260 3648 20 LVector4i::LVector4i 0 6 1154 1155 1156 1157 1158 1159 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">317</span>
<span class="s0">inline LVector4i::LVector4i(void) = default;</span>
<span class="s0">inline LVector4i::LVector4i(LVecBase4i const &amp;copy);</span>
<span class="s0">inline LVector4i::LVector4i(int fill_value);</span>
<span class="s0">inline LVector4i::LVector4i(int x, int y, int z, int w);</span>
<span class="s0">inline LVector4i::LVector4i(LVecBase3i const &amp;copy, int w);</span>
<span class="s0">inline LVector4i::LVector4i(LVector4i const &amp;) = default;</span>

<span class="s0">3012 11 __getattr__ 0 4 3648 22 LVector4i::__getattr__ 0 1 1160 0</span>
<span class="s0">92</span>
<span class="s0">inline PyObject *LVector4i::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">3013 11 __setattr__ 0 4 3648 22 LVector4i::__setattr__ 0 1 1161 0</span>
<span class="s0">98</span>
<span class="s0">inline int LVector4i::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">3014 4 zero 0 4 3648 15 LVector4i::zero 0 1 1162 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LVector4i const &amp;LVector4i::zero(void);</span>

<span class="s0">3015 6 unit_x 0 4 3648 17 LVector4i::unit_x 0 1 1163 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4i const &amp;LVector4i::unit_x(void);</span>

<span class="s0">3016 6 unit_y 0 4 3648 17 LVector4i::unit_y 0 1 1164 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4i const &amp;LVector4i::unit_y(void);</span>

<span class="s0">3017 6 unit_z 0 4 3648 17 LVector4i::unit_z 0 1 1165 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4i const &amp;LVector4i::unit_z(void);</span>

<span class="s0">3018 6 unit_w 0 4 3648 17 LVector4i::unit_w 0 1 1166 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline LVector4i const &amp;LVector4i::unit_w(void);</span>

<span class="s0">3019 7 get_xyz 0 4 3648 18 LVector4i::get_xyz 0 1 1167 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline LVector3i LVector4i::get_xyz(void) const;</span>

<span class="s0">3020 6 get_xy 0 4 3648 17 LVector4i::get_xy 0 1 1168 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline LVector2i LVector4i::get_xy(void) const;</span>

<span class="s0">3021 10 operator - 0 68 3648 21 LVector4i::operator - 0 1 1169 0</span>
<span class="s0">51</span>
<span class="s0">inline LVector4i LVector4i::operator -(void) const;</span>

<span class="s0">3022 10 operator + 0 4 3648 21 LVector4i::operator + 0 2 1170 1171 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase4i LVector4i::operator +(LVecBase4i const &amp;other) const;</span>
<span class="s0">inline LVector4i LVector4i::operator +(LVector4i const &amp;other) const;</span>

<span class="s0">3023 10 operator - 0 4 3648 21 LVector4i::operator - 0 2 1172 1173 0</span>
<span class="s0">141</span>
<span class="s0">inline LVecBase4i LVector4i::operator -(LVecBase4i const &amp;other) const;</span>
<span class="s0">inline LVector4i LVector4i::operator -(LVector4i const &amp;other) const;</span>

<span class="s0">3024 10 operator * 0 4 3648 21 LVector4i::operator * 0 1 1174 0</span>
<span class="s0">57</span>
<span class="s0">inline LVector4i LVector4i::operator *(int scalar) const;</span>

<span class="s0">3025 10 operator / 0 4 3648 21 LVector4i::operator / 0 1 1175 0</span>
<span class="s0">57</span>
<span class="s0">inline LVector4i LVector4i::operator /(int scalar) const;</span>

<span class="s0">3026 8 __repr__ 0 4 3648 19 LVector4i::__repr__ 0 1 1176 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LVector4i::__repr__(void) const;</span>

<span class="s0">3027 14 get_class_type 0 4 3648 25 LVector4i::get_class_type 0 1 1177 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LVector4i::get_class_type(void);</span>

<span class="s0">3028 10 ~LVector4i 0 516 3648 21 LVector4i::~LVector4i 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LVector4i::~LVector4i(void);</span>

<span class="s0">3029 8 LPoint4f 0 260 3649 18 LPoint4f::LPoint4f 0 6 1178 1179 1180 1181 1182 1183 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">316</span>
<span class="s0">inline LPoint4f::LPoint4f(void) = default;</span>
<span class="s0">inline LPoint4f::LPoint4f(LVecBase4f const &amp;copy);</span>
<span class="s0">inline LPoint4f::LPoint4f(float fill_value);</span>
<span class="s0">inline LPoint4f::LPoint4f(float x, float y, float z, float w);</span>
<span class="s0">inline LPoint4f::LPoint4f(LVecBase3f const &amp;copy, float w);</span>
<span class="s0">inline LPoint4f::LPoint4f(LPoint4f const &amp;) = default;</span>

<span class="s0">3030 11 __getattr__ 0 4 3649 21 LPoint4f::__getattr__ 0 1 1184 0</span>
<span class="s0">91</span>
<span class="s0">inline PyObject *LPoint4f::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">3031 11 __setattr__ 0 4 3649 21 LPoint4f::__setattr__ 0 1 1185 0</span>
<span class="s0">97</span>
<span class="s0">inline int LPoint4f::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">3032 4 zero 0 4 3649 14 LPoint4f::zero 0 1 1186 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline LPoint4f const &amp;LPoint4f::zero(void);</span>

<span class="s0">3033 6 unit_x 0 4 3649 16 LPoint4f::unit_x 0 1 1187 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4f const &amp;LPoint4f::unit_x(void);</span>

<span class="s0">3034 6 unit_y 0 4 3649 16 LPoint4f::unit_y 0 1 1188 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4f const &amp;LPoint4f::unit_y(void);</span>

<span class="s0">3035 6 unit_z 0 4 3649 16 LPoint4f::unit_z 0 1 1189 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4f const &amp;LPoint4f::unit_z(void);</span>

<span class="s0">3036 6 unit_w 0 4 3649 16 LPoint4f::unit_w 0 1 1190 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit W point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4f const &amp;LPoint4f::unit_w(void);</span>

<span class="s0">3037 7 get_xyz 0 4 3649 17 LPoint4f::get_xyz 0 1 1191 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline LPoint3f LPoint4f::get_xyz(void) const;</span>

<span class="s0">3038 6 get_xy 0 4 3649 16 LPoint4f::get_xy 0 1 1192 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2f LPoint4f::get_xy(void) const;</span>

<span class="s0">3039 10 operator - 0 68 3649 20 LPoint4f::operator - 0 1 1193 0</span>
<span class="s0">49</span>
<span class="s0">inline LPoint4f LPoint4f::operator -(void) const;</span>

<span class="s0">3040 10 operator + 0 4 3649 20 LPoint4f::operator + 0 2 1194 1195 0</span>
<span class="s0">138</span>
<span class="s0">inline LVecBase4f LPoint4f::operator +(LVecBase4f const &amp;other) const;</span>
<span class="s0">inline LPoint4f LPoint4f::operator +(LVector4f const &amp;other) const;</span>

<span class="s0">3041 10 operator - 0 4 3649 20 LPoint4f::operator - 0 3 1196 1197 1198 0</span>
<span class="s0">206</span>
<span class="s0">inline LVecBase4f LPoint4f::operator -(LVecBase4f const &amp;other) const;</span>
<span class="s0">inline LVector4f LPoint4f::operator -(LPoint4f const &amp;other) const;</span>
<span class="s0">inline LPoint4f LPoint4f::operator -(LVector4f const &amp;other) const;</span>

<span class="s0">3042 10 operator * 0 4 3649 20 LPoint4f::operator * 0 1 1199 0</span>
<span class="s0">57</span>
<span class="s0">inline LPoint4f LPoint4f::operator *(float scalar) const;</span>

<span class="s0">3043 10 operator / 0 4 3649 20 LPoint4f::operator / 0 1 1200 0</span>
<span class="s0">57</span>
<span class="s0">inline LPoint4f LPoint4f::operator /(float scalar) const;</span>

<span class="s0">3044 10 normalized 0 4 3649 20 LPoint4f::normalized 0 1 1201 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LPoint4f LPoint4f::normalized(void) const;</span>

<span class="s0">3045 7 project 0 4 3649 17 LPoint4f::project 0 1 1202 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LPoint4f LPoint4f::project(LVecBase4f const &amp;onto) const;</span>

<span class="s0">3046 8 __repr__ 0 4 3649 18 LPoint4f::__repr__ 0 1 1203 0</span>
<span class="s0">50</span>
<span class="s0">inline std::string LPoint4f::__repr__(void) const;</span>

<span class="s0">3047 14 get_class_type 0 4 3649 24 LPoint4f::get_class_type 0 1 1204 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle LPoint4f::get_class_type(void);</span>

<span class="s0">3048 9 ~LPoint4f 0 516 3649 19 LPoint4f::~LPoint4f 0 0 0</span>
<span class="s0">26</span>
<span class="s0">LPoint4f::~LPoint4f(void);</span>

<span class="s0">3049 8 LPoint4d 0 260 3650 18 LPoint4d::LPoint4d 0 6 1205 1206 1207 1208 1209 1210 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">322</span>
<span class="s0">inline LPoint4d::LPoint4d(void) = default;</span>
<span class="s0">inline LPoint4d::LPoint4d(LVecBase4d const &amp;copy);</span>
<span class="s0">inline LPoint4d::LPoint4d(double fill_value);</span>
<span class="s0">inline LPoint4d::LPoint4d(double x, double y, double z, double w);</span>
<span class="s0">inline LPoint4d::LPoint4d(LVecBase3d const &amp;copy, double w);</span>
<span class="s0">inline LPoint4d::LPoint4d(LPoint4d const &amp;) = default;</span>

<span class="s0">3050 11 __getattr__ 0 4 3650 21 LPoint4d::__getattr__ 0 1 1211 0</span>
<span class="s0">91</span>
<span class="s0">inline PyObject *LPoint4d::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">3051 11 __setattr__ 0 4 3650 21 LPoint4d::__setattr__ 0 1 1212 0</span>
<span class="s0">97</span>
<span class="s0">inline int LPoint4d::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">3052 4 zero 0 4 3650 14 LPoint4d::zero 0 1 1213 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline LPoint4d const &amp;LPoint4d::zero(void);</span>

<span class="s0">3053 6 unit_x 0 4 3650 16 LPoint4d::unit_x 0 1 1214 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4d const &amp;LPoint4d::unit_x(void);</span>

<span class="s0">3054 6 unit_y 0 4 3650 16 LPoint4d::unit_y 0 1 1215 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4d const &amp;LPoint4d::unit_y(void);</span>

<span class="s0">3055 6 unit_z 0 4 3650 16 LPoint4d::unit_z 0 1 1216 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4d const &amp;LPoint4d::unit_z(void);</span>

<span class="s0">3056 6 unit_w 0 4 3650 16 LPoint4d::unit_w 0 1 1217 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit W point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4d const &amp;LPoint4d::unit_w(void);</span>

<span class="s0">3057 7 get_xyz 0 4 3650 17 LPoint4d::get_xyz 0 1 1218 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline LPoint3d LPoint4d::get_xyz(void) const;</span>

<span class="s0">3058 6 get_xy 0 4 3650 16 LPoint4d::get_xy 0 1 1219 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2d LPoint4d::get_xy(void) const;</span>

<span class="s0">3059 10 operator - 0 68 3650 20 LPoint4d::operator - 0 1 1220 0</span>
<span class="s0">49</span>
<span class="s0">inline LPoint4d LPoint4d::operator -(void) const;</span>

<span class="s0">3060 10 operator + 0 4 3650 20 LPoint4d::operator + 0 2 1221 1222 0</span>
<span class="s0">138</span>
<span class="s0">inline LVecBase4d LPoint4d::operator +(LVecBase4d const &amp;other) const;</span>
<span class="s0">inline LPoint4d LPoint4d::operator +(LVector4d const &amp;other) const;</span>

<span class="s0">3061 10 operator - 0 4 3650 20 LPoint4d::operator - 0 3 1223 1224 1225 0</span>
<span class="s0">206</span>
<span class="s0">inline LVecBase4d LPoint4d::operator -(LVecBase4d const &amp;other) const;</span>
<span class="s0">inline LVector4d LPoint4d::operator -(LPoint4d const &amp;other) const;</span>
<span class="s0">inline LPoint4d LPoint4d::operator -(LVector4d const &amp;other) const;</span>

<span class="s0">3062 10 operator * 0 4 3650 20 LPoint4d::operator * 0 1 1226 0</span>
<span class="s0">58</span>
<span class="s0">inline LPoint4d LPoint4d::operator *(double scalar) const;</span>

<span class="s0">3063 10 operator / 0 4 3650 20 LPoint4d::operator / 0 1 1227 0</span>
<span class="s0">58</span>
<span class="s0">inline LPoint4d LPoint4d::operator /(double scalar) const;</span>

<span class="s0">3064 10 normalized 0 4 3650 20 LPoint4d::normalized 0 1 1228 160</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline LPoint4d LPoint4d::normalized(void) const;</span>

<span class="s0">3065 7 project 0 4 3650 17 LPoint4d::project 0 1 1229 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LPoint4d LPoint4d::project(LVecBase4d const &amp;onto) const;</span>

<span class="s0">3066 8 __repr__ 0 4 3650 18 LPoint4d::__repr__ 0 1 1230 0</span>
<span class="s0">50</span>
<span class="s0">inline std::string LPoint4d::__repr__(void) const;</span>

<span class="s0">3067 14 get_class_type 0 4 3650 24 LPoint4d::get_class_type 0 1 1231 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle LPoint4d::get_class_type(void);</span>

<span class="s0">3068 9 ~LPoint4d 0 516 3650 19 LPoint4d::~LPoint4d 0 0 0</span>
<span class="s0">26</span>
<span class="s0">LPoint4d::~LPoint4d(void);</span>

<span class="s0">3069 8 LPoint4i 0 260 3651 18 LPoint4i::LPoint4i 0 6 1232 1233 1234 1235 1236 1237 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">304</span>
<span class="s0">inline LPoint4i::LPoint4i(void) = default;</span>
<span class="s0">inline LPoint4i::LPoint4i(LVecBase4i const &amp;copy);</span>
<span class="s0">inline LPoint4i::LPoint4i(int fill_value);</span>
<span class="s0">inline LPoint4i::LPoint4i(int x, int y, int z, int w);</span>
<span class="s0">inline LPoint4i::LPoint4i(LVecBase3i const &amp;copy, int w);</span>
<span class="s0">inline LPoint4i::LPoint4i(LPoint4i const &amp;) = default;</span>

<span class="s0">3070 11 __getattr__ 0 4 3651 21 LPoint4i::__getattr__ 0 1 1238 0</span>
<span class="s0">91</span>
<span class="s0">inline PyObject *LPoint4i::__getattr__(PyObject *self, std::string const &amp;attr_name) const;</span>

<span class="s0">3071 11 __setattr__ 0 4 3651 21 LPoint4i::__setattr__ 0 1 1239 0</span>
<span class="s0">97</span>
<span class="s0">inline int LPoint4i::__setattr__(PyObject *self, std::string const &amp;attr_name, PyObject *assign);</span>

<span class="s0">3072 4 zero 0 4 3651 14 LPoint4i::zero 0 1 1240 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline LPoint4i const &amp;LPoint4i::zero(void);</span>

<span class="s0">3073 6 unit_x 0 4 3651 16 LPoint4i::unit_x 0 1 1241 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4i const &amp;LPoint4i::unit_x(void);</span>

<span class="s0">3074 6 unit_y 0 4 3651 16 LPoint4i::unit_y 0 1 1242 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4i const &amp;LPoint4i::unit_y(void);</span>

<span class="s0">3075 6 unit_z 0 4 3651 16 LPoint4i::unit_z 0 1 1243 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4i const &amp;LPoint4i::unit_z(void);</span>

<span class="s0">3076 6 unit_w 0 4 3651 16 LPoint4i::unit_w 0 1 1244 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unit W point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline LPoint4i const &amp;LPoint4i::unit_w(void);</span>

<span class="s0">3077 7 get_xyz 0 4 3651 17 LPoint4i::get_xyz 0 1 1245 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline LPoint3i LPoint4i::get_xyz(void) const;</span>

<span class="s0">3078 6 get_xy 0 4 3651 16 LPoint4i::get_xy 0 1 1246 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline LPoint2i LPoint4i::get_xy(void) const;</span>

<span class="s0">3079 10 operator - 0 68 3651 20 LPoint4i::operator - 0 1 1247 0</span>
<span class="s0">49</span>
<span class="s0">inline LPoint4i LPoint4i::operator -(void) const;</span>

<span class="s0">3080 10 operator + 0 4 3651 20 LPoint4i::operator + 0 2 1248 1249 0</span>
<span class="s0">138</span>
<span class="s0">inline LVecBase4i LPoint4i::operator +(LVecBase4i const &amp;other) const;</span>
<span class="s0">inline LPoint4i LPoint4i::operator +(LVector4i const &amp;other) const;</span>

<span class="s0">3081 10 operator - 0 4 3651 20 LPoint4i::operator - 0 3 1250 1251 1252 0</span>
<span class="s0">206</span>
<span class="s0">inline LVecBase4i LPoint4i::operator -(LVecBase4i const &amp;other) const;</span>
<span class="s0">inline LVector4i LPoint4i::operator -(LPoint4i const &amp;other) const;</span>
<span class="s0">inline LPoint4i LPoint4i::operator -(LVector4i const &amp;other) const;</span>

<span class="s0">3082 10 operator * 0 4 3651 20 LPoint4i::operator * 0 1 1253 0</span>
<span class="s0">55</span>
<span class="s0">inline LPoint4i LPoint4i::operator *(int scalar) const;</span>

<span class="s0">3083 10 operator / 0 4 3651 20 LPoint4i::operator / 0 1 1254 0</span>
<span class="s0">55</span>
<span class="s0">inline LPoint4i LPoint4i::operator /(int scalar) const;</span>

<span class="s0">3084 8 __repr__ 0 4 3651 18 LPoint4i::__repr__ 0 1 1255 0</span>
<span class="s0">50</span>
<span class="s0">inline std::string LPoint4i::__repr__(void) const;</span>

<span class="s0">3085 14 get_class_type 0 4 3651 24 LPoint4i::get_class_type 0 1 1256 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle LPoint4i::get_class_type(void);</span>

<span class="s0">3086 9 ~LPoint4i 0 516 3651 19 LPoint4i::~LPoint4i 0 0 0</span>
<span class="s0">26</span>
<span class="s0">LPoint4i::~LPoint4i(void);</span>

<span class="s0">3087 11 operator [] 0 4 3654 27 LMatrix3f::Row::operator [] 0 2 1359 1360 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">inline float LMatrix3f::Row::operator [](int i) const;</span>
<span class="s0">inline float &amp;LMatrix3f::Row::operator [](int i);</span>

<span class="s0">3088 4 size 0 4 3654 20 LMatrix3f::Row::size 0 1 1361 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 3: the number of columns of a LMatrix3.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">static inline int LMatrix3f::Row::size(void);</span>

<span class="s0">3089 17 operator typecast 0 132 3654 33 LMatrix3f::Row::operator typecast 0 1 1362 0</span>
<span class="s0">47</span>
<span class="s0">inline operator LVecBase3f const &amp;(void) const;</span>

<span class="s0">3090 3 Row 0 260 3654 19 LMatrix3f::Row::Row 0 1 1358 60</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a row-level index accessor to the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline LMatrix3f::Row::Row(LMatrix3f::Row const &amp;) = default;</span>

<span class="s0">3091 4 ~Row 0 516 3654 20 LMatrix3f::Row::~Row 0 0 0</span>
<span class="s0">27</span>
<span class="s0">LMatrix3f::Row::~Row(void);</span>

<span class="s0">3092 11 operator [] 0 4 3655 28 LMatrix3f::CRow::operator [] 0 1 1364 0</span>
<span class="s0">55</span>
<span class="s0">inline float LMatrix3f::CRow::operator [](int i) const;</span>

<span class="s0">3093 4 size 0 4 3655 21 LMatrix3f::CRow::size 0 1 1365 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 3: the number of columns of a LMatrix3.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">static inline int LMatrix3f::CRow::size(void);</span>

<span class="s0">3094 17 operator typecast 0 132 3655 34 LMatrix3f::CRow::operator typecast 0 1 1366 0</span>
<span class="s0">47</span>
<span class="s0">inline operator LVecBase3f const &amp;(void) const;</span>

<span class="s0">3095 4 CRow 0 260 3655 21 LMatrix3f::CRow::CRow 0 1 1363 63</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a row-level constant accessor to the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &amp;) = default;</span>

<span class="s0">3096 5 ~CRow 0 516 3655 22 LMatrix3f::CRow::~CRow 0 0 0</span>
<span class="s0">29</span>
<span class="s0">LMatrix3f::CRow::~CRow(void);</span>

<span class="s0">3097 9 LMatrix3f 0 260 3652 20 LMatrix3f::LMatrix3f 0 4 1257 1258 1259 1260 96</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs the matrix from three individual rows.</span>
 <span class="s0">*/</span>
<span class="s0">277</span>
<span class="s0">inline LMatrix3f::LMatrix3f(void);</span>
<span class="s0">inline LMatrix3f::LMatrix3f(LMatrix3f const &amp;other);</span>
<span class="s0">inline LMatrix3f::LMatrix3f(float , float , float , float , float , float , float , float , float );</span>
<span class="s0">inline LMatrix3f::LMatrix3f(LVecBase3f const &amp;, LVecBase3f const &amp;, LVecBase3f const &amp;);</span>

<span class="s0">3098 10 operator = 0 4 3652 21 LMatrix3f::operator = 0 2 1261 1262 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">inline void LMatrix3f::operator =(LMatrix3f const &amp;other);</span>
<span class="s0">inline void LMatrix3f::operator =(float fill_value);</span>

<span class="s0">3099 12 operator new 0 4 3652 23 LMatrix3f::operator new 0 1 1263 0</span>
<span class="s0">122</span>
<span class="s0">inline void *LMatrix3f::operator new(std::size_t size);</span>
<span class="s0">inline void *LMatrix3f::operator new(std::size_t size, void *ptr);</span>

<span class="s0">3100 15 operator delete 0 4 3652 26 LMatrix3f::operator delete 0 0 0</span>
<span class="s0">106</span>
<span class="s0">inline void LMatrix3f::operator delete(void *ptr);</span>
<span class="s0">inline void LMatrix3f::operator delete(void *, void *);</span>

<span class="s0">3101 12 validate_ptr 0 4 3652 23 LMatrix3f::validate_ptr 0 0 0</span>
<span class="s0">60</span>
<span class="s0">static inline bool LMatrix3f::validate_ptr(void const *ptr);</span>

<span class="s0">3102 10 __reduce__ 0 4 3652 21 LMatrix3f::__reduce__ 0 1 1264 0</span>
<span class="s0">61</span>
<span class="s0">inline PyObject *LMatrix3f::__reduce__(PyObject *self) const;</span>

<span class="s0">3103 4 fill 0 4 3652 15 LMatrix3f::fill 0 1 1265 157</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the matrix to the indicated fill_value.  This is of</span>
 <span class="s0">* questionable value, but is sometimes useful when initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void LMatrix3f::fill(float fill_value);</span>

<span class="s0">3104 3 set 0 4 3652 14 LMatrix3f::set 0 1 1266 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">126</span>
<span class="s0">inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);</span>

<span class="s0">3105 11 operator [] 0 4 3652 22 LMatrix3f::operator [] 0 2 1267 1268 0</span>
<span class="s0">112</span>
<span class="s0">inline LMatrix3f::CRow LMatrix3f::operator [](int i) const;</span>
<span class="s0">inline LMatrix3f::Row LMatrix3f::operator [](int i);</span>

<span class="s0">3106 4 size 0 4 3652 15 LMatrix3f::size 0 1 1269 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 3: the number of rows of a LMatrix3.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">static inline int LMatrix3f::size(void);</span>

<span class="s0">3107 7 set_row 0 4 3652 18 LMatrix3f::set_row 0 2 1270 1271 193</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated row of the matrix from a three-component vector.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated row of the matrix from a two-component vector,</span>
 <span class="s0">* ignoring the last column.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline void LMatrix3f::set_row(int row, LVecBase3f const &amp;v);</span>
<span class="s0">inline void LMatrix3f::set_row(int row, LVecBase2f const &amp;v);</span>

<span class="s0">3108 7 set_col 0 4 3652 18 LMatrix3f::set_col 0 2 1272 1273 196</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated column of the matrix from a three-component vector.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated column of the matrix from a two-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline void LMatrix3f::set_col(int col, LVecBase3f const &amp;v);</span>
<span class="s0">inline void LMatrix3f::set_col(int col, LVecBase2f const &amp;v);</span>

<span class="s0">3109 7 get_row 0 4 3652 18 LMatrix3f::get_row 0 2 1274 1275 192</span>
<span class="s0">// these versions inline better</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the indicated row of the matrix as a three-component vector.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Stores the indicated row of the matrix as a three-component vector.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline LVecBase3f LMatrix3f::get_row(int row) const;</span>
<span class="s0">inline void LMatrix3f::get_row(LVecBase3f &amp;result_vec, int row) const;</span>

<span class="s0">3110 7 get_col 0 4 3652 18 LMatrix3f::get_col 0 1 1276 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated column of the matrix as a three-component vector.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LVecBase3f LMatrix3f::get_col(int col) const;</span>

<span class="s0">3111 8 get_row2 0 4 3652 19 LMatrix3f::get_row2 0 1 1277 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated row of the matrix as a two-component vector, ignoring</span>
 <span class="s0">* the last column.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase2f LMatrix3f::get_row2(int row) const;</span>

<span class="s0">3112 8 get_col2 0 4 3652 19 LMatrix3f::get_col2 0 1 1278 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated column of the matrix as a two-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase2f LMatrix3f::get_col2(int col) const;</span>

<span class="s0">3113 11 operator () 0 4 3652 22 LMatrix3f::operator () 0 2 1279 1280 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">inline float &amp;LMatrix3f::operator ()(int row, int col);</span>
<span class="s0">inline float LMatrix3f::operator ()(int row, int col) const;</span>

<span class="s0">3114 6 is_nan 0 4 3652 17 LMatrix3f::is_nan 0 1 1281 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the matrix is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool LMatrix3f::is_nan(void) const;</span>

<span class="s0">3115 11 is_identity 0 4 3652 22 LMatrix3f::is_identity 0 1 1282 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this is (close enough to) the identity matrix, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool LMatrix3f::is_identity(void) const;</span>

<span class="s0">3116 8 get_cell 0 4 3652 19 LMatrix3f::get_cell 0 1 1283 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a particular element of the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline float LMatrix3f::get_cell(int row, int col) const;</span>

<span class="s0">3117 8 set_cell 0 4 3652 19 LMatrix3f::set_cell 0 1 1284 54</span>
<span class="s0">/**</span>
 <span class="s0">* Changes a particular element of the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void LMatrix3f::set_cell(int row, int col, float value);</span>

<span class="s0">3118 8 get_data 0 4 3652 19 LMatrix3f::get_data 0 1 1285 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline float const *LMatrix3f::get_data(void) const;</span>

<span class="s0">3119 18 get_num_components 0 4 3652 29 LMatrix3f::get_num_components 0 1 1286 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of elements in the matrix, nine.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int LMatrix3f::get_num_components(void) const;</span>

<span class="s0">3120 10 operator &lt; 0 4 3652 21 LMatrix3f::operator &lt; 0 1 1287 0</span>
<span class="s0">64</span>
<span class="s0">inline bool LMatrix3f::operator &lt;(LMatrix3f const &amp;other) const;</span>

<span class="s0">3121 11 operator == 0 4 3652 22 LMatrix3f::operator == 0 1 1288 0</span>
<span class="s0">65</span>
<span class="s0">inline bool LMatrix3f::operator ==(LMatrix3f const &amp;other) const;</span>

<span class="s0">3122 11 operator != 0 4 3652 22 LMatrix3f::operator != 0 1 1289 0</span>
<span class="s0">65</span>
<span class="s0">inline bool LMatrix3f::operator !=(LMatrix3f const &amp;other) const;</span>

<span class="s0">3123 10 compare_to 0 4 3652 21 LMatrix3f::compare_to 0 2 1290 1291 333</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts matrices lexicographically, componentwise.  Returns a number less</span>
 <span class="s0">* than 0 if this matrix sorts before the other one, greater than zero if it</span>
 <span class="s0">* sorts after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/</span>
<span class="s0">137</span>
<span class="s0">inline int LMatrix3f::compare_to(LMatrix3f const &amp;other) const;</span>
<span class="s0">int LMatrix3f::compare_to(LMatrix3f const &amp;other, float threshold) const;</span>

<span class="s0">3124 8 get_hash 0 4 3652 19 LMatrix3f::get_hash 0 2 1292 1293 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">inline std::size_t LMatrix3f::get_hash(void) const;</span>
<span class="s0">inline std::size_t LMatrix3f::get_hash(float threshold) const;</span>

<span class="s0">3125 8 add_hash 0 4 3652 19 LMatrix3f::add_hash 0 2 1294 1295 100</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">inline std::size_t LMatrix3f::add_hash(std::size_t hash) const;</span>
<span class="s0">inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const;</span>

<span class="s0">3126 5 xform 0 4 3652 16 LMatrix3f::xform 0 1 1296 52</span>
<span class="s0">/**</span>
 <span class="s0">* 3-component vector or point times matrix.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase3f LMatrix3f::xform(LVecBase3f const &amp;v) const;</span>

<span class="s0">3127 11 xform_point 0 4 3652 22 LMatrix3f::xform_point 0 1 1297 162</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 2-component point (including translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &amp;v) const;</span>

<span class="s0">3128 9 xform_vec 0 4 3652 20 LMatrix3f::xform_vec 0 2 1298 1299 357</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 2-component vector (without translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector and returns the result.  This</span>
 <span class="s0">* assumes the matrix is an orthonormal transform.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, this is the same computation as xform().</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &amp;v) const;</span>
<span class="s0">inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &amp;v) const;</span>

<span class="s0">3129 17 xform_vec_general 0 4 3652 28 LMatrix3f::xform_vec_general 0 1 1300 142</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &amp;v) const;</span>

<span class="s0">3130 14 xform_in_place 0 4 3652 25 LMatrix3f::xform_in_place 0 1 1301 52</span>
<span class="s0">/**</span>
 <span class="s0">* 3-component vector or point times matrix.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void LMatrix3f::xform_in_place(LVecBase3f &amp;v) const;</span>

<span class="s0">3131 20 xform_point_in_place 0 4 3652 31 LMatrix3f::xform_point_in_place 0 1 1302 139</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 2-component point (including translation</span>
 <span class="s0">* component).  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void LMatrix3f::xform_point_in_place(LVecBase2f &amp;v) const;</span>

<span class="s0">3132 18 xform_vec_in_place 0 4 3652 29 LMatrix3f::xform_vec_in_place 0 2 1303 1304 310</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 2-component vector (without translation component).</span>
 <span class="s0">* This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector.  This assumes the matrix is an</span>
 <span class="s0">* orthonormal transform.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, this is the same computation as xform().</span>
 <span class="s0">*/</span>
<span class="s0">127</span>
<span class="s0">inline void LMatrix3f::xform_vec_in_place(LVecBase2f &amp;v) const;</span>
<span class="s0">inline void LMatrix3f::xform_vec_in_place(LVecBase3f &amp;v) const;</span>

<span class="s0">3133 26 xform_vec_general_in_place 0 4 3652 37 LMatrix3f::xform_vec_general_in_place 0 1 1305 119</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component),</span>
 <span class="s0">* as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &amp;v) const;</span>

<span class="s0">3134 8 multiply 0 4 3652 19 LMatrix3f::multiply 0 1 1306 52</span>
<span class="s0">// this = other1 * other2</span>

<span class="s0">// this = other1 * other2</span>
<span class="s0">82</span>
<span class="s0">inline void LMatrix3f::multiply(LMatrix3f const &amp;other1, LMatrix3f const &amp;other2);</span>

<span class="s0">3135 10 operator * 0 4 3652 21 LMatrix3f::operator * 0 2 1307 1308 0</span>
<span class="s0">129</span>
<span class="s0">inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &amp;other) const;</span>
<span class="s0">inline LMatrix3f LMatrix3f::operator *(float scalar) const;</span>

<span class="s0">3136 10 operator / 0 4 3652 21 LMatrix3f::operator / 0 1 1309 0</span>
<span class="s0">59</span>
<span class="s0">inline LMatrix3f LMatrix3f::operator /(float scalar) const;</span>

<span class="s0">3137 11 operator += 0 4 3652 22 LMatrix3f::operator += 0 1 1310 63</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise addition between two matrices.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LMatrix3f &amp;LMatrix3f::operator +=(LMatrix3f const &amp;other);</span>

<span class="s0">3138 11 operator -= 0 4 3652 22 LMatrix3f::operator -= 0 1 1311 66</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise subtraction between two matrices.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LMatrix3f &amp;LMatrix3f::operator -=(LMatrix3f const &amp;other);</span>

<span class="s0">3139 11 operator *= 0 4 3652 22 LMatrix3f::operator *= 0 2 1312 1313 51</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise scale.</span>
 <span class="s0">*/</span>
<span class="s0">121</span>
<span class="s0">inline LMatrix3f &amp;LMatrix3f::operator *=(LMatrix3f const &amp;other);</span>
<span class="s0">inline LMatrix3f &amp;LMatrix3f::operator *=(float scalar);</span>

<span class="s0">3140 11 operator /= 0 4 3652 22 LMatrix3f::operator /= 0 1 1314 39</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise scale.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LMatrix3f &amp;LMatrix3f::operator /=(float scalar);</span>

<span class="s0">3141 18 componentwise_mult 0 4 3652 29 LMatrix3f::componentwise_mult 0 1 1315 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void LMatrix3f::componentwise_mult(LMatrix3f const &amp;other);</span>

<span class="s0">3142 11 determinant 0 4 3652 22 LMatrix3f::determinant 0 1 1316 49</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the determinant of the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline float LMatrix3f::determinant(void) const;</span>

<span class="s0">3143 14 transpose_from 0 4 3652 25 LMatrix3f::transpose_from 0 1 1317 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void LMatrix3f::transpose_from(LMatrix3f const &amp;other);</span>

<span class="s0">3144 18 transpose_in_place 0 4 3652 29 LMatrix3f::transpose_in_place 0 1 1318 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void LMatrix3f::transpose_in_place(void);</span>

<span class="s0">3145 11 invert_from 0 4 3652 22 LMatrix3f::invert_from 0 1 1319 463</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the inverse of the other matrix, and stores the result in this</span>
 <span class="s0">* matrix.  This is a fully general operation and makes no assumptions about</span>
 <span class="s0">* the type of transform represented by the matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* The other matrix must be a different object than this matrix.  However, if</span>
 <span class="s0">* you need to invert a matrix in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the matrix was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool LMatrix3f::invert_from(LMatrix3f const &amp;other);</span>

<span class="s0">3146 15 invert_in_place 0 4 3652 26 LMatrix3f::invert_in_place 0 1 1320 119</span>
<span class="s0">/**</span>
 <span class="s0">* Inverts the current matrix.  Returns true if the inverse is successful,</span>
 <span class="s0">* false if the matrix was singular.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool LMatrix3f::invert_in_place(void);</span>

<span class="s0">3147 21 invert_transpose_from 0 4 3652 32 LMatrix3f::invert_transpose_from 0 2 1321 1322 230</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously computes the inverse of the indicated matrix, and then the</span>
 <span class="s0">* transpose of that inverse.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Simultaneously computes the inverse of the indicated matrix, and then the</span>
 <span class="s0">* transpose of that inverse.</span>
 <span class="s0">*/</span>
<span class="s0">139</span>
<span class="s0">inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &amp;other);</span>
<span class="s0">inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &amp;other);</span>

<span class="s0">3148 9 ident_mat 0 4 3652 20 LMatrix3f::ident_mat 0 1 1323 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an identity matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* This function definition must appear first, since some inline functions</span>
 <span class="s0">* below take advantage of it.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">static inline LMatrix3f const &amp;LMatrix3f::ident_mat(void);</span>

<span class="s0">3149 17 set_translate_mat 0 4 3652 28 LMatrix3f::set_translate_mat 0 1 1324 74</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void LMatrix3f::set_translate_mat(LVecBase2f const &amp;trans);</span>

<span class="s0">3150 14 set_rotate_mat 0 4 3652 25 LMatrix3f::set_rotate_mat 0 2 1325 1326 225</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">inline void LMatrix3f::set_rotate_mat(float angle);</span>
<span class="s0">void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3151 13 set_scale_mat 0 4 3652 24 LMatrix3f::set_scale_mat 0 2 1327 1328 194</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the two</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the</span>
 <span class="s0">* three axes.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">inline void LMatrix3f::set_scale_mat(LVecBase2f const &amp;scale);</span>
<span class="s0">inline void LMatrix3f::set_scale_mat(LVecBase3f const &amp;scale);</span>

<span class="s0">3152 13 translate_mat 0 4 3652 24 LMatrix3f::translate_mat 0 2 1329 1330 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &amp;trans);</span>
<span class="s0">static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty);</span>

<span class="s0">3153 10 rotate_mat 0 4 3652 21 LMatrix3f::rotate_mat 0 2 1331 1332 211</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/</span>
<span class="s0">179</span>
<span class="s0">static inline LMatrix3f LMatrix3f::rotate_mat(float angle);</span>
<span class="s0">static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3154 9 scale_mat 0 4 3652 20 LMatrix3f::scale_mat 0 4 1333 1334 1335 1336 356</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the two axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the two axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/</span>
<span class="s0">283</span>
<span class="s0">static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &amp;scale);</span>
<span class="s0">static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy);</span>
<span class="s0">static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &amp;scale);</span>
<span class="s0">static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz);</span>

<span class="s0">3155 23 set_rotate_mat_normaxis 0 4 3652 34 LMatrix3f::set_rotate_mat_normaxis 0 1 1337 163</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* normalized.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3156 19 rotate_mat_normaxis 0 4 3652 30 LMatrix3f::rotate_mat_normaxis 0 1 1338 156</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* normalized.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3157 13 set_shear_mat 0 4 3652 24 LMatrix3f::set_shear_mat 0 1 1339 99</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated shear in each of the</span>
 <span class="s0">* three planes.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline void LMatrix3f::set_shear_mat(LVecBase3f const &amp;shear, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3158 9 shear_mat 0 4 3652 20 LMatrix3f::shear_mat 0 2 1340 1341 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/</span>
<span class="s0">224</span>
<span class="s0">static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &amp;shear, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3159 19 set_scale_shear_mat 0 4 3652 30 LMatrix3f::set_scale_shear_mat 0 1 1342 78</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">void LMatrix3f::set_scale_shear_mat(LVecBase3f const &amp;scale, LVecBase3f const &amp;shear, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3160 15 scale_shear_mat 0 4 3652 26 LMatrix3f::scale_shear_mat 0 2 1343 1344 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>
<span class="s0">291</span>
<span class="s0">static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &amp;scale, LVecBase3f const &amp;shear, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3161 11 convert_mat 0 4 3652 22 LMatrix3f::convert_mat 0 1 1345 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that transforms from the indicated coordinate system to</span>
 <span class="s0">* the indicated coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">static LMatrix3f const &amp;LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to);</span>

<span class="s0">3162 12 almost_equal 0 4 3652 23 LMatrix3f::almost_equal 0 2 1346 1347 212</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">bool LMatrix3f::almost_equal(LMatrix3f const &amp;other, float threshold) const;</span>
<span class="s0">inline bool LMatrix3f::almost_equal(LMatrix3f const &amp;other) const;</span>

<span class="s0">3163 6 output 0 4 3652 17 LMatrix3f::output 0 1 1348 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void LMatrix3f::output(std::ostream &amp;out) const;</span>

<span class="s0">3164 5 write 0 4 3652 16 LMatrix3f::write 0 1 1349 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void LMatrix3f::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">3165 8 __repr__ 0 4 3652 19 LMatrix3f::__repr__ 0 1 1350 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LMatrix3f::__repr__(void) const;</span>

<span class="s0">3166 13 generate_hash 0 4 3652 24 LMatrix3f::generate_hash 0 2 1351 1352 120</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">inline void LMatrix3f::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>
<span class="s0">void LMatrix3f::generate_hash(ChecksumHashGenerator &amp;hashgen, float threshold) const;</span>

<span class="s0">3167 20 write_datagram_fixed 0 4 3652 31 LMatrix3f::write_datagram_fixed 0 1 1353 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the matrix, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">void LMatrix3f::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">3168 19 read_datagram_fixed 0 4 3652 30 LMatrix3f::read_datagram_fixed 0 1 1354 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void LMatrix3f::read_datagram_fixed(DatagramIterator &amp;scan);</span>

<span class="s0">3169 14 write_datagram 0 4 3652 25 LMatrix3f::write_datagram 0 1 1355 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the matrix using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void LMatrix3f::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">3170 13 read_datagram 0 4 3652 24 LMatrix3f::read_datagram 0 1 1356 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void LMatrix3f::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">3171 14 get_class_type 0 4 3652 25 LMatrix3f::get_class_type 0 1 1357 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LMatrix3f::get_class_type(void);</span>

<span class="s0">3172 10 ~LMatrix3f 0 516 3652 21 LMatrix3f::~LMatrix3f 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LMatrix3f::~LMatrix3f(void);</span>

<span class="s0">3173 9 transpose 0 1 0 9 transpose 0 4 1929 1930 1931 1932 0</span>
<span class="s0">191</span>
<span class="s0">inline LMatrix3f transpose(LMatrix3f const &amp;a);</span>
<span class="s0">inline LMatrix4f transpose(LMatrix4f const &amp;a);</span>
<span class="s0">inline LMatrix3d transpose(LMatrix3d const &amp;a);</span>
<span class="s0">inline LMatrix4d transpose(LMatrix4d const &amp;a);</span>

<span class="s0">3174 6 invert 0 1 0 6 invert 0 6 1933 1934 1935 1936 1937 1938 0</span>
<span class="s0">281</span>
<span class="s0">inline LMatrix3f invert(LMatrix3f const &amp;a);</span>
<span class="s0">inline LMatrix4f invert(LMatrix4f const &amp;a);</span>
<span class="s0">inline LMatrix3d invert(LMatrix3d const &amp;a);</span>
<span class="s0">inline LMatrix4d invert(LMatrix4d const &amp;a);</span>
<span class="s0">inline LQuaternionf invert(LQuaternionf const &amp;a);</span>
<span class="s0">inline LQuaterniond invert(LQuaterniond const &amp;a);</span>

<span class="s0">3175 11 operator [] 0 4 3658 27 LMatrix4f::Row::operator [] 0 2 1479 1480 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">inline float LMatrix4f::Row::operator [](int i) const;</span>
<span class="s0">inline float &amp;LMatrix4f::Row::operator [](int i);</span>

<span class="s0">3176 4 size 0 4 3658 20 LMatrix4f::Row::size 0 1 1481 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 4: the number of columns of a LMatrix4.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">static inline int LMatrix4f::Row::size(void);</span>

<span class="s0">3177 17 operator typecast 0 132 3658 33 LMatrix4f::Row::operator typecast 0 1 1482 0</span>
<span class="s0">47</span>
<span class="s0">inline operator LVecBase4f const &amp;(void) const;</span>

<span class="s0">3178 3 Row 0 260 3658 19 LMatrix4f::Row::Row 0 1 1478 60</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a row-level index accessor to the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline LMatrix4f::Row::Row(LMatrix4f::Row const &amp;) = default;</span>

<span class="s0">3179 4 ~Row 0 516 3658 20 LMatrix4f::Row::~Row 0 0 0</span>
<span class="s0">27</span>
<span class="s0">LMatrix4f::Row::~Row(void);</span>

<span class="s0">3180 11 operator [] 0 4 3659 28 LMatrix4f::CRow::operator [] 0 1 1484 0</span>
<span class="s0">55</span>
<span class="s0">inline float LMatrix4f::CRow::operator [](int i) const;</span>

<span class="s0">3181 4 size 0 4 3659 21 LMatrix4f::CRow::size 0 1 1485 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 4: the number of columns of a LMatrix4.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">static inline int LMatrix4f::CRow::size(void);</span>

<span class="s0">3182 17 operator typecast 0 132 3659 34 LMatrix4f::CRow::operator typecast 0 1 1486 0</span>
<span class="s0">47</span>
<span class="s0">inline operator LVecBase4f const &amp;(void) const;</span>

<span class="s0">3183 4 CRow 0 260 3659 21 LMatrix4f::CRow::CRow 0 1 1483 63</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a row-level constant accessor to the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &amp;) = default;</span>

<span class="s0">3184 5 ~CRow 0 516 3659 22 LMatrix4f::CRow::~CRow 0 0 0</span>
<span class="s0">29</span>
<span class="s0">LMatrix4f::CRow::~CRow(void);</span>

<span class="s0">3185 9 LMatrix4f 0 260 3656 20 LMatrix4f::LMatrix4f 0 7 1367 1368 1369 1370 1371 1372 1373 228</span>
<span class="s0">// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional</span>
<span class="s0">// translation component.</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs the matrix from four individual rows.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">548</span>
<span class="s0">inline LMatrix4f::LMatrix4f(void);</span>
<span class="s0">inline LMatrix4f::LMatrix4f(LMatrix4f const &amp;other);</span>
<span class="s0">inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &amp;other);</span>
<span class="s0">inline LMatrix4f::LMatrix4f(float , float , float , float , float , float , float , float , float , float , float , float , float , float , float , float );</span>
<span class="s0">inline LMatrix4f::LMatrix4f(LVecBase4f const &amp;, LVecBase4f const &amp;, LVecBase4f const &amp;, LVecBase4f const &amp;);</span>
<span class="s0">inline LMatrix4f::LMatrix4f(LMatrix3f const &amp;upper3);</span>
<span class="s0">inline LMatrix4f::LMatrix4f(LMatrix3f const &amp;upper3, LVecBase3f const &amp;trans);</span>

<span class="s0">3186 10 operator = 0 4 3656 21 LMatrix4f::operator = 0 3 1374 1375 1376 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">179</span>
<span class="s0">inline void LMatrix4f::operator =(LMatrix4f const &amp;other);</span>
<span class="s0">inline void LMatrix4f::operator =(UnalignedLMatrix4f const &amp;other);</span>
<span class="s0">inline void LMatrix4f::operator =(float fill_value);</span>

<span class="s0">3187 12 operator new 0 4 3656 23 LMatrix4f::operator new 0 1 1377 0</span>
<span class="s0">122</span>
<span class="s0">inline void *LMatrix4f::operator new(std::size_t size);</span>
<span class="s0">inline void *LMatrix4f::operator new(std::size_t size, void *ptr);</span>

<span class="s0">3188 15 operator delete 0 4 3656 26 LMatrix4f::operator delete 0 0 0</span>
<span class="s0">106</span>
<span class="s0">inline void LMatrix4f::operator delete(void *ptr);</span>
<span class="s0">inline void LMatrix4f::operator delete(void *, void *);</span>

<span class="s0">3189 12 validate_ptr 0 4 3656 23 LMatrix4f::validate_ptr 0 0 0</span>
<span class="s0">60</span>
<span class="s0">static inline bool LMatrix4f::validate_ptr(void const *ptr);</span>

<span class="s0">3190 10 __reduce__ 0 4 3656 21 LMatrix4f::__reduce__ 0 1 1378 0</span>
<span class="s0">61</span>
<span class="s0">inline PyObject *LMatrix4f::__reduce__(PyObject *self) const;</span>

<span class="s0">3191 4 fill 0 4 3656 15 LMatrix4f::fill 0 1 1379 157</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the matrix to the indicated fill_value.  This is of</span>
 <span class="s0">* questionable value, but is sometimes useful when initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void LMatrix4f::fill(float fill_value);</span>

<span class="s0">3192 3 set 0 4 3656 14 LMatrix4f::set 0 1 1380 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">203</span>
<span class="s0">inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);</span>

<span class="s0">3193 11 set_upper_3 0 4 3656 22 LMatrix4f::set_upper_3 0 1 1381 87</span>
<span class="s0">// Get and set the upper 3x3 rotation matrix.</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the upper 3x3 submatrix.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void LMatrix4f::set_upper_3(LMatrix3f const &amp;upper3);</span>

<span class="s0">3194 11 get_upper_3 0 4 3656 22 LMatrix4f::get_upper_3 0 1 1382 45</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the upper 3x3 submatrix.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LMatrix3f LMatrix4f::get_upper_3(void) const;</span>

<span class="s0">3195 11 operator [] 0 4 3656 22 LMatrix4f::operator [] 0 2 1383 1384 0</span>
<span class="s0">112</span>
<span class="s0">inline LMatrix4f::CRow LMatrix4f::operator [](int i) const;</span>
<span class="s0">inline LMatrix4f::Row LMatrix4f::operator [](int i);</span>

<span class="s0">3196 4 size 0 4 3656 15 LMatrix4f::size 0 1 1385 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 4: the number of rows of a LMatrix4.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">static inline int LMatrix4f::size(void);</span>

<span class="s0">3197 7 set_row 0 4 3656 18 LMatrix4f::set_row 0 2 1386 1387 173</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated row of the matrix.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated row of the matrix with the indicated 3-component</span>
 <span class="s0">* vector, ignoring the last column.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline void LMatrix4f::set_row(int row, LVecBase4f const &amp;v);</span>
<span class="s0">inline void LMatrix4f::set_row(int row, LVecBase3f const &amp;v);</span>

<span class="s0">3198 7 set_col 0 4 3656 18 LMatrix4f::set_col 0 2 1388 1389 176</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated column of the matrix.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated column of the matrix with the indicated 3-component</span>
 <span class="s0">* vector, ignoring the last row.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline void LMatrix4f::set_col(int col, LVecBase4f const &amp;v);</span>
<span class="s0">inline void LMatrix4f::set_col(int col, LVecBase3f const &amp;v);</span>

<span class="s0">3199 7 get_row 0 4 3656 18 LMatrix4f::get_row 0 2 1390 1391 186</span>
<span class="s0">// these versions inline better</span>

<span class="s0">/**</span>
 <span class="s0">* Retrieves the indicated row of the matrix as a 4-component vector.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Stores the indicated row of the matrix as a 4-component vector.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline LVecBase4f LMatrix4f::get_row(int row) const;</span>
<span class="s0">inline void LMatrix4f::get_row(LVecBase4f &amp;result_vec, int row) const;</span>

<span class="s0">3200 7 get_col 0 4 3656 18 LMatrix4f::get_col 0 1 1392 80</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the indicated column of the matrix as a 4-component vector.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LVecBase4f LMatrix4f::get_col(int col) const;</span>

<span class="s0">3201 8 get_row3 0 4 3656 19 LMatrix4f::get_row3 0 2 1393 1394 205</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the row column of the matrix as a 3-component vector, ignoring</span>
 <span class="s0">* the last column.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Stores the row column of the matrix as a 3-component vector, ignoring the</span>
 <span class="s0">* last column.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">inline LVecBase3f LMatrix4f::get_row3(int row) const;</span>
<span class="s0">inline void LMatrix4f::get_row3(LVecBase3f &amp;result_vec, int row) const;</span>

<span class="s0">3202 8 get_col3 0 4 3656 19 LMatrix4f::get_col3 0 1 1395 106</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the indicated column of the matrix as a 3-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase3f LMatrix4f::get_col3(int col) const;</span>

<span class="s0">3203 11 operator () 0 4 3656 22 LMatrix4f::operator () 0 2 1396 1397 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">inline float &amp;LMatrix4f::operator ()(int row, int col);</span>
<span class="s0">inline float LMatrix4f::operator ()(int row, int col) const;</span>

<span class="s0">3204 6 is_nan 0 4 3656 17 LMatrix4f::is_nan 0 1 1398 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the matrix is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool LMatrix4f::is_nan(void) const;</span>

<span class="s0">3205 11 is_identity 0 4 3656 22 LMatrix4f::is_identity 0 1 1399 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this is (close enough to) the identity matrix, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool LMatrix4f::is_identity(void) const;</span>

<span class="s0">3206 8 get_cell 0 4 3656 19 LMatrix4f::get_cell 0 1 1400 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a particular element of the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline float LMatrix4f::get_cell(int row, int col) const;</span>

<span class="s0">3207 8 set_cell 0 4 3656 19 LMatrix4f::set_cell 0 1 1401 54</span>
<span class="s0">/**</span>
 <span class="s0">* Changes a particular element of the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void LMatrix4f::set_cell(int row, int col, float value);</span>

<span class="s0">3208 8 get_data 0 4 3656 19 LMatrix4f::get_data 0 1 1402 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline float const *LMatrix4f::get_data(void) const;</span>

<span class="s0">3209 18 get_num_components 0 4 3656 29 LMatrix4f::get_num_components 0 1 1403 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of elements in the matrix, 16.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int LMatrix4f::get_num_components(void) const;</span>

<span class="s0">3210 5 begin 0 4 3656 16 LMatrix4f::begin 0 2 1404 1405 204</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">inline LMatrix4f::iterator LMatrix4f::begin(void);</span>
<span class="s0">inline LMatrix4f::const_iterator LMatrix4f::begin(void) const;</span>

<span class="s0">3211 3 end 0 4 3656 14 LMatrix4f::end 0 2 1406 1407 204</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">inline LMatrix4f::iterator LMatrix4f::end(void);</span>
<span class="s0">inline LMatrix4f::const_iterator LMatrix4f::end(void) const;</span>

<span class="s0">3212 10 operator &lt; 0 4 3656 21 LMatrix4f::operator &lt; 0 1 1408 0</span>
<span class="s0">64</span>
<span class="s0">inline bool LMatrix4f::operator &lt;(LMatrix4f const &amp;other) const;</span>

<span class="s0">3213 11 operator == 0 4 3656 22 LMatrix4f::operator == 0 1 1409 0</span>
<span class="s0">65</span>
<span class="s0">inline bool LMatrix4f::operator ==(LMatrix4f const &amp;other) const;</span>

<span class="s0">3214 11 operator != 0 4 3656 22 LMatrix4f::operator != 0 1 1410 0</span>
<span class="s0">65</span>
<span class="s0">inline bool LMatrix4f::operator !=(LMatrix4f const &amp;other) const;</span>

<span class="s0">3215 10 compare_to 0 4 3656 21 LMatrix4f::compare_to 0 2 1411 1412 333</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts matrices lexicographically, componentwise.  Returns a number less</span>
 <span class="s0">* than 0 if this matrix sorts before the other one, greater than zero if it</span>
 <span class="s0">* sorts after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/</span>
<span class="s0">137</span>
<span class="s0">inline int LMatrix4f::compare_to(LMatrix4f const &amp;other) const;</span>
<span class="s0">int LMatrix4f::compare_to(LMatrix4f const &amp;other, float threshold) const;</span>

<span class="s0">3216 8 get_hash 0 4 3656 19 LMatrix4f::get_hash 0 2 1413 1414 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">inline std::size_t LMatrix4f::get_hash(void) const;</span>
<span class="s0">inline std::size_t LMatrix4f::get_hash(float threshold) const;</span>

<span class="s0">3217 8 add_hash 0 4 3656 19 LMatrix4f::add_hash 0 2 1415 1416 100</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">inline std::size_t LMatrix4f::add_hash(std::size_t hash) const;</span>
<span class="s0">inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const;</span>

<span class="s0">3218 5 xform 0 4 3656 16 LMatrix4f::xform 0 1 1417 91</span>
<span class="s0">/**</span>
 <span class="s0">* 4-component vector or point times matrix.  This is a fully general</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase4f LMatrix4f::xform(LVecBase4f const &amp;v) const;</span>

<span class="s0">3219 11 xform_point 0 4 3656 22 LMatrix4f::xform_point 0 1 1418 162</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &amp;v) const;</span>

<span class="s0">3220 19 xform_point_general 0 4 3656 30 LMatrix4f::xform_point_general 0 1 1419 143</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &amp;v) const;</span>

<span class="s0">3221 9 xform_vec 0 4 3656 20 LMatrix4f::xform_vec 0 1 1420 169</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an orthonormal</span>
 <span class="s0">* transform.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &amp;v) const;</span>

<span class="s0">3222 17 xform_vec_general 0 4 3656 28 LMatrix4f::xform_vec_general 0 1 1421 142</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &amp;v) const;</span>

<span class="s0">3223 14 xform_in_place 0 4 3656 25 LMatrix4f::xform_in_place 0 1 1422 91</span>
<span class="s0">/**</span>
 <span class="s0">* 4-component vector or point times matrix.  This is a fully general</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void LMatrix4f::xform_in_place(LVecBase4f &amp;v) const;</span>

<span class="s0">3224 20 xform_point_in_place 0 4 3656 31 LMatrix4f::xform_point_in_place 0 1 1423 139</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation</span>
 <span class="s0">* component).  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void LMatrix4f::xform_point_in_place(LVecBase3f &amp;v) const;</span>

<span class="s0">3225 28 xform_point_general_in_place 0 4 3656 39 LMatrix4f::xform_point_general_in_place 0 1 1424 120</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation</span>
 <span class="s0">* component), as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &amp;v) const;</span>

<span class="s0">3226 18 xform_vec_in_place 0 4 3656 29 LMatrix4f::xform_vec_in_place 0 1 1425 142</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component).</span>
 <span class="s0">* This assumes the matrix is an orthonormal transform.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void LMatrix4f::xform_vec_in_place(LVecBase3f &amp;v) const;</span>

<span class="s0">3227 26 xform_vec_general_in_place 0 4 3656 37 LMatrix4f::xform_vec_general_in_place 0 1 1426 119</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component),</span>
 <span class="s0">* as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &amp;v) const;</span>

<span class="s0">3228 8 multiply 0 4 3656 19 LMatrix4f::multiply 0 1 1427 52</span>
<span class="s0">// this = other1 * other2</span>

<span class="s0">// this = other1 * other2</span>
<span class="s0">82</span>
<span class="s0">inline void LMatrix4f::multiply(LMatrix4f const &amp;other1, LMatrix4f const &amp;other2);</span>

<span class="s0">3229 10 operator * 0 4 3656 21 LMatrix4f::operator * 0 2 1428 1429 0</span>
<span class="s0">129</span>
<span class="s0">inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &amp;other) const;</span>
<span class="s0">inline LMatrix4f LMatrix4f::operator *(float scalar) const;</span>

<span class="s0">3230 10 operator / 0 4 3656 21 LMatrix4f::operator / 0 1 1430 0</span>
<span class="s0">59</span>
<span class="s0">inline LMatrix4f LMatrix4f::operator /(float scalar) const;</span>

<span class="s0">3231 11 operator += 0 4 3656 22 LMatrix4f::operator += 0 1 1431 63</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise addition between two matrices.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LMatrix4f &amp;LMatrix4f::operator +=(LMatrix4f const &amp;other);</span>

<span class="s0">3232 11 operator -= 0 4 3656 22 LMatrix4f::operator -= 0 1 1432 66</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise subtraction between two matrices.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LMatrix4f &amp;LMatrix4f::operator -=(LMatrix4f const &amp;other);</span>

<span class="s0">3233 11 operator *= 0 4 3656 22 LMatrix4f::operator *= 0 2 1433 1434 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">121</span>
<span class="s0">inline LMatrix4f &amp;LMatrix4f::operator *=(LMatrix4f const &amp;other);</span>
<span class="s0">inline LMatrix4f &amp;LMatrix4f::operator *=(float scalar);</span>

<span class="s0">3234 11 operator /= 0 4 3656 22 LMatrix4f::operator /= 0 1 1435 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LMatrix4f &amp;LMatrix4f::operator /=(float scalar);</span>

<span class="s0">3235 18 componentwise_mult 0 4 3656 29 LMatrix4f::componentwise_mult 0 1 1436 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void LMatrix4f::componentwise_mult(LMatrix4f const &amp;other);</span>

<span class="s0">3236 14 transpose_from 0 4 3656 25 LMatrix4f::transpose_from 0 1 1437 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void LMatrix4f::transpose_from(LMatrix4f const &amp;other);</span>

<span class="s0">3237 18 transpose_in_place 0 4 3656 29 LMatrix4f::transpose_in_place 0 1 1438 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void LMatrix4f::transpose_in_place(void);</span>

<span class="s0">3238 11 invert_from 0 4 3656 22 LMatrix4f::invert_from 0 1 1439 461</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the inverse of the other matrix, and stores the result in this</span>
 <span class="s0">* matrix.  This is a fully general operation and makes no assumptions about</span>
 <span class="s0">* the type of transform represented by the matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* The other matrix must be a different object than this matrix.  However, if</span>
 <span class="s0">* you need to invert a matrix in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the matrix was successfully inverted, false if</span>
 <span class="s0">* the was a singularity.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool LMatrix4f::invert_from(LMatrix4f const &amp;other);</span>

<span class="s0">3239 18 invert_affine_from 0 4 3656 29 LMatrix4f::invert_affine_from 0 1 1440 139</span>
<span class="s0">// bugbug: we could optimize this for rotationscaletranslation matrices</span>
<span class="s0">// (transpose upper 3x3 and take negative of translation component)</span>
<span class="s0">66</span>
<span class="s0">inline bool LMatrix4f::invert_affine_from(LMatrix4f const &amp;other);</span>

<span class="s0">3240 15 invert_in_place 0 4 3656 26 LMatrix4f::invert_in_place 0 1 1441 119</span>
<span class="s0">/**</span>
 <span class="s0">* Inverts the current matrix.  Returns true if the inverse is successful,</span>
 <span class="s0">* false if the matrix was singular.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool LMatrix4f::invert_in_place(void);</span>

<span class="s0">3241 10 accumulate 0 4 3656 21 LMatrix4f::accumulate 0 1 1442 48</span>
<span class="s0">/**</span>
 <span class="s0">* Computes `(*this) += other * weight`.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void LMatrix4f::accumulate(LMatrix4f const &amp;other, float weight);</span>

<span class="s0">3242 9 ident_mat 0 4 3656 20 LMatrix4f::ident_mat 0 1 1443 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an identity matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* This function definition must appear first, since some inline functions</span>
 <span class="s0">* below take advantage of it.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">static inline LMatrix4f const &amp;LMatrix4f::ident_mat(void);</span>

<span class="s0">3243 8 ones_mat 0 4 3656 19 LMatrix4f::ones_mat 0 1 1444 46</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an matrix filled with ones.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LMatrix4f const &amp;LMatrix4f::ones_mat(void);</span>

<span class="s0">3244 9 zeros_mat 0 4 3656 20 LMatrix4f::zeros_mat 0 1 1445 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an matrix filled with zeros.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">static inline LMatrix4f const &amp;LMatrix4f::zeros_mat(void);</span>

<span class="s0">3245 17 set_translate_mat 0 4 3656 28 LMatrix4f::set_translate_mat 0 1 1446 74</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void LMatrix4f::set_translate_mat(LVecBase3f const &amp;trans);</span>

<span class="s0">3246 14 set_rotate_mat 0 4 3656 25 LMatrix4f::set_rotate_mat 0 1 1447 122</span>
<span class="s0">/**</span>
 <span class="s0">* Sets mat to a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3247 23 set_rotate_mat_normaxis 0 4 3656 34 LMatrix4f::set_rotate_mat_normaxis 0 1 1448 166</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* prenormalized.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3248 13 set_scale_mat 0 4 3656 24 LMatrix4f::set_scale_mat 0 1 1449 97</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the</span>
 <span class="s0">* three axes.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void LMatrix4f::set_scale_mat(LVecBase3f const &amp;scale);</span>

<span class="s0">3249 13 set_shear_mat 0 4 3656 24 LMatrix4f::set_shear_mat 0 1 1450 99</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated shear in each of the</span>
 <span class="s0">* three planes.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline void LMatrix4f::set_shear_mat(LVecBase3f const &amp;shear, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3250 19 set_scale_shear_mat 0 4 3656 30 LMatrix4f::set_scale_shear_mat 0 1 1451 78</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>
<span class="s0">129</span>
<span class="s0">inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &amp;scale, LVecBase3f const &amp;shear, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3251 13 translate_mat 0 4 3656 24 LMatrix4f::translate_mat 0 2 1452 1453 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>
<span class="s0">154</span>
<span class="s0">static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &amp;trans);</span>
<span class="s0">static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz);</span>

<span class="s0">3252 10 rotate_mat 0 4 3656 21 LMatrix4f::rotate_mat 0 1 1454 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3253 19 rotate_mat_normaxis 0 4 3656 30 LMatrix4f::rotate_mat_normaxis 0 1 1455 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* prenormalized.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3254 9 scale_mat 0 4 3656 20 LMatrix4f::scale_mat 0 3 1456 1457 1458 253</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated uniform scale.</span>
 <span class="s0">*/</span>
<span class="s0">205</span>
<span class="s0">static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &amp;scale);</span>
<span class="s0">static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz);</span>
<span class="s0">static inline LMatrix4f LMatrix4f::scale_mat(float scale);</span>

<span class="s0">3255 9 shear_mat 0 4 3656 20 LMatrix4f::shear_mat 0 2 1459 1460 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/</span>
<span class="s0">224</span>
<span class="s0">static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &amp;shear, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3256 15 scale_shear_mat 0 4 3656 26 LMatrix4f::scale_shear_mat 0 2 1461 1462 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>
<span class="s0">291</span>
<span class="s0">static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &amp;scale, LVecBase3f const &amp;shear, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3257 13 y_to_z_up_mat 0 4 3656 24 LMatrix4f::y_to_z_up_mat 0 1 1463 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that transforms from the Y-up coordinate system to the</span>
 <span class="s0">* Z-up coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static inline LMatrix4f const &amp;LMatrix4f::y_to_z_up_mat(void);</span>

<span class="s0">3258 13 z_to_y_up_mat 0 4 3656 24 LMatrix4f::z_to_y_up_mat 0 1 1464 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that transforms from the Y-up coordinate system to the</span>
 <span class="s0">* Z-up coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static inline LMatrix4f const &amp;LMatrix4f::z_to_y_up_mat(void);</span>

<span class="s0">3259 11 convert_mat 0 4 3656 22 LMatrix4f::convert_mat 0 1 1465 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that transforms from the indicated coordinate system to</span>
 <span class="s0">* the indicated coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">static LMatrix4f const &amp;LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to);</span>

<span class="s0">3260 12 almost_equal 0 4 3656 23 LMatrix4f::almost_equal 0 2 1466 1467 318</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a specified</span>
 <span class="s0">* tolerance.  This is faster than the equivalence operator as this doesn't</span>
 <span class="s0">* have to guarantee that it is transitive.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">bool LMatrix4f::almost_equal(LMatrix4f const &amp;other, float threshold) const;</span>
<span class="s0">inline bool LMatrix4f::almost_equal(LMatrix4f const &amp;other) const;</span>

<span class="s0">3261 6 output 0 4 3656 17 LMatrix4f::output 0 1 1468 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void LMatrix4f::output(std::ostream &amp;out) const;</span>

<span class="s0">3262 5 write 0 4 3656 16 LMatrix4f::write 0 1 1469 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void LMatrix4f::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">3263 8 __repr__ 0 4 3656 19 LMatrix4f::__repr__ 0 1 1470 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LMatrix4f::__repr__(void) const;</span>

<span class="s0">3264 13 generate_hash 0 4 3656 24 LMatrix4f::generate_hash 0 2 1471 1472 120</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">157</span>
<span class="s0">inline void LMatrix4f::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>
<span class="s0">void LMatrix4f::generate_hash(ChecksumHashGenerator &amp;hashgen, float scale) const;</span>

<span class="s0">3265 20 write_datagram_fixed 0 4 3656 31 LMatrix4f::write_datagram_fixed 0 1 1473 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the matrix, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">void LMatrix4f::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">3266 19 read_datagram_fixed 0 4 3656 30 LMatrix4f::read_datagram_fixed 0 1 1474 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void LMatrix4f::read_datagram_fixed(DatagramIterator &amp;scan);</span>

<span class="s0">3267 14 write_datagram 0 4 3656 25 LMatrix4f::write_datagram 0 1 1475 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the matrix using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void LMatrix4f::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">3268 13 read_datagram 0 4 3656 24 LMatrix4f::read_datagram 0 1 1476 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void LMatrix4f::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">3269 14 get_class_type 0 4 3656 25 LMatrix4f::get_class_type 0 1 1477 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LMatrix4f::get_class_type(void);</span>

<span class="s0">3270 10 ~LMatrix4f 0 516 3656 21 LMatrix4f::~LMatrix4f 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LMatrix4f::~LMatrix4f(void);</span>

<span class="s0">3271 18 UnalignedLMatrix4f 0 260 3660 38 UnalignedLMatrix4f::UnalignedLMatrix4f 0 4 1487 1488 1489 1490 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">424</span>
<span class="s0">inline UnalignedLMatrix4f::UnalignedLMatrix4f(void);</span>
<span class="s0">inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &amp;copy);</span>
<span class="s0">inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &amp;copy);</span>
<span class="s0">inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);</span>

<span class="s0">3272 10 operator = 0 4 3660 30 UnalignedLMatrix4f::operator = 0 2 1491 1492 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">142</span>
<span class="s0">inline void UnalignedLMatrix4f::operator =(LMatrix4f const &amp;copy);</span>
<span class="s0">inline void UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &amp;copy);</span>

<span class="s0">3273 3 set 0 4 3660 23 UnalignedLMatrix4f::set 0 1 1493 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">212</span>
<span class="s0">inline void UnalignedLMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);</span>

<span class="s0">3274 11 operator () 0 4 3660 31 UnalignedLMatrix4f::operator () 0 2 1494 1495 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">inline float &amp;UnalignedLMatrix4f::operator ()(int row, int col);</span>
<span class="s0">inline float UnalignedLMatrix4f::operator ()(int row, int col) const;</span>

<span class="s0">3275 8 get_data 0 4 3660 28 UnalignedLMatrix4f::get_data 0 1 1496 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline float const *UnalignedLMatrix4f::get_data(void) const;</span>

<span class="s0">3276 18 get_num_components 0 4 3660 38 UnalignedLMatrix4f::get_num_components 0 1 1497 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of elements in the matrix, sixteen.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int UnalignedLMatrix4f::get_num_components(void) const;</span>

<span class="s0">3277 11 operator == 0 4 3660 31 UnalignedLMatrix4f::operator == 0 1 1498 0</span>
<span class="s0">83</span>
<span class="s0">inline bool UnalignedLMatrix4f::operator ==(UnalignedLMatrix4f const &amp;other) const;</span>

<span class="s0">3278 11 operator != 0 4 3660 31 UnalignedLMatrix4f::operator != 0 1 1499 0</span>
<span class="s0">83</span>
<span class="s0">inline bool UnalignedLMatrix4f::operator !=(UnalignedLMatrix4f const &amp;other) const;</span>

<span class="s0">3279 14 get_class_type 0 4 3660 34 UnalignedLMatrix4f::get_class_type 0 1 1500 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle UnalignedLMatrix4f::get_class_type(void);</span>

<span class="s0">3280 19 ~UnalignedLMatrix4f 0 516 3660 39 UnalignedLMatrix4f::~UnalignedLMatrix4f 0 0 0</span>
<span class="s0">46</span>
<span class="s0">UnalignedLMatrix4f::~UnalignedLMatrix4f(void);</span>

<span class="s0">3281 11 operator [] 0 4 3664 27 LMatrix3d::Row::operator [] 0 2 1603 1604 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">inline double LMatrix3d::Row::operator [](int i) const;</span>
<span class="s0">inline double &amp;LMatrix3d::Row::operator [](int i);</span>

<span class="s0">3282 4 size 0 4 3664 20 LMatrix3d::Row::size 0 1 1605 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 3: the number of columns of a LMatrix3.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">static inline int LMatrix3d::Row::size(void);</span>

<span class="s0">3283 17 operator typecast 0 132 3664 33 LMatrix3d::Row::operator typecast 0 1 1606 0</span>
<span class="s0">47</span>
<span class="s0">inline operator LVecBase3d const &amp;(void) const;</span>

<span class="s0">3284 3 Row 0 260 3664 19 LMatrix3d::Row::Row 0 1 1602 60</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a row-level index accessor to the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline LMatrix3d::Row::Row(LMatrix3d::Row const &amp;) = default;</span>

<span class="s0">3285 4 ~Row 0 516 3664 20 LMatrix3d::Row::~Row 0 0 0</span>
<span class="s0">27</span>
<span class="s0">LMatrix3d::Row::~Row(void);</span>

<span class="s0">3286 11 operator [] 0 4 3665 28 LMatrix3d::CRow::operator [] 0 1 1608 0</span>
<span class="s0">56</span>
<span class="s0">inline double LMatrix3d::CRow::operator [](int i) const;</span>

<span class="s0">3287 4 size 0 4 3665 21 LMatrix3d::CRow::size 0 1 1609 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 3: the number of columns of a LMatrix3.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">static inline int LMatrix3d::CRow::size(void);</span>

<span class="s0">3288 17 operator typecast 0 132 3665 34 LMatrix3d::CRow::operator typecast 0 1 1610 0</span>
<span class="s0">47</span>
<span class="s0">inline operator LVecBase3d const &amp;(void) const;</span>

<span class="s0">3289 4 CRow 0 260 3665 21 LMatrix3d::CRow::CRow 0 1 1607 63</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a row-level constant accessor to the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &amp;) = default;</span>

<span class="s0">3290 5 ~CRow 0 516 3665 22 LMatrix3d::CRow::~CRow 0 0 0</span>
<span class="s0">29</span>
<span class="s0">LMatrix3d::CRow::~CRow(void);</span>

<span class="s0">3291 9 LMatrix3d 0 260 3662 20 LMatrix3d::LMatrix3d 0 4 1501 1502 1503 1504 96</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs the matrix from three individual rows.</span>
 <span class="s0">*/</span>
<span class="s0">286</span>
<span class="s0">inline LMatrix3d::LMatrix3d(void);</span>
<span class="s0">inline LMatrix3d::LMatrix3d(LMatrix3d const &amp;other);</span>
<span class="s0">inline LMatrix3d::LMatrix3d(double , double , double , double , double , double , double , double , double );</span>
<span class="s0">inline LMatrix3d::LMatrix3d(LVecBase3d const &amp;, LVecBase3d const &amp;, LVecBase3d const &amp;);</span>

<span class="s0">3292 10 operator = 0 4 3662 21 LMatrix3d::operator = 0 2 1505 1506 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">inline void LMatrix3d::operator =(LMatrix3d const &amp;other);</span>
<span class="s0">inline void LMatrix3d::operator =(double fill_value);</span>

<span class="s0">3293 12 operator new 0 4 3662 23 LMatrix3d::operator new 0 1 1507 0</span>
<span class="s0">122</span>
<span class="s0">inline void *LMatrix3d::operator new(std::size_t size);</span>
<span class="s0">inline void *LMatrix3d::operator new(std::size_t size, void *ptr);</span>

<span class="s0">3294 15 operator delete 0 4 3662 26 LMatrix3d::operator delete 0 0 0</span>
<span class="s0">106</span>
<span class="s0">inline void LMatrix3d::operator delete(void *ptr);</span>
<span class="s0">inline void LMatrix3d::operator delete(void *, void *);</span>

<span class="s0">3295 12 validate_ptr 0 4 3662 23 LMatrix3d::validate_ptr 0 0 0</span>
<span class="s0">60</span>
<span class="s0">static inline bool LMatrix3d::validate_ptr(void const *ptr);</span>

<span class="s0">3296 10 __reduce__ 0 4 3662 21 LMatrix3d::__reduce__ 0 1 1508 0</span>
<span class="s0">61</span>
<span class="s0">inline PyObject *LMatrix3d::__reduce__(PyObject *self) const;</span>

<span class="s0">3297 4 fill 0 4 3662 15 LMatrix3d::fill 0 1 1509 157</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the matrix to the indicated fill_value.  This is of</span>
 <span class="s0">* questionable value, but is sometimes useful when initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void LMatrix3d::fill(double fill_value);</span>

<span class="s0">3298 3 set 0 4 3662 14 LMatrix3d::set 0 1 1510 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);</span>

<span class="s0">3299 11 operator [] 0 4 3662 22 LMatrix3d::operator [] 0 2 1511 1512 0</span>
<span class="s0">112</span>
<span class="s0">inline LMatrix3d::CRow LMatrix3d::operator [](int i) const;</span>
<span class="s0">inline LMatrix3d::Row LMatrix3d::operator [](int i);</span>

<span class="s0">3300 4 size 0 4 3662 15 LMatrix3d::size 0 1 1513 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 3: the number of rows of a LMatrix3.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">static inline int LMatrix3d::size(void);</span>

<span class="s0">3301 7 set_row 0 4 3662 18 LMatrix3d::set_row 0 2 1514 1515 193</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated row of the matrix from a three-component vector.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated row of the matrix from a two-component vector,</span>
 <span class="s0">* ignoring the last column.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline void LMatrix3d::set_row(int row, LVecBase3d const &amp;v);</span>
<span class="s0">inline void LMatrix3d::set_row(int row, LVecBase2d const &amp;v);</span>

<span class="s0">3302 7 set_col 0 4 3662 18 LMatrix3d::set_col 0 2 1516 1517 196</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated column of the matrix from a three-component vector.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated column of the matrix from a two-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline void LMatrix3d::set_col(int col, LVecBase3d const &amp;v);</span>
<span class="s0">inline void LMatrix3d::set_col(int col, LVecBase2d const &amp;v);</span>

<span class="s0">3303 7 get_row 0 4 3662 18 LMatrix3d::get_row 0 2 1518 1519 192</span>
<span class="s0">// these versions inline better</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the indicated row of the matrix as a three-component vector.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Stores the indicated row of the matrix as a three-component vector.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline LVecBase3d LMatrix3d::get_row(int row) const;</span>
<span class="s0">inline void LMatrix3d::get_row(LVecBase3d &amp;result_vec, int row) const;</span>

<span class="s0">3304 7 get_col 0 4 3662 18 LMatrix3d::get_col 0 1 1520 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated column of the matrix as a three-component vector.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LVecBase3d LMatrix3d::get_col(int col) const;</span>

<span class="s0">3305 8 get_row2 0 4 3662 19 LMatrix3d::get_row2 0 1 1521 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated row of the matrix as a two-component vector, ignoring</span>
 <span class="s0">* the last column.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase2d LMatrix3d::get_row2(int row) const;</span>

<span class="s0">3306 8 get_col2 0 4 3662 19 LMatrix3d::get_col2 0 1 1522 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated column of the matrix as a two-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase2d LMatrix3d::get_col2(int col) const;</span>

<span class="s0">3307 11 operator () 0 4 3662 22 LMatrix3d::operator () 0 2 1523 1524 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">inline double &amp;LMatrix3d::operator ()(int row, int col);</span>
<span class="s0">inline double LMatrix3d::operator ()(int row, int col) const;</span>

<span class="s0">3308 6 is_nan 0 4 3662 17 LMatrix3d::is_nan 0 1 1525 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the matrix is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool LMatrix3d::is_nan(void) const;</span>

<span class="s0">3309 11 is_identity 0 4 3662 22 LMatrix3d::is_identity 0 1 1526 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this is (close enough to) the identity matrix, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool LMatrix3d::is_identity(void) const;</span>

<span class="s0">3310 8 get_cell 0 4 3662 19 LMatrix3d::get_cell 0 1 1527 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a particular element of the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline double LMatrix3d::get_cell(int row, int col) const;</span>

<span class="s0">3311 8 set_cell 0 4 3662 19 LMatrix3d::set_cell 0 1 1528 54</span>
<span class="s0">/**</span>
 <span class="s0">* Changes a particular element of the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LMatrix3d::set_cell(int row, int col, double value);</span>

<span class="s0">3312 8 get_data 0 4 3662 19 LMatrix3d::get_data 0 1 1529 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline double const *LMatrix3d::get_data(void) const;</span>

<span class="s0">3313 18 get_num_components 0 4 3662 29 LMatrix3d::get_num_components 0 1 1530 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of elements in the matrix, nine.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int LMatrix3d::get_num_components(void) const;</span>

<span class="s0">3314 10 operator &lt; 0 4 3662 21 LMatrix3d::operator &lt; 0 1 1531 0</span>
<span class="s0">64</span>
<span class="s0">inline bool LMatrix3d::operator &lt;(LMatrix3d const &amp;other) const;</span>

<span class="s0">3315 11 operator == 0 4 3662 22 LMatrix3d::operator == 0 1 1532 0</span>
<span class="s0">65</span>
<span class="s0">inline bool LMatrix3d::operator ==(LMatrix3d const &amp;other) const;</span>

<span class="s0">3316 11 operator != 0 4 3662 22 LMatrix3d::operator != 0 1 1533 0</span>
<span class="s0">65</span>
<span class="s0">inline bool LMatrix3d::operator !=(LMatrix3d const &amp;other) const;</span>

<span class="s0">3317 10 compare_to 0 4 3662 21 LMatrix3d::compare_to 0 2 1534 1535 333</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts matrices lexicographically, componentwise.  Returns a number less</span>
 <span class="s0">* than 0 if this matrix sorts before the other one, greater than zero if it</span>
 <span class="s0">* sorts after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/</span>
<span class="s0">138</span>
<span class="s0">inline int LMatrix3d::compare_to(LMatrix3d const &amp;other) const;</span>
<span class="s0">int LMatrix3d::compare_to(LMatrix3d const &amp;other, double threshold) const;</span>

<span class="s0">3318 8 get_hash 0 4 3662 19 LMatrix3d::get_hash 0 2 1536 1537 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">115</span>
<span class="s0">inline std::size_t LMatrix3d::get_hash(void) const;</span>
<span class="s0">inline std::size_t LMatrix3d::get_hash(double threshold) const;</span>

<span class="s0">3319 8 add_hash 0 4 3662 19 LMatrix3d::add_hash 0 2 1538 1539 100</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">145</span>
<span class="s0">inline std::size_t LMatrix3d::add_hash(std::size_t hash) const;</span>
<span class="s0">inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const;</span>

<span class="s0">3320 5 xform 0 4 3662 16 LMatrix3d::xform 0 1 1540 52</span>
<span class="s0">/**</span>
 <span class="s0">* 3-component vector or point times matrix.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase3d LMatrix3d::xform(LVecBase3d const &amp;v) const;</span>

<span class="s0">3321 11 xform_point 0 4 3662 22 LMatrix3d::xform_point 0 1 1541 162</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 2-component point (including translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &amp;v) const;</span>

<span class="s0">3322 9 xform_vec 0 4 3662 20 LMatrix3d::xform_vec 0 2 1542 1543 357</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 2-component vector (without translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector and returns the result.  This</span>
 <span class="s0">* assumes the matrix is an orthonormal transform.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, this is the same computation as xform().</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &amp;v) const;</span>
<span class="s0">inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &amp;v) const;</span>

<span class="s0">3323 17 xform_vec_general 0 4 3662 28 LMatrix3d::xform_vec_general 0 1 1544 142</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &amp;v) const;</span>

<span class="s0">3324 14 xform_in_place 0 4 3662 25 LMatrix3d::xform_in_place 0 1 1545 52</span>
<span class="s0">/**</span>
 <span class="s0">* 3-component vector or point times matrix.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void LMatrix3d::xform_in_place(LVecBase3d &amp;v) const;</span>

<span class="s0">3325 20 xform_point_in_place 0 4 3662 31 LMatrix3d::xform_point_in_place 0 1 1546 139</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 2-component point (including translation</span>
 <span class="s0">* component).  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void LMatrix3d::xform_point_in_place(LVecBase2d &amp;v) const;</span>

<span class="s0">3326 18 xform_vec_in_place 0 4 3662 29 LMatrix3d::xform_vec_in_place 0 2 1547 1548 310</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 2-component vector (without translation component).</span>
 <span class="s0">* This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector.  This assumes the matrix is an</span>
 <span class="s0">* orthonormal transform.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, this is the same computation as xform().</span>
 <span class="s0">*/</span>
<span class="s0">127</span>
<span class="s0">inline void LMatrix3d::xform_vec_in_place(LVecBase2d &amp;v) const;</span>
<span class="s0">inline void LMatrix3d::xform_vec_in_place(LVecBase3d &amp;v) const;</span>

<span class="s0">3327 26 xform_vec_general_in_place 0 4 3662 37 LMatrix3d::xform_vec_general_in_place 0 1 1549 119</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component),</span>
 <span class="s0">* as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &amp;v) const;</span>

<span class="s0">3328 8 multiply 0 4 3662 19 LMatrix3d::multiply 0 1 1550 52</span>
<span class="s0">// this = other1 * other2</span>

<span class="s0">// this = other1 * other2</span>
<span class="s0">82</span>
<span class="s0">inline void LMatrix3d::multiply(LMatrix3d const &amp;other1, LMatrix3d const &amp;other2);</span>

<span class="s0">3329 10 operator * 0 4 3662 21 LMatrix3d::operator * 0 2 1551 1552 0</span>
<span class="s0">130</span>
<span class="s0">inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &amp;other) const;</span>
<span class="s0">inline LMatrix3d LMatrix3d::operator *(double scalar) const;</span>

<span class="s0">3330 10 operator / 0 4 3662 21 LMatrix3d::operator / 0 1 1553 0</span>
<span class="s0">60</span>
<span class="s0">inline LMatrix3d LMatrix3d::operator /(double scalar) const;</span>

<span class="s0">3331 11 operator += 0 4 3662 22 LMatrix3d::operator += 0 1 1554 63</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise addition between two matrices.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LMatrix3d &amp;LMatrix3d::operator +=(LMatrix3d const &amp;other);</span>

<span class="s0">3332 11 operator -= 0 4 3662 22 LMatrix3d::operator -= 0 1 1555 66</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise subtraction between two matrices.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LMatrix3d &amp;LMatrix3d::operator -=(LMatrix3d const &amp;other);</span>

<span class="s0">3333 11 operator *= 0 4 3662 22 LMatrix3d::operator *= 0 2 1556 1557 51</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise scale.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">inline LMatrix3d &amp;LMatrix3d::operator *=(LMatrix3d const &amp;other);</span>
<span class="s0">inline LMatrix3d &amp;LMatrix3d::operator *=(double scalar);</span>

<span class="s0">3334 11 operator /= 0 4 3662 22 LMatrix3d::operator /= 0 1 1558 39</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise scale.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LMatrix3d &amp;LMatrix3d::operator /=(double scalar);</span>

<span class="s0">3335 18 componentwise_mult 0 4 3662 29 LMatrix3d::componentwise_mult 0 1 1559 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void LMatrix3d::componentwise_mult(LMatrix3d const &amp;other);</span>

<span class="s0">3336 11 determinant 0 4 3662 22 LMatrix3d::determinant 0 1 1560 49</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the determinant of the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline double LMatrix3d::determinant(void) const;</span>

<span class="s0">3337 14 transpose_from 0 4 3662 25 LMatrix3d::transpose_from 0 1 1561 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void LMatrix3d::transpose_from(LMatrix3d const &amp;other);</span>

<span class="s0">3338 18 transpose_in_place 0 4 3662 29 LMatrix3d::transpose_in_place 0 1 1562 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void LMatrix3d::transpose_in_place(void);</span>

<span class="s0">3339 11 invert_from 0 4 3662 22 LMatrix3d::invert_from 0 1 1563 463</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the inverse of the other matrix, and stores the result in this</span>
 <span class="s0">* matrix.  This is a fully general operation and makes no assumptions about</span>
 <span class="s0">* the type of transform represented by the matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* The other matrix must be a different object than this matrix.  However, if</span>
 <span class="s0">* you need to invert a matrix in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the matrix was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool LMatrix3d::invert_from(LMatrix3d const &amp;other);</span>

<span class="s0">3340 15 invert_in_place 0 4 3662 26 LMatrix3d::invert_in_place 0 1 1564 119</span>
<span class="s0">/**</span>
 <span class="s0">* Inverts the current matrix.  Returns true if the inverse is successful,</span>
 <span class="s0">* false if the matrix was singular.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool LMatrix3d::invert_in_place(void);</span>

<span class="s0">3341 21 invert_transpose_from 0 4 3662 32 LMatrix3d::invert_transpose_from 0 2 1565 1566 230</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously computes the inverse of the indicated matrix, and then the</span>
 <span class="s0">* transpose of that inverse.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Simultaneously computes the inverse of the indicated matrix, and then the</span>
 <span class="s0">* transpose of that inverse.</span>
 <span class="s0">*/</span>
<span class="s0">139</span>
<span class="s0">inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &amp;other);</span>
<span class="s0">inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &amp;other);</span>

<span class="s0">3342 9 ident_mat 0 4 3662 20 LMatrix3d::ident_mat 0 1 1567 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an identity matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* This function definition must appear first, since some inline functions</span>
 <span class="s0">* below take advantage of it.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">static inline LMatrix3d const &amp;LMatrix3d::ident_mat(void);</span>

<span class="s0">3343 17 set_translate_mat 0 4 3662 28 LMatrix3d::set_translate_mat 0 1 1568 74</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void LMatrix3d::set_translate_mat(LVecBase2d const &amp;trans);</span>

<span class="s0">3344 14 set_rotate_mat 0 4 3662 25 LMatrix3d::set_rotate_mat 0 2 1569 1570 225</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/</span>
<span class="s0">158</span>
<span class="s0">inline void LMatrix3d::set_rotate_mat(double angle);</span>
<span class="s0">void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3345 13 set_scale_mat 0 4 3662 24 LMatrix3d::set_scale_mat 0 2 1571 1572 194</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the two</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the</span>
 <span class="s0">* three axes.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">inline void LMatrix3d::set_scale_mat(LVecBase2d const &amp;scale);</span>
<span class="s0">inline void LMatrix3d::set_scale_mat(LVecBase3d const &amp;scale);</span>

<span class="s0">3346 13 translate_mat 0 4 3662 24 LMatrix3d::translate_mat 0 2 1573 1574 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>
<span class="s0">146</span>
<span class="s0">static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &amp;trans);</span>
<span class="s0">static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty);</span>

<span class="s0">3347 10 rotate_mat 0 4 3662 21 LMatrix3d::rotate_mat 0 2 1575 1576 211</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/</span>
<span class="s0">181</span>
<span class="s0">static inline LMatrix3d LMatrix3d::rotate_mat(double angle);</span>
<span class="s0">static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3348 9 scale_mat 0 4 3662 20 LMatrix3d::scale_mat 0 4 1577 1578 1579 1580 356</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the two axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the two axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/</span>
<span class="s0">288</span>
<span class="s0">static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &amp;scale);</span>
<span class="s0">static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy);</span>
<span class="s0">static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &amp;scale);</span>
<span class="s0">static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz);</span>

<span class="s0">3349 23 set_rotate_mat_normaxis 0 4 3662 34 LMatrix3d::set_rotate_mat_normaxis 0 1 1581 163</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* normalized.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3350 19 rotate_mat_normaxis 0 4 3662 30 LMatrix3d::rotate_mat_normaxis 0 1 1582 156</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* normalized.</span>
 <span class="s0">*/</span>
<span class="s0">129</span>
<span class="s0">static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3351 13 set_shear_mat 0 4 3662 24 LMatrix3d::set_shear_mat 0 1 1583 99</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated shear in each of the</span>
 <span class="s0">* three planes.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline void LMatrix3d::set_shear_mat(LVecBase3d const &amp;shear, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3352 9 shear_mat 0 4 3662 20 LMatrix3d::shear_mat 0 2 1584 1585 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/</span>
<span class="s0">227</span>
<span class="s0">static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &amp;shear, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3353 19 set_scale_shear_mat 0 4 3662 30 LMatrix3d::set_scale_shear_mat 0 1 1586 78</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">void LMatrix3d::set_scale_shear_mat(LVecBase3d const &amp;scale, LVecBase3d const &amp;shear, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3354 15 scale_shear_mat 0 4 3662 26 LMatrix3d::scale_shear_mat 0 2 1587 1588 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>
<span class="s0">297</span>
<span class="s0">static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &amp;scale, LVecBase3d const &amp;shear, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3355 11 convert_mat 0 4 3662 22 LMatrix3d::convert_mat 0 1 1589 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that transforms from the indicated coordinate system to</span>
 <span class="s0">* the indicated coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">static LMatrix3d const &amp;LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to);</span>

<span class="s0">3356 12 almost_equal 0 4 3662 23 LMatrix3d::almost_equal 0 2 1590 1591 212</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">bool LMatrix3d::almost_equal(LMatrix3d const &amp;other, double threshold) const;</span>
<span class="s0">inline bool LMatrix3d::almost_equal(LMatrix3d const &amp;other) const;</span>

<span class="s0">3357 6 output 0 4 3662 17 LMatrix3d::output 0 1 1592 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void LMatrix3d::output(std::ostream &amp;out) const;</span>

<span class="s0">3358 5 write 0 4 3662 16 LMatrix3d::write 0 1 1593 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void LMatrix3d::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">3359 8 __repr__ 0 4 3662 19 LMatrix3d::__repr__ 0 1 1594 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LMatrix3d::__repr__(void) const;</span>

<span class="s0">3360 13 generate_hash 0 4 3662 24 LMatrix3d::generate_hash 0 2 1595 1596 120</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">162</span>
<span class="s0">inline void LMatrix3d::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>
<span class="s0">void LMatrix3d::generate_hash(ChecksumHashGenerator &amp;hashgen, double threshold) const;</span>

<span class="s0">3361 20 write_datagram_fixed 0 4 3662 31 LMatrix3d::write_datagram_fixed 0 1 1597 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the matrix, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">void LMatrix3d::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">3362 19 read_datagram_fixed 0 4 3662 30 LMatrix3d::read_datagram_fixed 0 1 1598 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void LMatrix3d::read_datagram_fixed(DatagramIterator &amp;scan);</span>

<span class="s0">3363 14 write_datagram 0 4 3662 25 LMatrix3d::write_datagram 0 1 1599 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the matrix using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void LMatrix3d::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">3364 13 read_datagram 0 4 3662 24 LMatrix3d::read_datagram 0 1 1600 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void LMatrix3d::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">3365 14 get_class_type 0 4 3662 25 LMatrix3d::get_class_type 0 1 1601 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LMatrix3d::get_class_type(void);</span>

<span class="s0">3366 10 ~LMatrix3d 0 516 3662 21 LMatrix3d::~LMatrix3d 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LMatrix3d::~LMatrix3d(void);</span>

<span class="s0">3367 11 operator [] 0 4 3668 27 LMatrix4d::Row::operator [] 0 2 1723 1724 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">inline double LMatrix4d::Row::operator [](int i) const;</span>
<span class="s0">inline double &amp;LMatrix4d::Row::operator [](int i);</span>

<span class="s0">3368 4 size 0 4 3668 20 LMatrix4d::Row::size 0 1 1725 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 4: the number of columns of a LMatrix4.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">static inline int LMatrix4d::Row::size(void);</span>

<span class="s0">3369 17 operator typecast 0 132 3668 33 LMatrix4d::Row::operator typecast 0 1 1726 0</span>
<span class="s0">47</span>
<span class="s0">inline operator LVecBase4d const &amp;(void) const;</span>

<span class="s0">3370 3 Row 0 260 3668 19 LMatrix4d::Row::Row 0 1 1722 60</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a row-level index accessor to the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline LMatrix4d::Row::Row(LMatrix4d::Row const &amp;) = default;</span>

<span class="s0">3371 4 ~Row 0 516 3668 20 LMatrix4d::Row::~Row 0 0 0</span>
<span class="s0">27</span>
<span class="s0">LMatrix4d::Row::~Row(void);</span>

<span class="s0">3372 11 operator [] 0 4 3669 28 LMatrix4d::CRow::operator [] 0 1 1728 0</span>
<span class="s0">56</span>
<span class="s0">inline double LMatrix4d::CRow::operator [](int i) const;</span>

<span class="s0">3373 4 size 0 4 3669 21 LMatrix4d::CRow::size 0 1 1729 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 4: the number of columns of a LMatrix4.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">static inline int LMatrix4d::CRow::size(void);</span>

<span class="s0">3374 17 operator typecast 0 132 3669 34 LMatrix4d::CRow::operator typecast 0 1 1730 0</span>
<span class="s0">47</span>
<span class="s0">inline operator LVecBase4d const &amp;(void) const;</span>

<span class="s0">3375 4 CRow 0 260 3669 21 LMatrix4d::CRow::CRow 0 1 1727 63</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a row-level constant accessor to the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &amp;) = default;</span>

<span class="s0">3376 5 ~CRow 0 516 3669 22 LMatrix4d::CRow::~CRow 0 0 0</span>
<span class="s0">29</span>
<span class="s0">LMatrix4d::CRow::~CRow(void);</span>

<span class="s0">3377 9 LMatrix4d 0 260 3666 20 LMatrix4d::LMatrix4d 0 7 1611 1612 1613 1614 1615 1616 1617 228</span>
<span class="s0">// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional</span>
<span class="s0">// translation component.</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs the matrix from four individual rows.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">564</span>
<span class="s0">inline LMatrix4d::LMatrix4d(void);</span>
<span class="s0">inline LMatrix4d::LMatrix4d(LMatrix4d const &amp;other);</span>
<span class="s0">inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &amp;other);</span>
<span class="s0">inline LMatrix4d::LMatrix4d(double , double , double , double , double , double , double , double , double , double , double , double , double , double , double , double );</span>
<span class="s0">inline LMatrix4d::LMatrix4d(LVecBase4d const &amp;, LVecBase4d const &amp;, LVecBase4d const &amp;, LVecBase4d const &amp;);</span>
<span class="s0">inline LMatrix4d::LMatrix4d(LMatrix3d const &amp;upper3);</span>
<span class="s0">inline LMatrix4d::LMatrix4d(LMatrix3d const &amp;upper3, LVecBase3d const &amp;trans);</span>

<span class="s0">3378 10 operator = 0 4 3666 21 LMatrix4d::operator = 0 3 1618 1619 1620 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">180</span>
<span class="s0">inline void LMatrix4d::operator =(LMatrix4d const &amp;other);</span>
<span class="s0">inline void LMatrix4d::operator =(UnalignedLMatrix4d const &amp;other);</span>
<span class="s0">inline void LMatrix4d::operator =(double fill_value);</span>

<span class="s0">3379 12 operator new 0 4 3666 23 LMatrix4d::operator new 0 1 1621 0</span>
<span class="s0">122</span>
<span class="s0">inline void *LMatrix4d::operator new(std::size_t size);</span>
<span class="s0">inline void *LMatrix4d::operator new(std::size_t size, void *ptr);</span>

<span class="s0">3380 15 operator delete 0 4 3666 26 LMatrix4d::operator delete 0 0 0</span>
<span class="s0">106</span>
<span class="s0">inline void LMatrix4d::operator delete(void *ptr);</span>
<span class="s0">inline void LMatrix4d::operator delete(void *, void *);</span>

<span class="s0">3381 12 validate_ptr 0 4 3666 23 LMatrix4d::validate_ptr 0 0 0</span>
<span class="s0">60</span>
<span class="s0">static inline bool LMatrix4d::validate_ptr(void const *ptr);</span>

<span class="s0">3382 10 __reduce__ 0 4 3666 21 LMatrix4d::__reduce__ 0 1 1622 0</span>
<span class="s0">61</span>
<span class="s0">inline PyObject *LMatrix4d::__reduce__(PyObject *self) const;</span>

<span class="s0">3383 4 fill 0 4 3666 15 LMatrix4d::fill 0 1 1623 157</span>
<span class="s0">/**</span>
 <span class="s0">* Sets each element of the matrix to the indicated fill_value.  This is of</span>
 <span class="s0">* questionable value, but is sometimes useful when initializing to zero.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void LMatrix4d::fill(double fill_value);</span>

<span class="s0">3384 3 set 0 4 3666 14 LMatrix4d::set 0 1 1624 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">219</span>
<span class="s0">inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);</span>

<span class="s0">3385 11 set_upper_3 0 4 3666 22 LMatrix4d::set_upper_3 0 1 1625 87</span>
<span class="s0">// Get and set the upper 3x3 rotation matrix.</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the upper 3x3 submatrix.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void LMatrix4d::set_upper_3(LMatrix3d const &amp;upper3);</span>

<span class="s0">3386 11 get_upper_3 0 4 3666 22 LMatrix4d::get_upper_3 0 1 1626 45</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the upper 3x3 submatrix.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LMatrix3d LMatrix4d::get_upper_3(void) const;</span>

<span class="s0">3387 11 operator [] 0 4 3666 22 LMatrix4d::operator [] 0 2 1627 1628 0</span>
<span class="s0">112</span>
<span class="s0">inline LMatrix4d::CRow LMatrix4d::operator [](int i) const;</span>
<span class="s0">inline LMatrix4d::Row LMatrix4d::operator [](int i);</span>

<span class="s0">3388 4 size 0 4 3666 15 LMatrix4d::size 0 1 1629 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 4: the number of rows of a LMatrix4.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">static inline int LMatrix4d::size(void);</span>

<span class="s0">3389 7 set_row 0 4 3666 18 LMatrix4d::set_row 0 2 1630 1631 173</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated row of the matrix.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated row of the matrix with the indicated 3-component</span>
 <span class="s0">* vector, ignoring the last column.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline void LMatrix4d::set_row(int row, LVecBase4d const &amp;v);</span>
<span class="s0">inline void LMatrix4d::set_row(int row, LVecBase3d const &amp;v);</span>

<span class="s0">3390 7 set_col 0 4 3666 18 LMatrix4d::set_col 0 2 1632 1633 176</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated column of the matrix.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated column of the matrix with the indicated 3-component</span>
 <span class="s0">* vector, ignoring the last row.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline void LMatrix4d::set_col(int col, LVecBase4d const &amp;v);</span>
<span class="s0">inline void LMatrix4d::set_col(int col, LVecBase3d const &amp;v);</span>

<span class="s0">3391 7 get_row 0 4 3666 18 LMatrix4d::get_row 0 2 1634 1635 186</span>
<span class="s0">// these versions inline better</span>

<span class="s0">/**</span>
 <span class="s0">* Retrieves the indicated row of the matrix as a 4-component vector.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Stores the indicated row of the matrix as a 4-component vector.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline LVecBase4d LMatrix4d::get_row(int row) const;</span>
<span class="s0">inline void LMatrix4d::get_row(LVecBase4d &amp;result_vec, int row) const;</span>

<span class="s0">3392 7 get_col 0 4 3666 18 LMatrix4d::get_col 0 1 1636 80</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the indicated column of the matrix as a 4-component vector.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LVecBase4d LMatrix4d::get_col(int col) const;</span>

<span class="s0">3393 8 get_row3 0 4 3666 19 LMatrix4d::get_row3 0 2 1637 1638 205</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the row column of the matrix as a 3-component vector, ignoring</span>
 <span class="s0">* the last column.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Stores the row column of the matrix as a 3-component vector, ignoring the</span>
 <span class="s0">* last column.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">inline LVecBase3d LMatrix4d::get_row3(int row) const;</span>
<span class="s0">inline void LMatrix4d::get_row3(LVecBase3d &amp;result_vec, int row) const;</span>

<span class="s0">3394 8 get_col3 0 4 3666 19 LMatrix4d::get_col3 0 1 1639 106</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the indicated column of the matrix as a 3-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase3d LMatrix4d::get_col3(int col) const;</span>

<span class="s0">3395 11 operator () 0 4 3666 22 LMatrix4d::operator () 0 2 1640 1641 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">inline double &amp;LMatrix4d::operator ()(int row, int col);</span>
<span class="s0">inline double LMatrix4d::operator ()(int row, int col) const;</span>

<span class="s0">3396 6 is_nan 0 4 3666 17 LMatrix4d::is_nan 0 1 1642 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any component of the matrix is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool LMatrix4d::is_nan(void) const;</span>

<span class="s0">3397 11 is_identity 0 4 3666 22 LMatrix4d::is_identity 0 1 1643 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this is (close enough to) the identity matrix, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool LMatrix4d::is_identity(void) const;</span>

<span class="s0">3398 8 get_cell 0 4 3666 19 LMatrix4d::get_cell 0 1 1644 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a particular element of the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline double LMatrix4d::get_cell(int row, int col) const;</span>

<span class="s0">3399 8 set_cell 0 4 3666 19 LMatrix4d::set_cell 0 1 1645 54</span>
<span class="s0">/**</span>
 <span class="s0">* Changes a particular element of the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LMatrix4d::set_cell(int row, int col, double value);</span>

<span class="s0">3400 8 get_data 0 4 3666 19 LMatrix4d::get_data 0 1 1646 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline double const *LMatrix4d::get_data(void) const;</span>

<span class="s0">3401 18 get_num_components 0 4 3666 29 LMatrix4d::get_num_components 0 1 1647 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of elements in the matrix, 16.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int LMatrix4d::get_num_components(void) const;</span>

<span class="s0">3402 5 begin 0 4 3666 16 LMatrix4d::begin 0 2 1648 1649 204</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">inline LMatrix4d::iterator LMatrix4d::begin(void);</span>
<span class="s0">inline LMatrix4d::const_iterator LMatrix4d::begin(void) const;</span>

<span class="s0">3403 3 end 0 4 3666 14 LMatrix4d::end 0 2 1650 1651 204</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">inline LMatrix4d::iterator LMatrix4d::end(void);</span>
<span class="s0">inline LMatrix4d::const_iterator LMatrix4d::end(void) const;</span>

<span class="s0">3404 10 operator &lt; 0 4 3666 21 LMatrix4d::operator &lt; 0 1 1652 0</span>
<span class="s0">64</span>
<span class="s0">inline bool LMatrix4d::operator &lt;(LMatrix4d const &amp;other) const;</span>

<span class="s0">3405 11 operator == 0 4 3666 22 LMatrix4d::operator == 0 1 1653 0</span>
<span class="s0">65</span>
<span class="s0">inline bool LMatrix4d::operator ==(LMatrix4d const &amp;other) const;</span>

<span class="s0">3406 11 operator != 0 4 3666 22 LMatrix4d::operator != 0 1 1654 0</span>
<span class="s0">65</span>
<span class="s0">inline bool LMatrix4d::operator !=(LMatrix4d const &amp;other) const;</span>

<span class="s0">3407 10 compare_to 0 4 3666 21 LMatrix4d::compare_to 0 2 1655 1656 333</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts matrices lexicographically, componentwise.  Returns a number less</span>
 <span class="s0">* than 0 if this matrix sorts before the other one, greater than zero if it</span>
 <span class="s0">* sorts after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/</span>
<span class="s0">138</span>
<span class="s0">inline int LMatrix4d::compare_to(LMatrix4d const &amp;other) const;</span>
<span class="s0">int LMatrix4d::compare_to(LMatrix4d const &amp;other, double threshold) const;</span>

<span class="s0">3408 8 get_hash 0 4 3666 19 LMatrix4d::get_hash 0 2 1657 1658 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">115</span>
<span class="s0">inline std::size_t LMatrix4d::get_hash(void) const;</span>
<span class="s0">inline std::size_t LMatrix4d::get_hash(double threshold) const;</span>

<span class="s0">3409 8 add_hash 0 4 3666 19 LMatrix4d::add_hash 0 2 1659 1660 100</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/</span>
<span class="s0">145</span>
<span class="s0">inline std::size_t LMatrix4d::add_hash(std::size_t hash) const;</span>
<span class="s0">inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const;</span>

<span class="s0">3410 5 xform 0 4 3666 16 LMatrix4d::xform 0 1 1661 91</span>
<span class="s0">/**</span>
 <span class="s0">* 4-component vector or point times matrix.  This is a fully general</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase4d LMatrix4d::xform(LVecBase4d const &amp;v) const;</span>

<span class="s0">3411 11 xform_point 0 4 3666 22 LMatrix4d::xform_point 0 1 1662 162</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &amp;v) const;</span>

<span class="s0">3412 19 xform_point_general 0 4 3666 30 LMatrix4d::xform_point_general 0 1 1663 143</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &amp;v) const;</span>

<span class="s0">3413 9 xform_vec 0 4 3666 20 LMatrix4d::xform_vec 0 1 1664 169</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an orthonormal</span>
 <span class="s0">* transform.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &amp;v) const;</span>

<span class="s0">3414 17 xform_vec_general 0 4 3666 28 LMatrix4d::xform_vec_general 0 1 1665 142</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &amp;v) const;</span>

<span class="s0">3415 14 xform_in_place 0 4 3666 25 LMatrix4d::xform_in_place 0 1 1666 91</span>
<span class="s0">/**</span>
 <span class="s0">* 4-component vector or point times matrix.  This is a fully general</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void LMatrix4d::xform_in_place(LVecBase4d &amp;v) const;</span>

<span class="s0">3416 20 xform_point_in_place 0 4 3666 31 LMatrix4d::xform_point_in_place 0 1 1667 139</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation</span>
 <span class="s0">* component).  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void LMatrix4d::xform_point_in_place(LVecBase3d &amp;v) const;</span>

<span class="s0">3417 28 xform_point_general_in_place 0 4 3666 39 LMatrix4d::xform_point_general_in_place 0 1 1668 120</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation</span>
 <span class="s0">* component), as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &amp;v) const;</span>

<span class="s0">3418 18 xform_vec_in_place 0 4 3666 29 LMatrix4d::xform_vec_in_place 0 1 1669 142</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component).</span>
 <span class="s0">* This assumes the matrix is an orthonormal transform.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void LMatrix4d::xform_vec_in_place(LVecBase3d &amp;v) const;</span>

<span class="s0">3419 26 xform_vec_general_in_place 0 4 3666 37 LMatrix4d::xform_vec_general_in_place 0 1 1670 119</span>
<span class="s0">/**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component),</span>
 <span class="s0">* as a fully general operation.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &amp;v) const;</span>

<span class="s0">3420 8 multiply 0 4 3666 19 LMatrix4d::multiply 0 1 1671 52</span>
<span class="s0">// this = other1 * other2</span>

<span class="s0">// this = other1 * other2</span>
<span class="s0">82</span>
<span class="s0">inline void LMatrix4d::multiply(LMatrix4d const &amp;other1, LMatrix4d const &amp;other2);</span>

<span class="s0">3421 10 operator * 0 4 3666 21 LMatrix4d::operator * 0 2 1672 1673 0</span>
<span class="s0">130</span>
<span class="s0">inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &amp;other) const;</span>
<span class="s0">inline LMatrix4d LMatrix4d::operator *(double scalar) const;</span>

<span class="s0">3422 10 operator / 0 4 3666 21 LMatrix4d::operator / 0 1 1674 0</span>
<span class="s0">60</span>
<span class="s0">inline LMatrix4d LMatrix4d::operator /(double scalar) const;</span>

<span class="s0">3423 11 operator += 0 4 3666 22 LMatrix4d::operator += 0 1 1675 63</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise addition between two matrices.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LMatrix4d &amp;LMatrix4d::operator +=(LMatrix4d const &amp;other);</span>

<span class="s0">3424 11 operator -= 0 4 3666 22 LMatrix4d::operator -= 0 1 1676 66</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a memberwise subtraction between two matrices.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LMatrix4d &amp;LMatrix4d::operator -=(LMatrix4d const &amp;other);</span>

<span class="s0">3425 11 operator *= 0 4 3666 22 LMatrix4d::operator *= 0 2 1677 1678 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">inline LMatrix4d &amp;LMatrix4d::operator *=(LMatrix4d const &amp;other);</span>
<span class="s0">inline LMatrix4d &amp;LMatrix4d::operator *=(double scalar);</span>

<span class="s0">3426 11 operator /= 0 4 3666 22 LMatrix4d::operator /= 0 1 1679 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LMatrix4d &amp;LMatrix4d::operator /=(double scalar);</span>

<span class="s0">3427 18 componentwise_mult 0 4 3666 29 LMatrix4d::componentwise_mult 0 1 1680 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void LMatrix4d::componentwise_mult(LMatrix4d const &amp;other);</span>

<span class="s0">3428 14 transpose_from 0 4 3666 25 LMatrix4d::transpose_from 0 1 1681 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void LMatrix4d::transpose_from(LMatrix4d const &amp;other);</span>

<span class="s0">3429 18 transpose_in_place 0 4 3666 29 LMatrix4d::transpose_in_place 0 1 1682 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void LMatrix4d::transpose_in_place(void);</span>

<span class="s0">3430 11 invert_from 0 4 3666 22 LMatrix4d::invert_from 0 1 1683 461</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the inverse of the other matrix, and stores the result in this</span>
 <span class="s0">* matrix.  This is a fully general operation and makes no assumptions about</span>
 <span class="s0">* the type of transform represented by the matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* The other matrix must be a different object than this matrix.  However, if</span>
 <span class="s0">* you need to invert a matrix in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the matrix was successfully inverted, false if</span>
 <span class="s0">* the was a singularity.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool LMatrix4d::invert_from(LMatrix4d const &amp;other);</span>

<span class="s0">3431 18 invert_affine_from 0 4 3666 29 LMatrix4d::invert_affine_from 0 1 1684 139</span>
<span class="s0">// bugbug: we could optimize this for rotationscaletranslation matrices</span>
<span class="s0">// (transpose upper 3x3 and take negative of translation component)</span>
<span class="s0">66</span>
<span class="s0">inline bool LMatrix4d::invert_affine_from(LMatrix4d const &amp;other);</span>

<span class="s0">3432 15 invert_in_place 0 4 3666 26 LMatrix4d::invert_in_place 0 1 1685 119</span>
<span class="s0">/**</span>
 <span class="s0">* Inverts the current matrix.  Returns true if the inverse is successful,</span>
 <span class="s0">* false if the matrix was singular.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool LMatrix4d::invert_in_place(void);</span>

<span class="s0">3433 10 accumulate 0 4 3666 21 LMatrix4d::accumulate 0 1 1686 48</span>
<span class="s0">/**</span>
 <span class="s0">* Computes `(*this) += other * weight`.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void LMatrix4d::accumulate(LMatrix4d const &amp;other, double weight);</span>

<span class="s0">3434 9 ident_mat 0 4 3666 20 LMatrix4d::ident_mat 0 1 1687 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an identity matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* This function definition must appear first, since some inline functions</span>
 <span class="s0">* below take advantage of it.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">static inline LMatrix4d const &amp;LMatrix4d::ident_mat(void);</span>

<span class="s0">3435 8 ones_mat 0 4 3666 19 LMatrix4d::ones_mat 0 1 1688 46</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an matrix filled with ones.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline LMatrix4d const &amp;LMatrix4d::ones_mat(void);</span>

<span class="s0">3436 9 zeros_mat 0 4 3666 20 LMatrix4d::zeros_mat 0 1 1689 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an matrix filled with zeros.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">static inline LMatrix4d const &amp;LMatrix4d::zeros_mat(void);</span>

<span class="s0">3437 17 set_translate_mat 0 4 3666 28 LMatrix4d::set_translate_mat 0 1 1690 74</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void LMatrix4d::set_translate_mat(LVecBase3d const &amp;trans);</span>

<span class="s0">3438 14 set_rotate_mat 0 4 3666 25 LMatrix4d::set_rotate_mat 0 1 1691 122</span>
<span class="s0">/**</span>
 <span class="s0">* Sets mat to a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3439 23 set_rotate_mat_normaxis 0 4 3666 34 LMatrix4d::set_rotate_mat_normaxis 0 1 1692 166</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* prenormalized.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3440 13 set_scale_mat 0 4 3666 24 LMatrix4d::set_scale_mat 0 1 1693 97</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the</span>
 <span class="s0">* three axes.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void LMatrix4d::set_scale_mat(LVecBase3d const &amp;scale);</span>

<span class="s0">3441 13 set_shear_mat 0 4 3666 24 LMatrix4d::set_shear_mat 0 1 1694 99</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated shear in each of the</span>
 <span class="s0">* three planes.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline void LMatrix4d::set_shear_mat(LVecBase3d const &amp;shear, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3442 19 set_scale_shear_mat 0 4 3666 30 LMatrix4d::set_scale_shear_mat 0 1 1695 78</span>
<span class="s0">/**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>
<span class="s0">129</span>
<span class="s0">inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &amp;scale, LVecBase3d const &amp;shear, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3443 13 translate_mat 0 4 3666 24 LMatrix4d::translate_mat 0 2 1696 1697 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/</span>
<span class="s0">157</span>
<span class="s0">static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &amp;trans);</span>
<span class="s0">static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz);</span>

<span class="s0">3444 10 rotate_mat 0 4 3666 21 LMatrix4d::rotate_mat 0 1 1698 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3445 19 rotate_mat_normaxis 0 4 3666 30 LMatrix4d::rotate_mat_normaxis 0 1 1699 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* prenormalized.</span>
 <span class="s0">*/</span>
<span class="s0">129</span>
<span class="s0">static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &amp;axis, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3446 9 scale_mat 0 4 3666 20 LMatrix4d::scale_mat 0 3 1700 1701 1702 253</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated uniform scale.</span>
 <span class="s0">*/</span>
<span class="s0">209</span>
<span class="s0">static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &amp;scale);</span>
<span class="s0">static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz);</span>
<span class="s0">static inline LMatrix4d LMatrix4d::scale_mat(double scale);</span>

<span class="s0">3447 9 shear_mat 0 4 3666 20 LMatrix4d::shear_mat 0 2 1703 1704 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/</span>
<span class="s0">227</span>
<span class="s0">static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &amp;shear, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3448 15 scale_shear_mat 0 4 3666 26 LMatrix4d::scale_shear_mat 0 2 1705 1706 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/</span>
<span class="s0">297</span>
<span class="s0">static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &amp;scale, LVecBase3d const &amp;shear, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3449 13 y_to_z_up_mat 0 4 3666 24 LMatrix4d::y_to_z_up_mat 0 1 1707 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that transforms from the Y-up coordinate system to the</span>
 <span class="s0">* Z-up coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static inline LMatrix4d const &amp;LMatrix4d::y_to_z_up_mat(void);</span>

<span class="s0">3450 13 z_to_y_up_mat 0 4 3666 24 LMatrix4d::z_to_y_up_mat 0 1 1708 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that transforms from the Y-up coordinate system to the</span>
 <span class="s0">* Z-up coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static inline LMatrix4d const &amp;LMatrix4d::z_to_y_up_mat(void);</span>

<span class="s0">3451 11 convert_mat 0 4 3666 22 LMatrix4d::convert_mat 0 1 1709 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a matrix that transforms from the indicated coordinate system to</span>
 <span class="s0">* the indicated coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">static LMatrix4d const &amp;LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to);</span>

<span class="s0">3452 12 almost_equal 0 4 3666 23 LMatrix4d::almost_equal 0 2 1710 1711 318</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a specified</span>
 <span class="s0">* tolerance.  This is faster than the equivalence operator as this doesn't</span>
 <span class="s0">* have to guarantee that it is transitive.</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">bool LMatrix4d::almost_equal(LMatrix4d const &amp;other, double threshold) const;</span>
<span class="s0">inline bool LMatrix4d::almost_equal(LMatrix4d const &amp;other) const;</span>

<span class="s0">3453 6 output 0 4 3666 17 LMatrix4d::output 0 1 1712 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void LMatrix4d::output(std::ostream &amp;out) const;</span>

<span class="s0">3454 5 write 0 4 3666 16 LMatrix4d::write 0 1 1713 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void LMatrix4d::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">3455 8 __repr__ 0 4 3666 19 LMatrix4d::__repr__ 0 1 1714 0</span>
<span class="s0">51</span>
<span class="s0">inline std::string LMatrix4d::__repr__(void) const;</span>

<span class="s0">3456 13 generate_hash 0 4 3666 24 LMatrix4d::generate_hash 0 2 1715 1716 120</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/</span>
<span class="s0">158</span>
<span class="s0">inline void LMatrix4d::generate_hash(ChecksumHashGenerator &amp;hashgen) const;</span>
<span class="s0">void LMatrix4d::generate_hash(ChecksumHashGenerator &amp;hashgen, double scale) const;</span>

<span class="s0">3457 20 write_datagram_fixed 0 4 3666 31 LMatrix4d::write_datagram_fixed 0 1 1717 332</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the matrix, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">void LMatrix4d::write_datagram_fixed(Datagram &amp;destination) const;</span>

<span class="s0">3458 19 read_datagram_fixed 0 4 3666 30 LMatrix4d::read_datagram_fixed 0 1 1718 114</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void LMatrix4d::read_datagram_fixed(DatagramIterator &amp;scan);</span>

<span class="s0">3459 14 write_datagram 0 4 3666 25 LMatrix4d::write_datagram 0 1 1719 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the matrix using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void LMatrix4d::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">3460 13 read_datagram 0 4 3666 24 LMatrix4d::read_datagram 0 1 1720 67</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_stdfloat().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void LMatrix4d::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">3461 14 get_class_type 0 4 3666 25 LMatrix4d::get_class_type 0 1 1721 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LMatrix4d::get_class_type(void);</span>

<span class="s0">3462 10 ~LMatrix4d 0 516 3666 21 LMatrix4d::~LMatrix4d 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LMatrix4d::~LMatrix4d(void);</span>

<span class="s0">3463 18 UnalignedLMatrix4d 0 260 3670 38 UnalignedLMatrix4d::UnalignedLMatrix4d 0 4 1731 1732 1733 1734 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">440</span>
<span class="s0">inline UnalignedLMatrix4d::UnalignedLMatrix4d(void);</span>
<span class="s0">inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &amp;copy);</span>
<span class="s0">inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &amp;copy);</span>
<span class="s0">inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);</span>

<span class="s0">3464 10 operator = 0 4 3670 30 UnalignedLMatrix4d::operator = 0 2 1735 1736 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">142</span>
<span class="s0">inline void UnalignedLMatrix4d::operator =(LMatrix4d const &amp;copy);</span>
<span class="s0">inline void UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &amp;copy);</span>

<span class="s0">3465 3 set 0 4 3670 23 UnalignedLMatrix4d::set 0 1 1737 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">228</span>
<span class="s0">inline void UnalignedLMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);</span>

<span class="s0">3466 11 operator () 0 4 3670 31 UnalignedLMatrix4d::operator () 0 2 1738 1739 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">136</span>
<span class="s0">inline double &amp;UnalignedLMatrix4d::operator ()(int row, int col);</span>
<span class="s0">inline double UnalignedLMatrix4d::operator ()(int row, int col) const;</span>

<span class="s0">3467 8 get_data 0 4 3670 28 UnalignedLMatrix4d::get_data 0 1 1740 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline double const *UnalignedLMatrix4d::get_data(void) const;</span>

<span class="s0">3468 18 get_num_components 0 4 3670 38 UnalignedLMatrix4d::get_num_components 0 1 1741 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of elements in the matrix, sixteen.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int UnalignedLMatrix4d::get_num_components(void) const;</span>

<span class="s0">3469 11 operator == 0 4 3670 31 UnalignedLMatrix4d::operator == 0 1 1742 0</span>
<span class="s0">83</span>
<span class="s0">inline bool UnalignedLMatrix4d::operator ==(UnalignedLMatrix4d const &amp;other) const;</span>

<span class="s0">3470 11 operator != 0 4 3670 31 UnalignedLMatrix4d::operator != 0 1 1743 0</span>
<span class="s0">83</span>
<span class="s0">inline bool UnalignedLMatrix4d::operator !=(UnalignedLMatrix4d const &amp;other) const;</span>

<span class="s0">3471 14 get_class_type 0 4 3670 34 UnalignedLMatrix4d::get_class_type 0 1 1744 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle UnalignedLMatrix4d::get_class_type(void);</span>

<span class="s0">3472 19 ~UnalignedLMatrix4d 0 516 3670 39 UnalignedLMatrix4d::~UnalignedLMatrix4d 0 0 0</span>
<span class="s0">46</span>
<span class="s0">UnalignedLMatrix4d::~UnalignedLMatrix4d(void);</span>

<span class="s0">3473 10 operator * 0 1 0 10 operator * 0 24 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 0</span>
<span class="s0">1659</span>
<span class="s0">inline LVecBase3f operator *(LVecBase3f const &amp;v, LMatrix3f const &amp;m);</span>
<span class="s0">inline LVector3f operator *(LVector3f const &amp;v, LMatrix3f const &amp;m);</span>
<span class="s0">inline LPoint3f operator *(LPoint3f const &amp;v, LMatrix3f const &amp;m);</span>
<span class="s0">inline LVector2f operator *(LVector2f const &amp;v, LMatrix3f const &amp;m);</span>
<span class="s0">inline LPoint2f operator *(LPoint2f const &amp;v, LMatrix3f const &amp;m);</span>
<span class="s0">inline LVecBase4f operator *(LVecBase4f const &amp;v, LMatrix4f const &amp;m);</span>
<span class="s0">inline LPoint4f operator *(LPoint4f const &amp;v, LMatrix4f const &amp;m);</span>
<span class="s0">inline LVector4f operator *(LVector4f const &amp;v, LMatrix4f const &amp;m);</span>
<span class="s0">inline LVector3f operator *(LVector3f const &amp;v, LMatrix4f const &amp;m);</span>
<span class="s0">inline LPoint3f operator *(LPoint3f const &amp;v, LMatrix4f const &amp;m);</span>
<span class="s0">inline LVecBase3d operator *(LVecBase3d const &amp;v, LMatrix3d const &amp;m);</span>
<span class="s0">inline LVector3d operator *(LVector3d const &amp;v, LMatrix3d const &amp;m);</span>
<span class="s0">inline LPoint3d operator *(LPoint3d const &amp;v, LMatrix3d const &amp;m);</span>
<span class="s0">inline LVector2d operator *(LVector2d const &amp;v, LMatrix3d const &amp;m);</span>
<span class="s0">inline LPoint2d operator *(LPoint2d const &amp;v, LMatrix3d const &amp;m);</span>
<span class="s0">inline LVecBase4d operator *(LVecBase4d const &amp;v, LMatrix4d const &amp;m);</span>
<span class="s0">inline LPoint4d operator *(LPoint4d const &amp;v, LMatrix4d const &amp;m);</span>
<span class="s0">inline LVector4d operator *(LVector4d const &amp;v, LMatrix4d const &amp;m);</span>
<span class="s0">inline LVector3d operator *(LVector3d const &amp;v, LMatrix4d const &amp;m);</span>
<span class="s0">inline LPoint3d operator *(LPoint3d const &amp;v, LMatrix4d const &amp;m);</span>
<span class="s0">inline LMatrix3f operator *(LMatrix3f const &amp;m, LQuaternionf const &amp;q);</span>
<span class="s0">inline LMatrix4f operator *(LMatrix4f const &amp;m, LQuaternionf const &amp;q);</span>
<span class="s0">inline LMatrix3d operator *(LMatrix3d const &amp;m, LQuaterniond const &amp;q);</span>
<span class="s0">inline LMatrix4d operator *(LMatrix4d const &amp;m, LQuaterniond const &amp;q);</span>

<span class="s0">3474 11 operator *= 0 1 0 11 operator *= 0 16 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 0</span>
<span class="s0">941</span>
<span class="s0">inline void operator *=(LVecBase3f &amp;v, LMatrix3f const &amp;m);</span>
<span class="s0">inline void operator *=(LVector3f &amp;v, LMatrix3f const &amp;m);</span>
<span class="s0">inline void operator *=(LPoint3f &amp;v, LMatrix3f const &amp;m);</span>
<span class="s0">inline void operator *=(LVector2f &amp;v, LMatrix3f const &amp;m);</span>
<span class="s0">inline void operator *=(LPoint2f &amp;v, LMatrix3f const &amp;m);</span>
<span class="s0">inline void operator *=(LVecBase4f &amp;v, LMatrix4f const &amp;m);</span>
<span class="s0">inline void operator *=(LVector3f &amp;v, LMatrix4f const &amp;m);</span>
<span class="s0">inline void operator *=(LPoint3f &amp;v, LMatrix4f const &amp;m);</span>
<span class="s0">inline void operator *=(LVecBase3d &amp;v, LMatrix3d const &amp;m);</span>
<span class="s0">inline void operator *=(LVector3d &amp;v, LMatrix3d const &amp;m);</span>
<span class="s0">inline void operator *=(LPoint3d &amp;v, LMatrix3d const &amp;m);</span>
<span class="s0">inline void operator *=(LVector2d &amp;v, LMatrix3d const &amp;m);</span>
<span class="s0">inline void operator *=(LPoint2d &amp;v, LMatrix3d const &amp;m);</span>
<span class="s0">inline void operator *=(LVecBase4d &amp;v, LMatrix4d const &amp;m);</span>
<span class="s0">inline void operator *=(LVector3d &amp;v, LMatrix4d const &amp;m);</span>
<span class="s0">inline void operator *=(LPoint3d &amp;v, LMatrix4d const &amp;m);</span>

<span class="s0">3475 22 generic_write_datagram 0 1 0 22 generic_write_datagram 0 4 1979 1980 1981 1982 0</span>
<span class="s0">303</span>
<span class="s0">inline void generic_write_datagram(Datagram &amp;dest, LMatrix3f const &amp;value);</span>
<span class="s0">inline void generic_write_datagram(Datagram &amp;dest, LMatrix4f const &amp;value);</span>
<span class="s0">inline void generic_write_datagram(Datagram &amp;dest, LMatrix3d const &amp;value);</span>
<span class="s0">inline void generic_write_datagram(Datagram &amp;dest, LMatrix4d const &amp;value);</span>

<span class="s0">3476 21 generic_read_datagram 0 1 0 21 generic_read_datagram 0 4 1983 1984 1985 1986 0</span>
<span class="s0">319</span>
<span class="s0">inline void generic_read_datagram(LMatrix3f &amp;result, DatagramIterator &amp;source);</span>
<span class="s0">inline void generic_read_datagram(LMatrix4f &amp;result, DatagramIterator &amp;source);</span>
<span class="s0">inline void generic_read_datagram(LMatrix3d &amp;result, DatagramIterator &amp;source);</span>
<span class="s0">inline void generic_read_datagram(LMatrix4d &amp;result, DatagramIterator &amp;source);</span>

<span class="s0">3477 14 compose_matrix 0 1 0 14 compose_matrix 0 10 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 0</span>
<span class="s0">1484</span>
<span class="s0">void compose_matrix(LMatrix3f &amp;mat, LVecBase3f const &amp;scale, LVecBase3f const &amp;shear, LVecBase3f const &amp;hpr, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline void compose_matrix(LMatrix4f &amp;mat, LVecBase3f const &amp;scale, LVecBase3f const &amp;shear, LVecBase3f const &amp;hpr, LVecBase3f const &amp;translate, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline void compose_matrix(LMatrix4f &amp;mat, float const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline void compose_matrix(LMatrix3f &amp;mat, LVecBase3f const &amp;scale, LVecBase3f const &amp;hpr, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline void compose_matrix(LMatrix4f &amp;mat, LVecBase3f const &amp;scale, LVecBase3f const &amp;hpr, LVecBase3f const &amp;translate, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">void compose_matrix(LMatrix3d &amp;mat, LVecBase3d const &amp;scale, LVecBase3d const &amp;shear, LVecBase3d const &amp;hpr, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline void compose_matrix(LMatrix4d &amp;mat, LVecBase3d const &amp;scale, LVecBase3d const &amp;shear, LVecBase3d const &amp;hpr, LVecBase3d const &amp;translate, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline void compose_matrix(LMatrix4d &amp;mat, double const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline void compose_matrix(LMatrix3d &amp;mat, LVecBase3d const &amp;scale, LVecBase3d const &amp;hpr, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline void compose_matrix(LMatrix4d &amp;mat, LVecBase3d const &amp;scale, LVecBase3d const &amp;hpr, LVecBase3d const &amp;translate, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3478 16 decompose_matrix 0 1 0 16 decompose_matrix 0 10 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 0</span>
<span class="s0">1408</span>
<span class="s0">bool decompose_matrix(LMatrix3f const &amp;mat, LVecBase3f &amp;scale, LVecBase3f &amp;shear, LVecBase3f &amp;hpr, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline bool decompose_matrix(LMatrix4f const &amp;mat, LVecBase3f &amp;scale, LVecBase3f &amp;shear, LVecBase3f &amp;hpr, LVecBase3f &amp;translate, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline bool decompose_matrix(LMatrix4f const &amp;mat, float components[::num_matrix_components], CoordinateSystem CS = ::CS_default);</span>
<span class="s0">inline bool decompose_matrix(LMatrix3f const &amp;mat, LVecBase3f &amp;scale, LVecBase3f &amp;hpr, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline bool decompose_matrix(LMatrix4f const &amp;mat, LVecBase3f &amp;scale, LVecBase3f &amp;hpr, LVecBase3f &amp;translate, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">bool decompose_matrix(LMatrix3d const &amp;mat, LVecBase3d &amp;scale, LVecBase3d &amp;shear, LVecBase3d &amp;hpr, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline bool decompose_matrix(LMatrix4d const &amp;mat, LVecBase3d &amp;scale, LVecBase3d &amp;shear, LVecBase3d &amp;hpr, LVecBase3d &amp;translate, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline bool decompose_matrix(LMatrix4d const &amp;mat, double components[::num_matrix_components], CoordinateSystem CS = ::CS_default);</span>
<span class="s0">inline bool decompose_matrix(LMatrix3d const &amp;mat, LVecBase3d &amp;scale, LVecBase3d &amp;hpr, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">inline bool decompose_matrix(LMatrix4d const &amp;mat, LVecBase3d &amp;scale, LVecBase3d &amp;hpr, LVecBase3d &amp;translate, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3479 24 decompose_matrix_old_hpr 0 1 0 24 decompose_matrix_old_hpr 0 2 2007 2008 0</span>
<span class="s0">287</span>
<span class="s0">bool decompose_matrix_old_hpr(LMatrix3f const &amp;mat, LVecBase3f &amp;scale, LVecBase3f &amp;shear, LVecBase3f &amp;hpr, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">bool decompose_matrix_old_hpr(LMatrix3d const &amp;mat, LVecBase3d &amp;scale, LVecBase3d &amp;shear, LVecBase3d &amp;hpr, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3480 14 old_to_new_hpr 0 1 0 14 old_to_new_hpr 0 2 2009 2010 0</span>
<span class="s0">107</span>
<span class="s0">LVecBase3f old_to_new_hpr(LVecBase3f const &amp;old_hpr);</span>
<span class="s0">LVecBase3d old_to_new_hpr(LVecBase3d const &amp;old_hpr);</span>

<span class="s0">3481 12 LQuaternionf 0 260 3672 26 LQuaternionf::LQuaternionf 0 5 1745 1746 1747 1748 1749 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">305</span>
<span class="s0">inline LQuaternionf::LQuaternionf(void);</span>
<span class="s0">inline LQuaternionf::LQuaternionf(LVecBase4f const &amp;copy);</span>
<span class="s0">inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &amp;copy);</span>
<span class="s0">inline LQuaternionf::LQuaternionf(float r, float i, float j, float k);</span>
<span class="s0">inline LQuaternionf::LQuaternionf(LQuaternionf const &amp;) = default;</span>

<span class="s0">3482 14 pure_imaginary 0 4 3672 28 LQuaternionf::pure_imaginary 0 1 1750 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &amp;v);</span>

<span class="s0">3483 9 conjugate 0 4 3672 23 LQuaternionf::conjugate 0 1 1751 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complex conjugate of this quat.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LQuaternionf LQuaternionf::conjugate(void) const;</span>

<span class="s0">3484 5 xform 0 4 3672 19 LQuaternionf::xform 0 2 1752 1753 122</span>
<span class="s0">/**</span>
 <span class="s0">* Transforms a 3-d vector by the indicated rotation</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Transforms a 4-d vector by the indicated rotation</span>
 <span class="s0">*/</span>
<span class="s0">131</span>
<span class="s0">inline LVecBase3f LQuaternionf::xform(LVecBase3f const &amp;v) const;</span>
<span class="s0">inline LVecBase4f LQuaternionf::xform(LVecBase4f const &amp;v) const;</span>

<span class="s0">3485 8 multiply 0 4 3672 22 LQuaternionf::multiply 0 1 1754 45</span>
<span class="s0">/**</span>
 <span class="s0">* actual multiply call (non virtual)</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &amp;rhs) const;</span>

<span class="s0">3486 10 operator - 0 68 3672 24 LQuaternionf::operator - 0 1 1755 0</span>
<span class="s0">57</span>
<span class="s0">inline LQuaternionf LQuaternionf::operator -(void) const;</span>

<span class="s0">3487 10 operator + 0 4 3672 24 LQuaternionf::operator + 0 1 1756 0</span>
<span class="s0">78</span>
<span class="s0">inline LQuaternionf LQuaternionf::operator +(LQuaternionf const &amp;other) const;</span>

<span class="s0">3488 10 operator - 0 4 3672 24 LQuaternionf::operator - 0 1 1757 0</span>
<span class="s0">78</span>
<span class="s0">inline LQuaternionf LQuaternionf::operator -(LQuaternionf const &amp;other) const;</span>

<span class="s0">3489 9 angle_rad 0 4 3672 23 LQuaternionf::angle_rad 0 1 1758 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the angle between the orientation represented by this quaternion</span>
 <span class="s0">* and the other one, expressed in radians.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline float LQuaternionf::angle_rad(LQuaternionf const &amp;other) const;</span>

<span class="s0">3490 9 angle_deg 0 4 3672 23 LQuaternionf::angle_deg 0 1 1759 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the angle between the orientation represented by this quaternion</span>
 <span class="s0">* and the other one, expressed in degrees.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline float LQuaternionf::angle_deg(LQuaternionf const &amp;other) const;</span>

<span class="s0">3491 10 operator * 0 4 3672 24 LQuaternionf::operator * 0 4 1760 1761 1762 1763 0</span>
<span class="s0">263</span>
<span class="s0">inline LQuaternionf LQuaternionf::operator *(float scalar) const;</span>
<span class="s0">inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &amp;) const;</span>
<span class="s0">inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &amp;);</span>
<span class="s0">inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &amp;);</span>

<span class="s0">3492 10 operator / 0 4 3672 24 LQuaternionf::operator / 0 1 1764 0</span>
<span class="s0">65</span>
<span class="s0">inline LQuaternionf LQuaternionf::operator /(float scalar) const;</span>

<span class="s0">3493 11 operator *= 0 4 3672 25 LQuaternionf::operator *= 0 1 1765 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline LQuaternionf &amp;LQuaternionf::operator *=(LQuaternionf const &amp;);</span>

<span class="s0">3494 7 __pow__ 0 4 3672 21 LQuaternionf::__pow__ 0 1 1766 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new quaternion that represents this quaternion raised to the</span>
 <span class="s0">* given power.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">LQuaternionf LQuaternionf::__pow__(float ) const;</span>

<span class="s0">3495 12 almost_equal 0 4 3672 26 LQuaternionf::almost_equal 0 2 1767 1768 218</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two quaternions are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two quaternions are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>
<span class="s0">162</span>
<span class="s0">inline bool LQuaternionf::almost_equal(LQuaternionf const &amp;other) const;</span>
<span class="s0">inline bool LQuaternionf::almost_equal(LQuaternionf const &amp;other, float threshold) const;</span>

<span class="s0">3496 17 is_same_direction 0 4 3672 31 LQuaternionf::is_same_direction 0 1 1769 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two quaternions represent the same rotation within a</span>
 <span class="s0">* default tolerance based on the numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline bool LQuaternionf::is_same_direction(LQuaternionf const &amp;other) const;</span>

<span class="s0">3497 21 almost_same_direction 0 4 3672 35 LQuaternionf::almost_same_direction 0 1 1770 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two quaternions represent the same rotation within a</span>
 <span class="s0">* specified tolerance.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline bool LQuaternionf::almost_same_direction(LQuaternionf const &amp;other, float threshold) const;</span>

<span class="s0">3498 6 output 0 4 3672 20 LQuaternionf::output 0 1 1771 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void LQuaternionf::output(std::ostream &amp;) const;</span>

<span class="s0">3499 17 extract_to_matrix 0 4 3672 31 LQuaternionf::extract_to_matrix 0 2 1772 1773 88</span>
<span class="s0">/**</span>
 <span class="s0">* Based on the quat lib from VRPN.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Based on the quat lib from VRPN.</span>
 <span class="s0">*/</span>
<span class="s0">115</span>
<span class="s0">void LQuaternionf::extract_to_matrix(LMatrix3f &amp;m) const;</span>
<span class="s0">void LQuaternionf::extract_to_matrix(LMatrix4f &amp;m) const;</span>

<span class="s0">3500 15 set_from_matrix 0 4 3672 29 LQuaternionf::set_from_matrix 0 2 1774 1775 238</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the quaternion according to the rotation represented by the matrix.</span>
 <span class="s0">* Originally we tried an algorithm presented by Do-While Jones, but that</span>
 <span class="s0">* turned out to be broken.  This is based on the quat lib from UNC.</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">void LQuaternionf::set_from_matrix(LMatrix3f const &amp;m);</span>
<span class="s0">inline void LQuaternionf::set_from_matrix(LMatrix4f const &amp;m);</span>

<span class="s0">3501 7 set_hpr 0 4 3672 21 LQuaternionf::set_hpr 0 1 1776 132</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the quaternion as the unit quaternion that is equivalent to these</span>
 <span class="s0">* Euler angles.  (from Real-time Rendering, p.49)</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">void LQuaternionf::set_hpr(LVecBase3f const &amp;hpr, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3502 7 get_hpr 0 4 3672 21 LQuaternionf::get_hpr 0 1 1777 73</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts the equivalent Euler angles from the unit quaternion.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const;</span>

<span class="s0">3503 8 get_axis 0 4 3672 22 LQuaternionf::get_axis 0 1 1778 180</span>
<span class="s0">/**</span>
 <span class="s0">* This, along with get_angle(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the axis; it</span>
 <span class="s0">* is not normalized.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LVector3f LQuaternionf::get_axis(void) const;</span>

<span class="s0">3504 19 get_axis_normalized 0 4 3672 33 LQuaternionf::get_axis_normalized 0 1 1779 169</span>
<span class="s0">/**</span>
 <span class="s0">* This, along with get_angle(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the</span>
 <span class="s0">* normalized axis.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LVector3f LQuaternionf::get_axis_normalized(void) const;</span>

<span class="s0">3505 13 get_angle_rad 0 4 3672 27 LQuaternionf::get_angle_rad 0 1 1780 343</span>
<span class="s0">/**</span>
 <span class="s0">* This, along with get_axis(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the angle, in</span>
 <span class="s0">* radians counterclockwise about the axis.</span>
 <span class="s0">*</span>
 <span class="s0">* It is necessary to ensure the quaternion has been normalized (for instance,</span>
 <span class="s0">* with a call to normalize()) before calling this method.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline float LQuaternionf::get_angle_rad(void) const;</span>

<span class="s0">3506 9 get_angle 0 4 3672 23 LQuaternionf::get_angle 0 1 1781 343</span>
<span class="s0">/**</span>
 <span class="s0">* This, along with get_axis(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the angle, in</span>
 <span class="s0">* degrees counterclockwise about the axis.</span>
 <span class="s0">*</span>
 <span class="s0">* It is necessary to ensure the quaternion has been normalized (for instance,</span>
 <span class="s0">* with a call to normalize()) before calling this method.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline float LQuaternionf::get_angle(void) const;</span>

<span class="s0">3507 23 set_from_axis_angle_rad 0 4 3672 37 LQuaternionf::set_from_axis_angle_rad 0 1 1782 86</span>
<span class="s0">/**</span>
 <span class="s0">* angle_rad is the angle about the axis in radians.  axis must be normalized.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &amp;axis);</span>

<span class="s0">3508 19 set_from_axis_angle 0 4 3672 33 LQuaternionf::set_from_axis_angle 0 1 1783 86</span>
<span class="s0">/**</span>
 <span class="s0">* angle_deg is the angle about the axis in degrees.  axis must be normalized.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &amp;axis);</span>

<span class="s0">3509 6 get_up 0 4 3672 20 LQuaternionf::get_up 0 1 1784 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as an up</span>
 <span class="s0">* vector.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const;</span>

<span class="s0">3510 9 get_right 0 4 3672 23 LQuaternionf::get_right 0 1 1785 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as a</span>
 <span class="s0">* right vector.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const;</span>

<span class="s0">3511 11 get_forward 0 4 3672 25 LQuaternionf::get_forward 0 1 1786 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as a</span>
 <span class="s0">* forward vector.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const;</span>

<span class="s0">3512 5 get_r 0 4 3672 19 LQuaternionf::get_r 0 1 1787 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline float LQuaternionf::get_r(void) const;</span>

<span class="s0">3513 5 get_i 0 4 3672 19 LQuaternionf::get_i 0 1 1788 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline float LQuaternionf::get_i(void) const;</span>

<span class="s0">3514 5 get_j 0 4 3672 19 LQuaternionf::get_j 0 1 1789 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline float LQuaternionf::get_j(void) const;</span>

<span class="s0">3515 5 get_k 0 4 3672 19 LQuaternionf::get_k 0 1 1790 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline float LQuaternionf::get_k(void) const;</span>

<span class="s0">3516 5 set_r 0 4 3672 19 LQuaternionf::set_r 0 1 1791 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LQuaternionf::set_r(float r);</span>

<span class="s0">3517 5 set_i 0 4 3672 19 LQuaternionf::set_i 0 1 1792 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LQuaternionf::set_i(float i);</span>

<span class="s0">3518 5 set_j 0 4 3672 19 LQuaternionf::set_j 0 1 1793 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LQuaternionf::set_j(float j);</span>

<span class="s0">3519 5 set_k 0 4 3672 19 LQuaternionf::set_k 0 1 1794 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void LQuaternionf::set_k(float k);</span>

<span class="s0">3520 9 normalize 0 4 3672 23 LQuaternionf::normalize 0 1 1795 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool LQuaternionf::normalize(void);</span>

<span class="s0">3521 14 conjugate_from 0 4 3672 28 LQuaternionf::conjugate_from 0 1 1796 466</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the conjugate of the other quat, and stores the result in this</span>
 <span class="s0">* quat.  This is a fully general operation and makes no assumptions about the</span>
 <span class="s0">* type of transform represented by the quat.</span>
 <span class="s0">*</span>
 <span class="s0">* The other quat must be a different object than this quat.  However, if you</span>
 <span class="s0">* need to get a conjugate of a quat in place, see conjugate_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the quat was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline bool LQuaternionf::conjugate_from(LQuaternionf const &amp;other);</span>

<span class="s0">3522 18 conjugate_in_place 0 4 3672 32 LQuaternionf::conjugate_in_place 0 1 1797 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets this to be the conjugate of the current quat.  Returns true if the</span>
 <span class="s0">* successful, false if the quat was singular.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool LQuaternionf::conjugate_in_place(void);</span>

<span class="s0">3523 11 invert_from 0 4 3672 25 LQuaternionf::invert_from 0 1 1798 448</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the inverse of the other quat, and stores the result in this quat.</span>
 <span class="s0">* This is a fully general operation and makes no assumptions about the type</span>
 <span class="s0">* of transform represented by the quat.</span>
 <span class="s0">*</span>
 <span class="s0">* The other quat must be a different object than this quat.  However, if you</span>
 <span class="s0">* need to invert a quat in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the quat was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline bool LQuaternionf::invert_from(LQuaternionf const &amp;other);</span>

<span class="s0">3524 15 invert_in_place 0 4 3672 29 LQuaternionf::invert_in_place 0 1 1799 115</span>
<span class="s0">/**</span>
 <span class="s0">* Inverts the current quat.  Returns true if the inverse is successful, false</span>
 <span class="s0">* if the quat was singular.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool LQuaternionf::invert_in_place(void);</span>

<span class="s0">3525 11 is_identity 0 4 3672 25 LQuaternionf::is_identity 0 1 1800 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this quaternion represents the identity transformation: no</span>
 <span class="s0">* rotation.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool LQuaternionf::is_identity(void) const;</span>

<span class="s0">3526 18 is_almost_identity 0 4 3672 32 LQuaternionf::is_almost_identity 0 1 1801 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this quaternion represents the identity transformation</span>
 <span class="s0">* within a given tolerance.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline bool LQuaternionf::is_almost_identity(float tolerance) const;</span>

<span class="s0">3527 10 ident_quat 0 4 3672 24 LQuaternionf::ident_quat 0 1 1802 42</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an identity quaternion.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">static inline LQuaternionf const &amp;LQuaternionf::ident_quat(void);</span>

<span class="s0">3528 14 get_class_type 0 4 3672 28 LQuaternionf::get_class_type 0 1 1803 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle LQuaternionf::get_class_type(void);</span>

<span class="s0">3529 13 ~LQuaternionf 0 516 3672 27 LQuaternionf::~LQuaternionf 0 0 0</span>
<span class="s0">34</span>
<span class="s0">LQuaternionf::~LQuaternionf(void);</span>

<span class="s0">3530 12 LQuaterniond 0 260 3673 26 LQuaterniond::LQuaterniond 0 5 1804 1805 1806 1807 1808 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">310</span>
<span class="s0">inline LQuaterniond::LQuaterniond(void);</span>
<span class="s0">inline LQuaterniond::LQuaterniond(LVecBase4d const &amp;copy);</span>
<span class="s0">inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &amp;copy);</span>
<span class="s0">inline LQuaterniond::LQuaterniond(double r, double i, double j, double k);</span>
<span class="s0">inline LQuaterniond::LQuaterniond(LQuaterniond const &amp;) = default;</span>

<span class="s0">3531 14 pure_imaginary 0 4 3673 28 LQuaterniond::pure_imaginary 0 1 1809 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &amp;v);</span>

<span class="s0">3532 9 conjugate 0 4 3673 23 LQuaterniond::conjugate 0 1 1810 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complex conjugate of this quat.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LQuaterniond LQuaterniond::conjugate(void) const;</span>

<span class="s0">3533 5 xform 0 4 3673 19 LQuaterniond::xform 0 2 1811 1812 122</span>
<span class="s0">/**</span>
 <span class="s0">* Transforms a 3-d vector by the indicated rotation</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Transforms a 4-d vector by the indicated rotation</span>
 <span class="s0">*/</span>
<span class="s0">131</span>
<span class="s0">inline LVecBase3d LQuaterniond::xform(LVecBase3d const &amp;v) const;</span>
<span class="s0">inline LVecBase4d LQuaterniond::xform(LVecBase4d const &amp;v) const;</span>

<span class="s0">3534 8 multiply 0 4 3673 22 LQuaterniond::multiply 0 1 1813 45</span>
<span class="s0">/**</span>
 <span class="s0">* actual multiply call (non virtual)</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &amp;rhs) const;</span>

<span class="s0">3535 10 operator - 0 68 3673 24 LQuaterniond::operator - 0 1 1814 0</span>
<span class="s0">57</span>
<span class="s0">inline LQuaterniond LQuaterniond::operator -(void) const;</span>

<span class="s0">3536 10 operator + 0 4 3673 24 LQuaterniond::operator + 0 1 1815 0</span>
<span class="s0">78</span>
<span class="s0">inline LQuaterniond LQuaterniond::operator +(LQuaterniond const &amp;other) const;</span>

<span class="s0">3537 10 operator - 0 4 3673 24 LQuaterniond::operator - 0 1 1816 0</span>
<span class="s0">78</span>
<span class="s0">inline LQuaterniond LQuaterniond::operator -(LQuaterniond const &amp;other) const;</span>

<span class="s0">3538 9 angle_rad 0 4 3673 23 LQuaterniond::angle_rad 0 1 1817 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the angle between the orientation represented by this quaternion</span>
 <span class="s0">* and the other one, expressed in radians.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline double LQuaterniond::angle_rad(LQuaterniond const &amp;other) const;</span>

<span class="s0">3539 9 angle_deg 0 4 3673 23 LQuaterniond::angle_deg 0 1 1818 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the angle between the orientation represented by this quaternion</span>
 <span class="s0">* and the other one, expressed in degrees.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline double LQuaterniond::angle_deg(LQuaterniond const &amp;other) const;</span>

<span class="s0">3540 10 operator * 0 4 3673 24 LQuaterniond::operator * 0 4 1819 1820 1821 1822 0</span>
<span class="s0">264</span>
<span class="s0">inline LQuaterniond LQuaterniond::operator *(double scalar) const;</span>
<span class="s0">inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &amp;) const;</span>
<span class="s0">inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &amp;);</span>
<span class="s0">inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &amp;);</span>

<span class="s0">3541 10 operator / 0 4 3673 24 LQuaterniond::operator / 0 1 1823 0</span>
<span class="s0">66</span>
<span class="s0">inline LQuaterniond LQuaterniond::operator /(double scalar) const;</span>

<span class="s0">3542 11 operator *= 0 4 3673 25 LQuaterniond::operator *= 0 1 1824 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline LQuaterniond &amp;LQuaterniond::operator *=(LQuaterniond const &amp;);</span>

<span class="s0">3543 7 __pow__ 0 4 3673 21 LQuaterniond::__pow__ 0 1 1825 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new quaternion that represents this quaternion raised to the</span>
 <span class="s0">* given power.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">LQuaterniond LQuaterniond::__pow__(double ) const;</span>

<span class="s0">3544 12 almost_equal 0 4 3673 26 LQuaterniond::almost_equal 0 2 1826 1827 218</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two quaternions are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if two quaternions are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/</span>
<span class="s0">163</span>
<span class="s0">inline bool LQuaterniond::almost_equal(LQuaterniond const &amp;other) const;</span>
<span class="s0">inline bool LQuaterniond::almost_equal(LQuaterniond const &amp;other, double threshold) const;</span>

<span class="s0">3545 17 is_same_direction 0 4 3673 31 LQuaterniond::is_same_direction 0 1 1828 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two quaternions represent the same rotation within a</span>
 <span class="s0">* default tolerance based on the numeric type.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline bool LQuaterniond::is_same_direction(LQuaterniond const &amp;other) const;</span>

<span class="s0">3546 21 almost_same_direction 0 4 3673 35 LQuaterniond::almost_same_direction 0 1 1829 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two quaternions represent the same rotation within a</span>
 <span class="s0">* specified tolerance.</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">inline bool LQuaterniond::almost_same_direction(LQuaterniond const &amp;other, double threshold) const;</span>

<span class="s0">3547 6 output 0 4 3673 20 LQuaterniond::output 0 1 1830 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void LQuaterniond::output(std::ostream &amp;) const;</span>

<span class="s0">3548 17 extract_to_matrix 0 4 3673 31 LQuaterniond::extract_to_matrix 0 2 1831 1832 88</span>
<span class="s0">/**</span>
 <span class="s0">* Based on the quat lib from VRPN.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Based on the quat lib from VRPN.</span>
 <span class="s0">*/</span>
<span class="s0">115</span>
<span class="s0">void LQuaterniond::extract_to_matrix(LMatrix3d &amp;m) const;</span>
<span class="s0">void LQuaterniond::extract_to_matrix(LMatrix4d &amp;m) const;</span>

<span class="s0">3549 15 set_from_matrix 0 4 3673 29 LQuaterniond::set_from_matrix 0 2 1833 1834 238</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the quaternion according to the rotation represented by the matrix.</span>
 <span class="s0">* Originally we tried an algorithm presented by Do-While Jones, but that</span>
 <span class="s0">* turned out to be broken.  This is based on the quat lib from UNC.</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">void LQuaterniond::set_from_matrix(LMatrix3d const &amp;m);</span>
<span class="s0">inline void LQuaterniond::set_from_matrix(LMatrix4d const &amp;m);</span>

<span class="s0">3550 7 set_hpr 0 4 3673 21 LQuaterniond::set_hpr 0 1 1835 132</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the quaternion as the unit quaternion that is equivalent to these</span>
 <span class="s0">* Euler angles.  (from Real-time Rendering, p.49)</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">void LQuaterniond::set_hpr(LVecBase3d const &amp;hpr, CoordinateSystem cs = ::CS_default);</span>

<span class="s0">3551 7 get_hpr 0 4 3673 21 LQuaterniond::get_hpr 0 1 1836 73</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts the equivalent Euler angles from the unit quaternion.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const;</span>

<span class="s0">3552 8 get_axis 0 4 3673 22 LQuaterniond::get_axis 0 1 1837 180</span>
<span class="s0">/**</span>
 <span class="s0">* This, along with get_angle(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the axis; it</span>
 <span class="s0">* is not normalized.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LVector3d LQuaterniond::get_axis(void) const;</span>

<span class="s0">3553 19 get_axis_normalized 0 4 3673 33 LQuaterniond::get_axis_normalized 0 1 1838 169</span>
<span class="s0">/**</span>
 <span class="s0">* This, along with get_angle(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the</span>
 <span class="s0">* normalized axis.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LVector3d LQuaterniond::get_axis_normalized(void) const;</span>

<span class="s0">3554 13 get_angle_rad 0 4 3673 27 LQuaterniond::get_angle_rad 0 1 1839 343</span>
<span class="s0">/**</span>
 <span class="s0">* This, along with get_axis(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the angle, in</span>
 <span class="s0">* radians counterclockwise about the axis.</span>
 <span class="s0">*</span>
 <span class="s0">* It is necessary to ensure the quaternion has been normalized (for instance,</span>
 <span class="s0">* with a call to normalize()) before calling this method.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline double LQuaterniond::get_angle_rad(void) const;</span>

<span class="s0">3555 9 get_angle 0 4 3673 23 LQuaterniond::get_angle 0 1 1840 343</span>
<span class="s0">/**</span>
 <span class="s0">* This, along with get_axis(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the angle, in</span>
 <span class="s0">* degrees counterclockwise about the axis.</span>
 <span class="s0">*</span>
 <span class="s0">* It is necessary to ensure the quaternion has been normalized (for instance,</span>
 <span class="s0">* with a call to normalize()) before calling this method.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline double LQuaterniond::get_angle(void) const;</span>

<span class="s0">3556 23 set_from_axis_angle_rad 0 4 3673 37 LQuaterniond::set_from_axis_angle_rad 0 1 1841 86</span>
<span class="s0">/**</span>
 <span class="s0">* angle_rad is the angle about the axis in radians.  axis must be normalized.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &amp;axis);</span>

<span class="s0">3557 19 set_from_axis_angle 0 4 3673 33 LQuaterniond::set_from_axis_angle 0 1 1842 86</span>
<span class="s0">/**</span>
 <span class="s0">* angle_deg is the angle about the axis in degrees.  axis must be normalized.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &amp;axis);</span>

<span class="s0">3558 6 get_up 0 4 3673 20 LQuaterniond::get_up 0 1 1843 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as an up</span>
 <span class="s0">* vector.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const;</span>

<span class="s0">3559 9 get_right 0 4 3673 23 LQuaterniond::get_right 0 1 1844 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as a</span>
 <span class="s0">* right vector.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const;</span>

<span class="s0">3560 11 get_forward 0 4 3673 25 LQuaterniond::get_forward 0 1 1845 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as a</span>
 <span class="s0">* forward vector.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const;</span>

<span class="s0">3561 5 get_r 0 4 3673 19 LQuaterniond::get_r 0 1 1846 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline double LQuaterniond::get_r(void) const;</span>

<span class="s0">3562 5 get_i 0 4 3673 19 LQuaterniond::get_i 0 1 1847 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline double LQuaterniond::get_i(void) const;</span>

<span class="s0">3563 5 get_j 0 4 3673 19 LQuaterniond::get_j 0 1 1848 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline double LQuaterniond::get_j(void) const;</span>

<span class="s0">3564 5 get_k 0 4 3673 19 LQuaterniond::get_k 0 1 1849 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline double LQuaterniond::get_k(void) const;</span>

<span class="s0">3565 5 set_r 0 4 3673 19 LQuaterniond::set_r 0 1 1850 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void LQuaterniond::set_r(double r);</span>

<span class="s0">3566 5 set_i 0 4 3673 19 LQuaterniond::set_i 0 1 1851 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void LQuaterniond::set_i(double i);</span>

<span class="s0">3567 5 set_j 0 4 3673 19 LQuaterniond::set_j 0 1 1852 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void LQuaterniond::set_j(double j);</span>

<span class="s0">3568 5 set_k 0 4 3673 19 LQuaterniond::set_k 0 1 1853 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void LQuaterniond::set_k(double k);</span>

<span class="s0">3569 9 normalize 0 4 3673 23 LQuaterniond::normalize 0 1 1854 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool LQuaterniond::normalize(void);</span>

<span class="s0">3570 14 conjugate_from 0 4 3673 28 LQuaterniond::conjugate_from 0 1 1855 466</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the conjugate of the other quat, and stores the result in this</span>
 <span class="s0">* quat.  This is a fully general operation and makes no assumptions about the</span>
 <span class="s0">* type of transform represented by the quat.</span>
 <span class="s0">*</span>
 <span class="s0">* The other quat must be a different object than this quat.  However, if you</span>
 <span class="s0">* need to get a conjugate of a quat in place, see conjugate_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the quat was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline bool LQuaterniond::conjugate_from(LQuaterniond const &amp;other);</span>

<span class="s0">3571 18 conjugate_in_place 0 4 3673 32 LQuaterniond::conjugate_in_place 0 1 1856 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets this to be the conjugate of the current quat.  Returns true if the</span>
 <span class="s0">* successful, false if the quat was singular.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool LQuaterniond::conjugate_in_place(void);</span>

<span class="s0">3572 11 invert_from 0 4 3673 25 LQuaterniond::invert_from 0 1 1857 448</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the inverse of the other quat, and stores the result in this quat.</span>
 <span class="s0">* This is a fully general operation and makes no assumptions about the type</span>
 <span class="s0">* of transform represented by the quat.</span>
 <span class="s0">*</span>
 <span class="s0">* The other quat must be a different object than this quat.  However, if you</span>
 <span class="s0">* need to invert a quat in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the quat was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline bool LQuaterniond::invert_from(LQuaterniond const &amp;other);</span>

<span class="s0">3573 15 invert_in_place 0 4 3673 29 LQuaterniond::invert_in_place 0 1 1858 115</span>
<span class="s0">/**</span>
 <span class="s0">* Inverts the current quat.  Returns true if the inverse is successful, false</span>
 <span class="s0">* if the quat was singular.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool LQuaterniond::invert_in_place(void);</span>

<span class="s0">3574 11 is_identity 0 4 3673 25 LQuaterniond::is_identity 0 1 1859 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this quaternion represents the identity transformation: no</span>
 <span class="s0">* rotation.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool LQuaterniond::is_identity(void) const;</span>

<span class="s0">3575 18 is_almost_identity 0 4 3673 32 LQuaterniond::is_almost_identity 0 1 1860 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this quaternion represents the identity transformation</span>
 <span class="s0">* within a given tolerance.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline bool LQuaterniond::is_almost_identity(double tolerance) const;</span>

<span class="s0">3576 10 ident_quat 0 4 3673 24 LQuaterniond::ident_quat 0 1 1861 42</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an identity quaternion.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">static inline LQuaterniond const &amp;LQuaterniond::ident_quat(void);</span>

<span class="s0">3577 14 get_class_type 0 4 3673 28 LQuaterniond::get_class_type 0 1 1862 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle LQuaterniond::get_class_type(void);</span>

<span class="s0">3578 13 ~LQuaterniond 0 516 3673 27 LQuaterniond::~LQuaterniond 0 0 0</span>
<span class="s0">34</span>
<span class="s0">LQuaterniond::~LQuaterniond(void);</span>

<span class="s0">3579 10 LRotationf 0 260 3674 22 LRotationf::LRotationf 0 9 1863 1864 1865 1866 1867 1868 1869 1870 1871 185</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* lmatrix3</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* lmatrix4</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* axis + angle (in degrees)</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the rotation from the given Euler angles.</span>
 <span class="s0">*/</span>
<span class="s0">500</span>
<span class="s0">inline LRotationf::LRotationf(void);</span>
<span class="s0">inline LRotationf::LRotationf(LQuaternionf const &amp;c);</span>
<span class="s0">inline LRotationf::LRotationf(LVecBase4f const &amp;copy);</span>
<span class="s0">inline LRotationf::LRotationf(float r, float i, float j, float k);</span>
<span class="s0">inline LRotationf::LRotationf(LVector3f const &amp;axis, float angle);</span>
<span class="s0">inline LRotationf::LRotationf(LMatrix3f const &amp;m);</span>
<span class="s0">inline LRotationf::LRotationf(LMatrix4f const &amp;m);</span>
<span class="s0">inline LRotationf::LRotationf(float h, float p, float r);</span>
<span class="s0">inline LRotationf::LRotationf(LRotationf const &amp;) = default;</span>

<span class="s0">3580 10 operator * 0 4 3674 22 LRotationf::operator * 0 3 1872 1873 1874 0</span>
<span class="s0">211</span>
<span class="s0">inline LRotationf LRotationf::operator *(float scalar) const;</span>
<span class="s0">inline LRotationf LRotationf::operator *(LRotationf const &amp;other) const;</span>
<span class="s0">inline LQuaternionf LRotationf::operator *(LQuaternionf const &amp;other) const;</span>

<span class="s0">3581 10 operator / 0 4 3674 22 LRotationf::operator / 0 1 1875 0</span>
<span class="s0">61</span>
<span class="s0">inline LRotationf LRotationf::operator /(float scalar) const;</span>

<span class="s0">3582 14 get_class_type 0 4 3674 26 LRotationf::get_class_type 0 1 1876 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle LRotationf::get_class_type(void);</span>

<span class="s0">3583 11 ~LRotationf 0 516 3674 23 LRotationf::~LRotationf 0 0 0</span>
<span class="s0">30</span>
<span class="s0">LRotationf::~LRotationf(void);</span>

<span class="s0">3584 10 LRotationd 0 260 3675 22 LRotationd::LRotationd 0 9 1877 1878 1879 1880 1881 1882 1883 1884 1885 185</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* lmatrix3</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* lmatrix4</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* axis + angle (in degrees)</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the rotation from the given Euler angles.</span>
 <span class="s0">*/</span>
<span class="s0">508</span>
<span class="s0">inline LRotationd::LRotationd(void);</span>
<span class="s0">inline LRotationd::LRotationd(LQuaterniond const &amp;c);</span>
<span class="s0">inline LRotationd::LRotationd(LVecBase4d const &amp;copy);</span>
<span class="s0">inline LRotationd::LRotationd(double r, double i, double j, double k);</span>
<span class="s0">inline LRotationd::LRotationd(LVector3d const &amp;axis, double angle);</span>
<span class="s0">inline LRotationd::LRotationd(LMatrix3d const &amp;m);</span>
<span class="s0">inline LRotationd::LRotationd(LMatrix4d const &amp;m);</span>
<span class="s0">inline LRotationd::LRotationd(double h, double p, double r);</span>
<span class="s0">inline LRotationd::LRotationd(LRotationd const &amp;) = default;</span>

<span class="s0">3585 10 operator * 0 4 3675 22 LRotationd::operator * 0 3 1886 1887 1888 0</span>
<span class="s0">212</span>
<span class="s0">inline LRotationd LRotationd::operator *(double scalar) const;</span>
<span class="s0">inline LRotationd LRotationd::operator *(LRotationd const &amp;other) const;</span>
<span class="s0">inline LQuaterniond LRotationd::operator *(LQuaterniond const &amp;other) const;</span>

<span class="s0">3586 10 operator / 0 4 3675 22 LRotationd::operator / 0 1 1889 0</span>
<span class="s0">62</span>
<span class="s0">inline LRotationd LRotationd::operator /(double scalar) const;</span>

<span class="s0">3587 14 get_class_type 0 4 3675 26 LRotationd::get_class_type 0 1 1890 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle LRotationd::get_class_type(void);</span>

<span class="s0">3588 11 ~LRotationd 0 516 3675 23 LRotationd::~LRotationd 0 0 0</span>
<span class="s0">30</span>
<span class="s0">LRotationd::~LRotationd(void);</span>

<span class="s0">3589 13 LOrientationf 0 260 3676 28 LOrientationf::LOrientationf 0 7 1891 1892 1893 1894 1895 1896 1897 101</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* vector + twist</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* matrix3</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* matrix4</span>
 <span class="s0">*/</span>
<span class="s0">436</span>
<span class="s0">inline LOrientationf::LOrientationf(void);</span>
<span class="s0">inline LOrientationf::LOrientationf(LQuaternionf const &amp;c);</span>
<span class="s0">inline LOrientationf::LOrientationf(float r, float i, float j, float k);</span>
<span class="s0">inline LOrientationf::LOrientationf(LVector3f const &amp;point_at, float twist);</span>
<span class="s0">inline LOrientationf::LOrientationf(LMatrix3f const &amp;m);</span>
<span class="s0">inline LOrientationf::LOrientationf(LMatrix4f const &amp;m);</span>
<span class="s0">inline LOrientationf::LOrientationf(LOrientationf const &amp;) = default;</span>

<span class="s0">3590 10 operator * 0 4 3676 25 LOrientationf::operator * 0 2 1898 1899 0</span>
<span class="s0">159</span>
<span class="s0">inline LOrientationf LOrientationf::operator *(LRotationf const &amp;other) const;</span>
<span class="s0">inline LOrientationf LOrientationf::operator *(LQuaternionf const &amp;other) const;</span>

<span class="s0">3591 14 get_class_type 0 4 3676 29 LOrientationf::get_class_type 0 1 1900 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle LOrientationf::get_class_type(void);</span>

<span class="s0">3592 14 ~LOrientationf 0 516 3676 29 LOrientationf::~LOrientationf 0 0 0</span>
<span class="s0">36</span>
<span class="s0">LOrientationf::~LOrientationf(void);</span>

<span class="s0">3593 13 LOrientationd 0 260 3677 28 LOrientationd::LOrientationd 0 7 1901 1902 1903 1904 1905 1906 1907 101</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* vector + twist</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* matrix3</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* matrix4</span>
 <span class="s0">*/</span>
<span class="s0">441</span>
<span class="s0">inline LOrientationd::LOrientationd(void);</span>
<span class="s0">inline LOrientationd::LOrientationd(LQuaterniond const &amp;c);</span>
<span class="s0">inline LOrientationd::LOrientationd(double r, double i, double j, double k);</span>
<span class="s0">inline LOrientationd::LOrientationd(LVector3d const &amp;point_at, double twist);</span>
<span class="s0">inline LOrientationd::LOrientationd(LMatrix3d const &amp;m);</span>
<span class="s0">inline LOrientationd::LOrientationd(LMatrix4d const &amp;m);</span>
<span class="s0">inline LOrientationd::LOrientationd(LOrientationd const &amp;) = default;</span>

<span class="s0">3594 10 operator * 0 4 3677 25 LOrientationd::operator * 0 2 1908 1909 0</span>
<span class="s0">159</span>
<span class="s0">inline LOrientationd LOrientationd::operator *(LRotationd const &amp;other) const;</span>
<span class="s0">inline LOrientationd LOrientationd::operator *(LQuaterniond const &amp;other) const;</span>

<span class="s0">3595 14 get_class_type 0 4 3677 29 LOrientationd::get_class_type 0 1 1910 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle LOrientationd::get_class_type(void);</span>

<span class="s0">3596 14 ~LOrientationd 0 516 3677 29 LOrientationd::~LOrientationd 0 0 0</span>
<span class="s0">36</span>
<span class="s0">LOrientationd::~LOrientationd(void);</span>

<span class="s0">3597 19 ConfigVariableColor 0 260 3748 40 ConfigVariableColor::ConfigVariableColor 0 4 1911 1912 1913 1914 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">488</span>
<span class="s0">inline ConfigVariableColor::ConfigVariableColor(std::string const &amp;name);</span>
<span class="s0">inline ConfigVariableColor::ConfigVariableColor(std::string const &amp;name, LColor const &amp;default_value, std::string const &amp;description = string(), int flags = 0);</span>
<span class="s0">inline ConfigVariableColor::ConfigVariableColor(std::string const &amp;name, std::string const &amp;default_value, std::string const &amp;description = string(), int flags = 0);</span>
<span class="s0">inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &amp;) = default;</span>

<span class="s0">3598 10 operator = 0 4 3748 31 ConfigVariableColor::operator = 0 1 1915 0</span>
<span class="s0">65</span>
<span class="s0">inline void ConfigVariableColor::operator =(LColor const &amp;value);</span>

<span class="s0">3599 17 operator typecast 0 132 3748 38 ConfigVariableColor::operator typecast 0 1 1920 0</span>
<span class="s0">43</span>
<span class="s0">inline operator LColor const &amp;(void) const;</span>

<span class="s0">3600 11 operator [] 0 4 3748 32 ConfigVariableColor::operator [] 0 1 1916 0</span>
<span class="s0">65</span>
<span class="s0">inline PN_stdfloat ConfigVariableColor::operator [](int n) const;</span>

<span class="s0">3601 9 set_value 0 4 3748 30 ConfigVariableColor::set_value 0 1 1917 48</span>
<span class="s0">/**</span>
 <span class="s0">* Reassigns the variable's local value.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void ConfigVariableColor::set_value(LColor const &amp;value);</span>

<span class="s0">3602 9 get_value 0 4 3748 30 ConfigVariableColor::get_value 0 1 1918 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the variable's value.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LColor const &amp;ConfigVariableColor::get_value(void) const;</span>

<span class="s0">3603 17 get_default_value 0 4 3748 38 ConfigVariableColor::get_default_value 0 1 1919 48</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the variable's default value.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LColor ConfigVariableColor::get_default_value(void) const;</span>

<span class="s0">3604 20 ~ConfigVariableColor 0 516 3748 41 ConfigVariableColor::~ConfigVariableColor 0 0 0</span>
<span class="s0">48</span>
<span class="s0">ConfigVariableColor::~ConfigVariableColor(void);</span>

<span class="s0">2010</span>
<span class="s0">1 0 0 7 2 3750 2012 0 0 0 </span>
<span class="s0">2 0 0 15 2 3750 2012 0 0 1 6 param0 0 3751  </span>
<span class="s0">3 0 0 7 8 3753 2082 0 0 0 </span>
<span class="s0">4 0 0 15 8 3753 2082 0 0 1 6 param0 0 3754  </span>
<span class="s0">5 0 0 23 8 3753 2082 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3608  </span>
<span class="s0">6 0 0 23 8 3753 2082 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 1 x 1 3608  1 y 1 3608  </span>
<span class="s0">7 0 0 4 9 3758 0 0 0 2 4 this 3 3753  4 size 1 3756  </span>
<span class="s0">8 0 0 6 12 3753 0 0 0 2 4 this 3 3753  4 copy 1 3754  </span>
<span class="s0">9 0 0 6 12 3753 0 0 0 2 4 this 3 3753  10 fill_value 1 3608  </span>
<span class="s0">10 0 0 6 13 3754 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">11 0 0 6 14 3754 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">12 0 0 6 15 3754 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">13 0 0 38 16 3759 0 0 0 1 4 this 3 3754  </span>
<span class="s0">14 0 0 38 17 3759 0 0 0 2 4 this 3 3754  9 attr_name 1 3762  </span>
<span class="s0">15 0 0 38 18 3614 0 0 0 3 4 this 3 3753  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">16 0 0 4 19 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3753  1 i 1 3614  10 assign_val 1 3608  </span>
<span class="s0">17 0 0 6 19 3608 0 0 0 2 4 this 3 3754  1 i 1 3614  </span>
<span class="s0">18 0 0 6 20 3614 0 0 0 0 </span>
<span class="s0">19 0 0 6 21 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3754  </span>
<span class="s0">20 0 0 6 22 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3754  1 i 1 3614  </span>
<span class="s0">21 0 0 4 23 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3753  1 i 1 3614  5 value 1 3608  </span>
<span class="s0">22 0 0 6 24 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3754  </span>
<span class="s0">23 0 0 6 25 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3754  </span>
<span class="s0">24 0 0 4 26 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3753  5 value 1 3608  </span>
<span class="s0">25 0 0 4 27 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3753  5 value 1 3608  </span>
<span class="s0">26 0 0 4 31 3758 0 0 152 // These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages: 3 4 this 3 3753  1 i 1 3614  5 value 1 3608  </span>
<span class="s0">27 0 0 4 32 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3753  5 value 1 3608  </span>
<span class="s0">28 0 0 4 33 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3753  5 value 1 3608  </span>
<span class="s0">29 0 0 4 34 3758 0 0 155 /**</span>
 <span class="s0">* Returns the address of the first of the two data elements in the vector.</span>
 <span class="s0">* The next element occupies the next position consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3754  </span>
<span class="s0">30 0 0 6 35 3614 0 0 0 0 </span>
<span class="s0">31 0 0 4 36 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3753  10 fill_value 1 3608  </span>
<span class="s0">32 0 0 4 37 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3753  1 x 1 3608  1 y 1 3608  </span>
<span class="s0">33 0 0 6 38 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3754  5 other 1 3754  </span>
<span class="s0">34 0 0 6 39 3608 0 0 69 /**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/ 1 4 this 3 3754  </span>
<span class="s0">35 0 0 6 40 3608 0 0 72 /**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/ 1 4 this 3 3754  </span>
<span class="s0">36 0 0 6 41 3763 0 0 127 /**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/ 1 4 this 3 3753  </span>
<span class="s0">37 0 0 7 42 3753 2082 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3754  </span>
<span class="s0">38 0 0 7 43 3753 2082 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3754  4 onto 1 3754  </span>
<span class="s0">39 0 0 6 44 3763 0 0 0 2 4 this 3 3754  5 other 1 3754  </span>
<span class="s0">40 0 0 6 45 3763 0 0 0 2 4 this 3 3754  5 other 1 3754  </span>
<span class="s0">41 0 0 6 46 3763 0 0 0 2 4 this 3 3754  5 other 1 3754  </span>
<span class="s0">42 0 0 6 47 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3754  5 other 1 3754  </span>
<span class="s0">43 0 0 6 47 3614 0 0 233 /**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/ 3 4 this 3 3754  5 other 1 3754  9 threshold 1 3608  </span>
<span class="s0">44 0 0 6 48 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3754  </span>
<span class="s0">45 0 0 6 48 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 2 4 this 3 3754  9 threshold 1 3608  </span>
<span class="s0">46 0 0 6 49 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3754  4 hash 1 3756  </span>
<span class="s0">47 0 0 6 49 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 3 4 this 3 3754  4 hash 1 3756  9 threshold 1 3608  </span>
<span class="s0">48 0 0 4 50 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3754  7 hashgen 1 3764  </span>
<span class="s0">49 0 0 4 50 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 3 4 this 3 3754  7 hashgen 1 3764  9 threshold 1 3608  </span>
<span class="s0">50 0 0 7 51 3753 2082 0 0 1 4 this 3 3754  </span>
<span class="s0">51 0 0 7 52 3753 2082 0 0 2 4 this 3 3754  5 other 1 3754  </span>
<span class="s0">52 0 0 7 53 3753 2082 0 0 2 4 this 3 3754  5 other 1 3754  </span>
<span class="s0">53 0 0 7 54 3753 2082 0 0 2 4 this 3 3754  6 scalar 1 3608  </span>
<span class="s0">54 0 0 7 55 3753 2082 0 0 2 4 this 3 3754  6 scalar 1 3608  </span>
<span class="s0">55 0 0 6 56 3753 0 0 0 2 4 this 3 3753  5 other 1 3754  </span>
<span class="s0">56 0 0 6 57 3753 0 0 0 2 4 this 3 3753  5 other 1 3754  </span>
<span class="s0">57 0 0 6 58 3753 0 0 0 2 4 this 3 3753  6 scalar 1 3608  </span>
<span class="s0">58 0 0 6 59 3753 0 0 0 2 4 this 3 3753  6 scalar 1 3608  </span>
<span class="s0">59 0 0 4 60 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3753  5 other 1 3754  </span>
<span class="s0">60 0 0 38 61 3759 0 0 0 2 4 this 3 3754  6 scalar 1 3608  </span>
<span class="s0">61 0 0 38 62 3759 0 0 0 2 4 this 3 3753  6 scalar 1 3608  </span>
<span class="s0">62 0 0 38 63 3759 0 0 0 2 4 this 3 3754  8 exponent 1 3608  </span>
<span class="s0">63 0 0 38 64 3759 0 0 0 2 4 this 3 3753  8 exponent 1 3608  </span>
<span class="s0">64 0 0 38 65 3759 0 0 0 1 4 this 3 3753  </span>
<span class="s0">65 0 0 38 66 3759 0 0 0 1 4 this 3 3753  </span>
<span class="s0">66 0 0 38 67 3759 0 0 0 1 4 this 3 3753  </span>
<span class="s0">67 0 0 7 68 3753 2082 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3754  5 other 1 3754  </span>
<span class="s0">68 0 0 7 69 3753 2082 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3754  5 other 1 3754  </span>
<span class="s0">69 0 0 6 70 3763 0 0 116 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3754  5 other 1 3754  </span>
<span class="s0">70 0 0 6 70 3763 0 0 92 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3754  5 other 1 3754  9 threshold 1 3608  </span>
<span class="s0">71 0 0 4 71 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3754  3 out 1 3766  </span>
<span class="s0">72 0 0 38 72 3762 0 0 0 1 4 this 3 3754  </span>
<span class="s0">73 0 0 4 73 3758 0 0 332 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3754  11 destination 1 3768  </span>
<span class="s0">74 0 0 4 74 3758 0 0 114 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3753  6 source 1 3770  </span>
<span class="s0">75 0 0 4 75 3758 0 0 205 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3754  11 destination 1 3768  </span>
<span class="s0">76 0 0 4 76 3758 0 0 67 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3753  6 source 1 3770  </span>
<span class="s0">77 0 0 7 77 3773 0 0 0 0 </span>
<span class="s0">78 0 0 7 81 3774 2150 0 0 0 </span>
<span class="s0">79 0 0 15 81 3774 2150 0 0 1 6 param0 0 3775  </span>
<span class="s0">80 0 0 23 81 3774 2150 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3611  </span>
<span class="s0">81 0 0 23 81 3774 2150 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 1 x 1 3611  1 y 1 3611  </span>
<span class="s0">82 0 0 4 82 3758 0 0 0 2 4 this 3 3774  4 size 1 3756  </span>
<span class="s0">83 0 0 6 85 3774 0 0 0 2 4 this 3 3774  4 copy 1 3775  </span>
<span class="s0">84 0 0 6 85 3774 0 0 0 2 4 this 3 3774  10 fill_value 1 3611  </span>
<span class="s0">85 0 0 6 86 3775 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">86 0 0 6 87 3775 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">87 0 0 6 88 3775 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">88 0 0 38 89 3759 0 0 0 1 4 this 3 3775  </span>
<span class="s0">89 0 0 38 90 3759 0 0 0 2 4 this 3 3775  9 attr_name 1 3762  </span>
<span class="s0">90 0 0 38 91 3614 0 0 0 3 4 this 3 3774  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">91 0 0 4 92 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3774  1 i 1 3614  10 assign_val 1 3611  </span>
<span class="s0">92 0 0 6 92 3611 0 0 0 2 4 this 3 3775  1 i 1 3614  </span>
<span class="s0">93 0 0 6 93 3614 0 0 0 0 </span>
<span class="s0">94 0 0 6 94 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3775  </span>
<span class="s0">95 0 0 6 95 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3775  1 i 1 3614  </span>
<span class="s0">96 0 0 4 96 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3774  1 i 1 3614  5 value 1 3611  </span>
<span class="s0">97 0 0 6 97 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3775  </span>
<span class="s0">98 0 0 6 98 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3775  </span>
<span class="s0">99 0 0 4 99 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3774  5 value 1 3611  </span>
<span class="s0">100 0 0 4 100 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3774  5 value 1 3611  </span>
<span class="s0">101 0 0 4 104 3758 0 0 152 // These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages: 3 4 this 3 3774  1 i 1 3614  5 value 1 3611  </span>
<span class="s0">102 0 0 4 105 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3774  5 value 1 3611  </span>
<span class="s0">103 0 0 4 106 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3774  5 value 1 3611  </span>
<span class="s0">104 0 0 4 107 3758 0 0 155 /**</span>
 <span class="s0">* Returns the address of the first of the two data elements in the vector.</span>
 <span class="s0">* The next element occupies the next position consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3775  </span>
<span class="s0">105 0 0 6 108 3614 0 0 0 0 </span>
<span class="s0">106 0 0 4 109 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3774  10 fill_value 1 3611  </span>
<span class="s0">107 0 0 4 110 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3774  1 x 1 3611  1 y 1 3611  </span>
<span class="s0">108 0 0 6 111 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3775  5 other 1 3775  </span>
<span class="s0">109 0 0 6 112 3611 0 0 69 /**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/ 1 4 this 3 3775  </span>
<span class="s0">110 0 0 6 113 3611 0 0 72 /**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/ 1 4 this 3 3775  </span>
<span class="s0">111 0 0 6 114 3763 0 0 127 /**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/ 1 4 this 3 3774  </span>
<span class="s0">112 0 0 7 115 3774 2150 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3775  </span>
<span class="s0">113 0 0 7 116 3774 2150 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3775  4 onto 1 3775  </span>
<span class="s0">114 0 0 6 117 3763 0 0 0 2 4 this 3 3775  5 other 1 3775  </span>
<span class="s0">115 0 0 6 118 3763 0 0 0 2 4 this 3 3775  5 other 1 3775  </span>
<span class="s0">116 0 0 6 119 3763 0 0 0 2 4 this 3 3775  5 other 1 3775  </span>
<span class="s0">117 0 0 6 120 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3775  5 other 1 3775  </span>
<span class="s0">118 0 0 6 120 3614 0 0 233 /**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/ 3 4 this 3 3775  5 other 1 3775  9 threshold 1 3611  </span>
<span class="s0">119 0 0 6 121 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3775  </span>
<span class="s0">120 0 0 6 121 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 2 4 this 3 3775  9 threshold 1 3611  </span>
<span class="s0">121 0 0 6 122 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3775  4 hash 1 3756  </span>
<span class="s0">122 0 0 6 122 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 3 4 this 3 3775  4 hash 1 3756  9 threshold 1 3611  </span>
<span class="s0">123 0 0 4 123 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3775  7 hashgen 1 3764  </span>
<span class="s0">124 0 0 4 123 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 3 4 this 3 3775  7 hashgen 1 3764  9 threshold 1 3611  </span>
<span class="s0">125 0 0 7 124 3774 2150 0 0 1 4 this 3 3775  </span>
<span class="s0">126 0 0 7 125 3774 2150 0 0 2 4 this 3 3775  5 other 1 3775  </span>
<span class="s0">127 0 0 7 126 3774 2150 0 0 2 4 this 3 3775  5 other 1 3775  </span>
<span class="s0">128 0 0 7 127 3774 2150 0 0 2 4 this 3 3775  6 scalar 1 3611  </span>
<span class="s0">129 0 0 7 128 3774 2150 0 0 2 4 this 3 3775  6 scalar 1 3611  </span>
<span class="s0">130 0 0 6 129 3774 0 0 0 2 4 this 3 3774  5 other 1 3775  </span>
<span class="s0">131 0 0 6 130 3774 0 0 0 2 4 this 3 3774  5 other 1 3775  </span>
<span class="s0">132 0 0 6 131 3774 0 0 0 2 4 this 3 3774  6 scalar 1 3611  </span>
<span class="s0">133 0 0 6 132 3774 0 0 0 2 4 this 3 3774  6 scalar 1 3611  </span>
<span class="s0">134 0 0 4 133 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3774  5 other 1 3775  </span>
<span class="s0">135 0 0 38 134 3759 0 0 0 2 4 this 3 3775  6 scalar 1 3611  </span>
<span class="s0">136 0 0 38 135 3759 0 0 0 2 4 this 3 3774  6 scalar 1 3611  </span>
<span class="s0">137 0 0 38 136 3759 0 0 0 2 4 this 3 3775  8 exponent 1 3611  </span>
<span class="s0">138 0 0 38 137 3759 0 0 0 2 4 this 3 3774  8 exponent 1 3611  </span>
<span class="s0">139 0 0 38 138 3759 0 0 0 1 4 this 3 3774  </span>
<span class="s0">140 0 0 38 139 3759 0 0 0 1 4 this 3 3774  </span>
<span class="s0">141 0 0 38 140 3759 0 0 0 1 4 this 3 3774  </span>
<span class="s0">142 0 0 7 141 3774 2150 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3775  5 other 1 3775  </span>
<span class="s0">143 0 0 7 142 3774 2150 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3775  5 other 1 3775  </span>
<span class="s0">144 0 0 6 143 3763 0 0 116 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3775  5 other 1 3775  </span>
<span class="s0">145 0 0 6 143 3763 0 0 92 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3775  5 other 1 3775  9 threshold 1 3611  </span>
<span class="s0">146 0 0 4 144 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3775  3 out 1 3766  </span>
<span class="s0">147 0 0 38 145 3762 0 0 0 1 4 this 3 3775  </span>
<span class="s0">148 0 0 4 146 3758 0 0 332 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3775  11 destination 1 3768  </span>
<span class="s0">149 0 0 4 147 3758 0 0 114 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3774  6 source 1 3770  </span>
<span class="s0">150 0 0 4 148 3758 0 0 205 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3775  11 destination 1 3768  </span>
<span class="s0">151 0 0 4 149 3758 0 0 67 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3774  6 source 1 3770  </span>
<span class="s0">152 0 0 7 150 3773 0 0 0 0 </span>
<span class="s0">153 0 0 7 154 3777 2214 0 0 0 </span>
<span class="s0">154 0 0 15 154 3777 2214 0 0 1 6 param0 0 3778  </span>
<span class="s0">155 0 0 23 154 3777 2214 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3614  </span>
<span class="s0">156 0 0 23 154 3777 2214 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 1 x 1 3614  1 y 1 3614  </span>
<span class="s0">157 0 0 4 155 3758 0 0 0 2 4 this 3 3777  4 size 1 3756  </span>
<span class="s0">158 0 0 6 158 3777 0 0 0 2 4 this 3 3777  4 copy 1 3778  </span>
<span class="s0">159 0 0 6 158 3777 0 0 0 2 4 this 3 3777  10 fill_value 1 3614  </span>
<span class="s0">160 0 0 6 159 3778 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">161 0 0 6 160 3778 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">162 0 0 6 161 3778 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">163 0 0 38 162 3759 0 0 0 1 4 this 3 3778  </span>
<span class="s0">164 0 0 38 163 3759 0 0 0 2 4 this 3 3778  9 attr_name 1 3762  </span>
<span class="s0">165 0 0 38 164 3614 0 0 0 3 4 this 3 3777  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">166 0 0 4 165 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3777  1 i 1 3614  10 assign_val 1 3614  </span>
<span class="s0">167 0 0 6 165 3614 0 0 0 2 4 this 3 3778  1 i 1 3614  </span>
<span class="s0">168 0 0 6 166 3614 0 0 0 0 </span>
<span class="s0">169 0 0 6 167 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3778  </span>
<span class="s0">170 0 0 6 168 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3778  1 i 1 3614  </span>
<span class="s0">171 0 0 4 169 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3777  1 i 1 3614  5 value 1 3614  </span>
<span class="s0">172 0 0 6 170 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3778  </span>
<span class="s0">173 0 0 6 171 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3778  </span>
<span class="s0">174 0 0 4 172 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3777  5 value 1 3614  </span>
<span class="s0">175 0 0 4 173 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3777  5 value 1 3614  </span>
<span class="s0">176 0 0 4 177 3758 0 0 152 // These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages: 3 4 this 3 3777  1 i 1 3614  5 value 1 3614  </span>
<span class="s0">177 0 0 4 178 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3777  5 value 1 3614  </span>
<span class="s0">178 0 0 4 179 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3777  5 value 1 3614  </span>
<span class="s0">179 0 0 4 180 3758 0 0 155 /**</span>
 <span class="s0">* Returns the address of the first of the two data elements in the vector.</span>
 <span class="s0">* The next element occupies the next position consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3778  </span>
<span class="s0">180 0 0 6 181 3614 0 0 0 0 </span>
<span class="s0">181 0 0 4 182 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3777  10 fill_value 1 3614  </span>
<span class="s0">182 0 0 4 183 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3777  1 x 1 3614  1 y 1 3614  </span>
<span class="s0">183 0 0 6 184 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3778  5 other 1 3778  </span>
<span class="s0">184 0 0 6 185 3614 0 0 69 /**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/ 1 4 this 3 3778  </span>
<span class="s0">185 0 0 6 186 3763 0 0 0 2 4 this 3 3778  5 other 1 3778  </span>
<span class="s0">186 0 0 6 187 3763 0 0 0 2 4 this 3 3778  5 other 1 3778  </span>
<span class="s0">187 0 0 6 188 3763 0 0 0 2 4 this 3 3778  5 other 1 3778  </span>
<span class="s0">188 0 0 6 189 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3778  5 other 1 3778  </span>
<span class="s0">189 0 0 6 190 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3778  </span>
<span class="s0">190 0 0 6 191 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3778  4 hash 1 3756  </span>
<span class="s0">191 0 0 4 192 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3778  7 hashgen 1 3764  </span>
<span class="s0">192 0 0 7 193 3777 2214 0 0 1 4 this 3 3778  </span>
<span class="s0">193 0 0 7 194 3777 2214 0 0 2 4 this 3 3778  5 other 1 3778  </span>
<span class="s0">194 0 0 7 195 3777 2214 0 0 2 4 this 3 3778  5 other 1 3778  </span>
<span class="s0">195 0 0 7 196 3777 2214 0 0 2 4 this 3 3778  6 scalar 1 3614  </span>
<span class="s0">196 0 0 7 197 3777 2214 0 0 2 4 this 3 3778  6 scalar 1 3614  </span>
<span class="s0">197 0 0 6 198 3777 0 0 0 2 4 this 3 3777  5 other 1 3778  </span>
<span class="s0">198 0 0 6 199 3777 0 0 0 2 4 this 3 3777  5 other 1 3778  </span>
<span class="s0">199 0 0 6 200 3777 0 0 0 2 4 this 3 3777  6 scalar 1 3614  </span>
<span class="s0">200 0 0 6 201 3777 0 0 0 2 4 this 3 3777  6 scalar 1 3614  </span>
<span class="s0">201 0 0 4 202 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3777  5 other 1 3778  </span>
<span class="s0">202 0 0 38 203 3759 0 0 0 2 4 this 3 3778  6 scalar 1 3614  </span>
<span class="s0">203 0 0 38 204 3759 0 0 0 2 4 this 3 3777  6 scalar 1 3614  </span>
<span class="s0">204 0 0 38 205 3759 0 0 0 2 4 this 3 3778  8 exponent 1 3614  </span>
<span class="s0">205 0 0 38 206 3759 0 0 0 2 4 this 3 3777  8 exponent 1 3614  </span>
<span class="s0">206 0 0 38 207 3759 0 0 0 1 4 this 3 3777  </span>
<span class="s0">207 0 0 38 208 3759 0 0 0 1 4 this 3 3777  </span>
<span class="s0">208 0 0 38 209 3759 0 0 0 1 4 this 3 3777  </span>
<span class="s0">209 0 0 7 210 3777 2214 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3778  5 other 1 3778  </span>
<span class="s0">210 0 0 7 211 3777 2214 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3778  5 other 1 3778  </span>
<span class="s0">211 0 0 6 212 3763 0 0 116 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3778  5 other 1 3778  </span>
<span class="s0">212 0 0 6 212 3763 0 0 92 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3778  5 other 1 3778  9 threshold 1 3614  </span>
<span class="s0">213 0 0 4 213 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3778  3 out 1 3766  </span>
<span class="s0">214 0 0 38 214 3762 0 0 0 1 4 this 3 3778  </span>
<span class="s0">215 0 0 4 215 3758 0 0 332 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3778  11 destination 1 3768  </span>
<span class="s0">216 0 0 4 216 3758 0 0 114 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3777  6 source 1 3770  </span>
<span class="s0">217 0 0 4 217 3758 0 0 205 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3778  11 destination 1 3768  </span>
<span class="s0">218 0 0 4 218 3758 0 0 67 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3777  6 source 1 3770  </span>
<span class="s0">219 0 0 7 219 3773 0 0 0 0 </span>
<span class="s0">220 0 0 7 222 3780 2232 0 0 0 </span>
<span class="s0">221 0 0 23 222 3780 2232 0 53 /**</span>
 <span class="s0">* Constructs a new LVector2 from a LVecBase2</span>
 <span class="s0">*/ 1 4 copy 1 3754  </span>
<span class="s0">222 0 0 15 222 3780 2232 0 0 1 6 param0 0 3781  </span>
<span class="s0">223 0 0 23 222 3780 2232 0 79 /**</span>
 <span class="s0">* Constructs a new LVector2 with all components set to the fill value.</span>
 <span class="s0">*/ 1 10 fill_value 1 3608  </span>
<span class="s0">224 0 0 23 222 3780 2232 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 1 x 1 3608  1 y 1 3608  </span>
<span class="s0">225 0 0 38 223 3759 0 0 0 2 4 this 3 3781  9 attr_name 1 3762  </span>
<span class="s0">226 0 0 38 224 3614 0 0 0 3 4 this 3 3780  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">227 0 0 6 225 3781 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">228 0 0 6 226 3781 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">229 0 0 6 227 3781 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">230 0 0 7 228 3780 2232 0 0 1 4 this 3 3781  </span>
<span class="s0">231 0 0 7 229 3753 2082 0 0 2 4 this 3 3781  5 other 1 3754  </span>
<span class="s0">232 0 0 7 229 3780 2232 0 0 2 4 this 3 3781  5 other 1 3781  </span>
<span class="s0">233 0 0 7 230 3753 2082 0 0 2 4 this 3 3781  5 other 1 3754  </span>
<span class="s0">234 0 0 7 230 3780 2232 0 0 2 4 this 3 3781  5 other 1 3781  </span>
<span class="s0">235 0 0 7 231 3780 2232 0 0 2 4 this 3 3781  6 scalar 1 3608  </span>
<span class="s0">236 0 0 7 232 3780 2232 0 0 2 4 this 3 3781  6 scalar 1 3608  </span>
<span class="s0">237 0 0 7 233 3780 2232 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3781  </span>
<span class="s0">238 0 0 7 234 3780 2232 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3781  4 onto 1 3754  </span>
<span class="s0">239 0 0 6 235 3608 0 0 92 /**</span>
 <span class="s0">* returns the signed angled between two vectors.  normalization is NOT</span>
 <span class="s0">* necessary</span>
 <span class="s0">*/ 2 4 this 3 3781  5 other 1 3781  </span>
<span class="s0">240 0 0 6 236 3608 0 0 92 /**</span>
 <span class="s0">* returns the signed angled between two vectors.  normalization is NOT</span>
 <span class="s0">* necessary</span>
 <span class="s0">*/ 2 4 this 3 3781  5 other 1 3781  </span>
<span class="s0">241 0 0 38 237 3762 0 0 0 1 4 this 3 3781  </span>
<span class="s0">242 0 0 7 238 3773 0 0 0 0 </span>
<span class="s0">243 0 0 7 241 3783 2250 0 0 0 </span>
<span class="s0">244 0 0 23 241 3783 2250 0 53 /**</span>
 <span class="s0">* Constructs a new LVector2 from a LVecBase2</span>
 <span class="s0">*/ 1 4 copy 1 3775  </span>
<span class="s0">245 0 0 15 241 3783 2250 0 0 1 6 param0 0 3784  </span>
<span class="s0">246 0 0 23 241 3783 2250 0 79 /**</span>
 <span class="s0">* Constructs a new LVector2 with all components set to the fill value.</span>
 <span class="s0">*/ 1 10 fill_value 1 3611  </span>
<span class="s0">247 0 0 23 241 3783 2250 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 1 x 1 3611  1 y 1 3611  </span>
<span class="s0">248 0 0 38 242 3759 0 0 0 2 4 this 3 3784  9 attr_name 1 3762  </span>
<span class="s0">249 0 0 38 243 3614 0 0 0 3 4 this 3 3783  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">250 0 0 6 244 3784 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">251 0 0 6 245 3784 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">252 0 0 6 246 3784 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">253 0 0 7 247 3783 2250 0 0 1 4 this 3 3784  </span>
<span class="s0">254 0 0 7 248 3774 2150 0 0 2 4 this 3 3784  5 other 1 3775  </span>
<span class="s0">255 0 0 7 248 3783 2250 0 0 2 4 this 3 3784  5 other 1 3784  </span>
<span class="s0">256 0 0 7 249 3774 2150 0 0 2 4 this 3 3784  5 other 1 3775  </span>
<span class="s0">257 0 0 7 249 3783 2250 0 0 2 4 this 3 3784  5 other 1 3784  </span>
<span class="s0">258 0 0 7 250 3783 2250 0 0 2 4 this 3 3784  6 scalar 1 3611  </span>
<span class="s0">259 0 0 7 251 3783 2250 0 0 2 4 this 3 3784  6 scalar 1 3611  </span>
<span class="s0">260 0 0 7 252 3783 2250 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3784  </span>
<span class="s0">261 0 0 7 253 3783 2250 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3784  4 onto 1 3775  </span>
<span class="s0">262 0 0 6 254 3611 0 0 92 /**</span>
 <span class="s0">* returns the signed angled between two vectors.  normalization is NOT</span>
 <span class="s0">* necessary</span>
 <span class="s0">*/ 2 4 this 3 3784  5 other 1 3784  </span>
<span class="s0">263 0 0 6 255 3611 0 0 92 /**</span>
 <span class="s0">* returns the signed angled between two vectors.  normalization is NOT</span>
 <span class="s0">* necessary</span>
 <span class="s0">*/ 2 4 this 3 3784  5 other 1 3784  </span>
<span class="s0">264 0 0 38 256 3762 0 0 0 1 4 this 3 3784  </span>
<span class="s0">265 0 0 7 257 3773 0 0 0 0 </span>
<span class="s0">266 0 0 7 260 3786 2264 0 0 0 </span>
<span class="s0">267 0 0 23 260 3786 2264 0 53 /**</span>
 <span class="s0">* Constructs a new LVector2 from a LVecBase2</span>
 <span class="s0">*/ 1 4 copy 1 3778  </span>
<span class="s0">268 0 0 15 260 3786 2264 0 0 1 6 param0 0 3787  </span>
<span class="s0">269 0 0 23 260 3786 2264 0 79 /**</span>
 <span class="s0">* Constructs a new LVector2 with all components set to the fill value.</span>
 <span class="s0">*/ 1 10 fill_value 1 3614  </span>
<span class="s0">270 0 0 23 260 3786 2264 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 1 x 1 3614  1 y 1 3614  </span>
<span class="s0">271 0 0 38 261 3759 0 0 0 2 4 this 3 3787  9 attr_name 1 3762  </span>
<span class="s0">272 0 0 38 262 3614 0 0 0 3 4 this 3 3786  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">273 0 0 6 263 3787 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">274 0 0 6 264 3787 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">275 0 0 6 265 3787 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">276 0 0 7 266 3786 2264 0 0 1 4 this 3 3787  </span>
<span class="s0">277 0 0 7 267 3777 2214 0 0 2 4 this 3 3787  5 other 1 3778  </span>
<span class="s0">278 0 0 7 267 3786 2264 0 0 2 4 this 3 3787  5 other 1 3787  </span>
<span class="s0">279 0 0 7 268 3777 2214 0 0 2 4 this 3 3787  5 other 1 3778  </span>
<span class="s0">280 0 0 7 268 3786 2264 0 0 2 4 this 3 3787  5 other 1 3787  </span>
<span class="s0">281 0 0 7 269 3786 2264 0 0 2 4 this 3 3787  6 scalar 1 3614  </span>
<span class="s0">282 0 0 7 270 3786 2264 0 0 2 4 this 3 3787  6 scalar 1 3614  </span>
<span class="s0">283 0 0 38 271 3762 0 0 0 1 4 this 3 3787  </span>
<span class="s0">284 0 0 7 272 3773 0 0 0 0 </span>
<span class="s0">285 0 0 7 275 3789 2280 0 0 0 </span>
<span class="s0">286 0 0 15 275 3789 2280 0 0 1 6 param0 0 3790  </span>
<span class="s0">287 0 0 23 275 3789 2280 0 52 /**</span>
 <span class="s0">* Constructs a new LPoint2 from a LVecBase2</span>
 <span class="s0">*/ 1 4 copy 1 3754  </span>
<span class="s0">288 0 0 23 275 3789 2280 0 73 /**</span>
 <span class="s0">* Constructs a new LPoint2 all components set to the fill value.</span>
 <span class="s0">*/ 1 10 fill_value 1 3608  </span>
<span class="s0">289 0 0 23 275 3789 2280 0 61 /**</span>
 <span class="s0">* Constructs a new LPoint2 with the given components</span>
 <span class="s0">*/ 2 1 x 1 3608  1 y 1 3608  </span>
<span class="s0">290 0 0 38 276 3759 0 0 0 2 4 this 3 3790  9 attr_name 1 3762  </span>
<span class="s0">291 0 0 38 277 3614 0 0 0 3 4 this 3 3789  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">292 0 0 6 278 3790 0 0 39 /**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">293 0 0 6 279 3790 0 0 34 /**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">294 0 0 6 280 3790 0 0 34 /**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">295 0 0 7 281 3789 2280 0 0 1 4 this 3 3790  </span>
<span class="s0">296 0 0 7 282 3753 2082 0 0 2 4 this 3 3790  5 other 1 3754  </span>
<span class="s0">297 0 0 7 282 3789 2280 0 0 2 4 this 3 3790  5 other 1 3781  </span>
<span class="s0">298 0 0 7 283 3780 2232 0 0 2 4 this 3 3790  5 other 1 3790  </span>
<span class="s0">299 0 0 7 283 3753 2082 0 0 2 4 this 3 3790  5 other 1 3754  </span>
<span class="s0">300 0 0 7 283 3789 2280 0 0 2 4 this 3 3790  5 other 1 3781  </span>
<span class="s0">301 0 0 7 284 3789 2280 0 0 2 4 this 3 3790  6 scalar 1 3608  </span>
<span class="s0">302 0 0 7 285 3789 2280 0 0 2 4 this 3 3790  6 scalar 1 3608  </span>
<span class="s0">303 0 0 7 286 3789 2280 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3790  </span>
<span class="s0">304 0 0 7 287 3789 2280 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3790  4 onto 1 3754  </span>
<span class="s0">305 0 0 38 288 3762 0 0 0 1 4 this 3 3790  </span>
<span class="s0">306 0 0 7 289 3773 0 0 0 0 </span>
<span class="s0">307 0 0 7 292 3792 2296 0 0 0 </span>
<span class="s0">308 0 0 15 292 3792 2296 0 0 1 6 param0 0 3793  </span>
<span class="s0">309 0 0 23 292 3792 2296 0 52 /**</span>
 <span class="s0">* Constructs a new LPoint2 from a LVecBase2</span>
 <span class="s0">*/ 1 4 copy 1 3775  </span>
<span class="s0">310 0 0 23 292 3792 2296 0 73 /**</span>
 <span class="s0">* Constructs a new LPoint2 all components set to the fill value.</span>
 <span class="s0">*/ 1 10 fill_value 1 3611  </span>
<span class="s0">311 0 0 23 292 3792 2296 0 61 /**</span>
 <span class="s0">* Constructs a new LPoint2 with the given components</span>
 <span class="s0">*/ 2 1 x 1 3611  1 y 1 3611  </span>
<span class="s0">312 0 0 38 293 3759 0 0 0 2 4 this 3 3793  9 attr_name 1 3762  </span>
<span class="s0">313 0 0 38 294 3614 0 0 0 3 4 this 3 3792  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">314 0 0 6 295 3793 0 0 39 /**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">315 0 0 6 296 3793 0 0 34 /**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">316 0 0 6 297 3793 0 0 34 /**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">317 0 0 7 298 3792 2296 0 0 1 4 this 3 3793  </span>
<span class="s0">318 0 0 7 299 3774 2150 0 0 2 4 this 3 3793  5 other 1 3775  </span>
<span class="s0">319 0 0 7 299 3792 2296 0 0 2 4 this 3 3793  5 other 1 3784  </span>
<span class="s0">320 0 0 7 300 3783 2250 0 0 2 4 this 3 3793  5 other 1 3793  </span>
<span class="s0">321 0 0 7 300 3774 2150 0 0 2 4 this 3 3793  5 other 1 3775  </span>
<span class="s0">322 0 0 7 300 3792 2296 0 0 2 4 this 3 3793  5 other 1 3784  </span>
<span class="s0">323 0 0 7 301 3792 2296 0 0 2 4 this 3 3793  6 scalar 1 3611  </span>
<span class="s0">324 0 0 7 302 3792 2296 0 0 2 4 this 3 3793  6 scalar 1 3611  </span>
<span class="s0">325 0 0 7 303 3792 2296 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3793  </span>
<span class="s0">326 0 0 7 304 3792 2296 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3793  4 onto 1 3775  </span>
<span class="s0">327 0 0 38 305 3762 0 0 0 1 4 this 3 3793  </span>
<span class="s0">328 0 0 7 306 3773 0 0 0 0 </span>
<span class="s0">329 0 0 7 309 3795 2310 0 0 0 </span>
<span class="s0">330 0 0 15 309 3795 2310 0 0 1 6 param0 0 3796  </span>
<span class="s0">331 0 0 23 309 3795 2310 0 52 /**</span>
 <span class="s0">* Constructs a new LPoint2 from a LVecBase2</span>
 <span class="s0">*/ 1 4 copy 1 3778  </span>
<span class="s0">332 0 0 23 309 3795 2310 0 73 /**</span>
 <span class="s0">* Constructs a new LPoint2 all components set to the fill value.</span>
 <span class="s0">*/ 1 10 fill_value 1 3614  </span>
<span class="s0">333 0 0 23 309 3795 2310 0 61 /**</span>
 <span class="s0">* Constructs a new LPoint2 with the given components</span>
 <span class="s0">*/ 2 1 x 1 3614  1 y 1 3614  </span>
<span class="s0">334 0 0 38 310 3759 0 0 0 2 4 this 3 3796  9 attr_name 1 3762  </span>
<span class="s0">335 0 0 38 311 3614 0 0 0 3 4 this 3 3795  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">336 0 0 6 312 3796 0 0 39 /**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">337 0 0 6 313 3796 0 0 34 /**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">338 0 0 6 314 3796 0 0 34 /**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">339 0 0 7 315 3795 2310 0 0 1 4 this 3 3796  </span>
<span class="s0">340 0 0 7 316 3777 2214 0 0 2 4 this 3 3796  5 other 1 3778  </span>
<span class="s0">341 0 0 7 316 3795 2310 0 0 2 4 this 3 3796  5 other 1 3787  </span>
<span class="s0">342 0 0 7 317 3786 2264 0 0 2 4 this 3 3796  5 other 1 3796  </span>
<span class="s0">343 0 0 7 317 3777 2214 0 0 2 4 this 3 3796  5 other 1 3778  </span>
<span class="s0">344 0 0 7 317 3795 2310 0 0 2 4 this 3 3796  5 other 1 3787  </span>
<span class="s0">345 0 0 7 318 3795 2310 0 0 2 4 this 3 3796  6 scalar 1 3614  </span>
<span class="s0">346 0 0 7 319 3795 2310 0 0 2 4 this 3 3796  6 scalar 1 3614  </span>
<span class="s0">347 0 0 38 320 3762 0 0 0 1 4 this 3 3796  </span>
<span class="s0">348 0 0 7 321 3773 0 0 0 0 </span>
<span class="s0">349 0 0 7 325 3798 2388 0 0 0 </span>
<span class="s0">350 0 0 23 325 3798 2388 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3754  1 z 1 3608  </span>
<span class="s0">351 0 0 15 325 3798 2388 0 0 1 6 param0 0 3799  </span>
<span class="s0">352 0 0 23 325 3798 2388 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3608  </span>
<span class="s0">353 0 0 23 325 3798 2388 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 1 x 1 3608  1 y 1 3608  1 z 1 3608  </span>
<span class="s0">354 0 0 4 326 3758 0 0 0 2 4 this 3 3798  4 size 1 3756  </span>
<span class="s0">355 0 0 6 329 3798 0 0 0 2 4 this 3 3798  4 copy 1 3799  </span>
<span class="s0">356 0 0 6 329 3798 0 0 0 2 4 this 3 3798  10 fill_value 1 3608  </span>
<span class="s0">357 0 0 6 330 3799 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">358 0 0 6 331 3799 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">359 0 0 6 332 3799 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">360 0 0 6 333 3799 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">361 0 0 38 334 3759 0 0 0 1 4 this 3 3799  </span>
<span class="s0">362 0 0 38 335 3759 0 0 0 2 4 this 3 3799  9 attr_name 1 3762  </span>
<span class="s0">363 0 0 38 336 3614 0 0 0 3 4 this 3 3798  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">364 0 0 4 337 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3798  1 i 1 3614  10 assign_val 1 3608  </span>
<span class="s0">365 0 0 6 337 3608 0 0 0 2 4 this 3 3799  1 i 1 3614  </span>
<span class="s0">366 0 0 6 338 3614 0 0 0 0 </span>
<span class="s0">367 0 0 6 339 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">368 0 0 6 340 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3799  1 i 1 3614  </span>
<span class="s0">369 0 0 6 341 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">370 0 0 6 342 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">371 0 0 6 343 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">372 0 0 4 344 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3798  1 i 1 3614  5 value 1 3608  </span>
<span class="s0">373 0 0 4 345 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3798  5 value 1 3608  </span>
<span class="s0">374 0 0 4 346 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3798  5 value 1 3608  </span>
<span class="s0">375 0 0 4 347 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3798  5 value 1 3608  </span>
<span class="s0">376 0 0 7 348 3753 2082 0 100 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">377 0 0 7 349 3753 2082 0 105 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">378 0 0 7 350 3753 2082 0 99 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">379 0 0 4 357 3758 0 0 152 // These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages: 3 4 this 3 3798  1 i 1 3614  5 value 1 3608  </span>
<span class="s0">380 0 0 4 358 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3798  5 value 1 3608  </span>
<span class="s0">381 0 0 4 359 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3798  5 value 1 3608  </span>
<span class="s0">382 0 0 4 360 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3798  5 value 1 3608  </span>
<span class="s0">383 0 0 4 361 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">384 0 0 6 362 3614 0 0 0 0 </span>
<span class="s0">385 0 0 4 363 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3798  10 fill_value 1 3608  </span>
<span class="s0">386 0 0 4 364 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 3798  1 x 1 3608  1 y 1 3608  1 z 1 3608  </span>
<span class="s0">387 0 0 6 365 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3799  5 other 1 3799  </span>
<span class="s0">388 0 0 6 366 3608 0 0 69 /**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">389 0 0 6 367 3608 0 0 72 /**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">390 0 0 6 368 3763 0 0 127 /**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/ 1 4 this 3 3798  </span>
<span class="s0">391 0 0 7 369 3798 2388 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">392 0 0 7 370 3798 2388 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3799  4 onto 1 3799  </span>
<span class="s0">393 0 0 7 371 3798 2388 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3799  5 other 1 3799  </span>
<span class="s0">394 0 0 6 372 3763 0 0 0 2 4 this 3 3799  5 other 1 3799  </span>
<span class="s0">395 0 0 6 373 3763 0 0 0 2 4 this 3 3799  5 other 1 3799  </span>
<span class="s0">396 0 0 6 374 3763 0 0 0 2 4 this 3 3799  5 other 1 3799  </span>
<span class="s0">397 0 0 7 375 3798 2388 0 623 /**</span>
 <span class="s0">* Try to un-spin the hpr to a standard form.  Like all standards, someone</span>
 <span class="s0">* decides between many arbitrary possible standards.  This function assumes</span>
 <span class="s0">* that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the</span>
 <span class="s0">* same.  Another example is -90 and 270. Each element will be in the range</span>
 <span class="s0">* -180.0 to 179.99999. The original usage of this function is for human</span>
 <span class="s0">* readable output.</span>
 <span class="s0">*</span>
 <span class="s0">* It doesn't work so well for asserting that foo_hpr is roughly equal to</span>
 <span class="s0">* bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:</span>
 <span class="s0">* get_standardized_rotation, LQuaternion::is_same_direction</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">398 0 0 6 376 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3799  5 other 1 3799  </span>
<span class="s0">399 0 0 6 376 3614 0 0 233 /**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/ 3 4 this 3 3799  5 other 1 3799  9 threshold 1 3608  </span>
<span class="s0">400 0 0 6 377 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3799  </span>
<span class="s0">401 0 0 6 377 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 2 4 this 3 3799  9 threshold 1 3608  </span>
<span class="s0">402 0 0 6 378 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3799  4 hash 1 3756  </span>
<span class="s0">403 0 0 6 378 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 3 4 this 3 3799  4 hash 1 3756  9 threshold 1 3608  </span>
<span class="s0">404 0 0 4 379 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3799  7 hashgen 1 3764  </span>
<span class="s0">405 0 0 4 379 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 3 4 this 3 3799  7 hashgen 1 3764  9 threshold 1 3608  </span>
<span class="s0">406 0 0 7 380 3798 2388 0 0 1 4 this 3 3799  </span>
<span class="s0">407 0 0 7 381 3798 2388 0 0 2 4 this 3 3799  5 other 1 3799  </span>
<span class="s0">408 0 0 7 382 3798 2388 0 0 2 4 this 3 3799  5 other 1 3799  </span>
<span class="s0">409 0 0 7 383 3798 2388 0 0 2 4 this 3 3799  6 scalar 1 3608  </span>
<span class="s0">410 0 0 7 384 3798 2388 0 0 2 4 this 3 3799  6 scalar 1 3608  </span>
<span class="s0">411 0 0 6 385 3798 0 0 0 2 4 this 3 3798  5 other 1 3799  </span>
<span class="s0">412 0 0 6 386 3798 0 0 0 2 4 this 3 3798  5 other 1 3799  </span>
<span class="s0">413 0 0 6 387 3798 0 0 0 2 4 this 3 3798  6 scalar 1 3608  </span>
<span class="s0">414 0 0 6 388 3798 0 0 0 2 4 this 3 3798  6 scalar 1 3608  </span>
<span class="s0">415 0 0 4 389 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3798  5 other 1 3799  </span>
<span class="s0">416 0 0 38 390 3759 0 0 0 2 4 this 3 3799  6 scalar 1 3608  </span>
<span class="s0">417 0 0 38 391 3759 0 0 0 2 4 this 3 3798  6 scalar 1 3608  </span>
<span class="s0">418 0 0 38 392 3759 0 0 0 2 4 this 3 3799  8 exponent 1 3608  </span>
<span class="s0">419 0 0 38 393 3759 0 0 0 2 4 this 3 3798  8 exponent 1 3608  </span>
<span class="s0">420 0 0 38 394 3759 0 0 0 1 4 this 3 3798  </span>
<span class="s0">421 0 0 38 395 3759 0 0 0 1 4 this 3 3798  </span>
<span class="s0">422 0 0 38 396 3759 0 0 0 1 4 this 3 3798  </span>
<span class="s0">423 0 0 7 397 3798 2388 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3799  5 other 1 3799  </span>
<span class="s0">424 0 0 7 398 3798 2388 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3799  5 other 1 3799  </span>
<span class="s0">425 0 0 4 399 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3798  5 other 1 3799  </span>
<span class="s0">426 0 0 6 400 3763 0 0 116 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3799  5 other 1 3799  </span>
<span class="s0">427 0 0 6 400 3763 0 0 92 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3799  5 other 1 3799  9 threshold 1 3608  </span>
<span class="s0">428 0 0 4 401 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3799  3 out 1 3766  </span>
<span class="s0">429 0 0 38 402 3762 0 0 0 1 4 this 3 3799  </span>
<span class="s0">430 0 0 4 403 3758 0 0 332 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3799  11 destination 1 3768  </span>
<span class="s0">431 0 0 4 404 3758 0 0 114 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3798  6 source 1 3770  </span>
<span class="s0">432 0 0 4 405 3758 0 0 205 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3799  11 destination 1 3768  </span>
<span class="s0">433 0 0 4 406 3758 0 0 67 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3798  6 source 1 3770  </span>
<span class="s0">434 0 0 7 407 3773 0 0 0 0 </span>
<span class="s0">435 0 0 7 411 3801 2466 0 0 0 </span>
<span class="s0">436 0 0 23 411 3801 2466 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3775  1 z 1 3611  </span>
<span class="s0">437 0 0 15 411 3801 2466 0 0 1 6 param0 0 3802  </span>
<span class="s0">438 0 0 23 411 3801 2466 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3611  </span>
<span class="s0">439 0 0 23 411 3801 2466 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 1 x 1 3611  1 y 1 3611  1 z 1 3611  </span>
<span class="s0">440 0 0 4 412 3758 0 0 0 2 4 this 3 3801  4 size 1 3756  </span>
<span class="s0">441 0 0 6 415 3801 0 0 0 2 4 this 3 3801  4 copy 1 3802  </span>
<span class="s0">442 0 0 6 415 3801 0 0 0 2 4 this 3 3801  10 fill_value 1 3611  </span>
<span class="s0">443 0 0 6 416 3802 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">444 0 0 6 417 3802 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">445 0 0 6 418 3802 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">446 0 0 6 419 3802 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">447 0 0 38 420 3759 0 0 0 1 4 this 3 3802  </span>
<span class="s0">448 0 0 38 421 3759 0 0 0 2 4 this 3 3802  9 attr_name 1 3762  </span>
<span class="s0">449 0 0 38 422 3614 0 0 0 3 4 this 3 3801  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">450 0 0 4 423 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3801  1 i 1 3614  10 assign_val 1 3611  </span>
<span class="s0">451 0 0 6 423 3611 0 0 0 2 4 this 3 3802  1 i 1 3614  </span>
<span class="s0">452 0 0 6 424 3614 0 0 0 0 </span>
<span class="s0">453 0 0 6 425 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">454 0 0 6 426 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3802  1 i 1 3614  </span>
<span class="s0">455 0 0 6 427 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">456 0 0 6 428 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">457 0 0 6 429 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">458 0 0 4 430 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3801  1 i 1 3614  5 value 1 3611  </span>
<span class="s0">459 0 0 4 431 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3801  5 value 1 3611  </span>
<span class="s0">460 0 0 4 432 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3801  5 value 1 3611  </span>
<span class="s0">461 0 0 4 433 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3801  5 value 1 3611  </span>
<span class="s0">462 0 0 7 434 3774 2150 0 100 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">463 0 0 7 435 3774 2150 0 105 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">464 0 0 7 436 3774 2150 0 99 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">465 0 0 4 443 3758 0 0 152 // These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages: 3 4 this 3 3801  1 i 1 3614  5 value 1 3611  </span>
<span class="s0">466 0 0 4 444 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3801  5 value 1 3611  </span>
<span class="s0">467 0 0 4 445 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3801  5 value 1 3611  </span>
<span class="s0">468 0 0 4 446 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3801  5 value 1 3611  </span>
<span class="s0">469 0 0 4 447 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">470 0 0 6 448 3614 0 0 0 0 </span>
<span class="s0">471 0 0 4 449 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3801  10 fill_value 1 3611  </span>
<span class="s0">472 0 0 4 450 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 3801  1 x 1 3611  1 y 1 3611  1 z 1 3611  </span>
<span class="s0">473 0 0 6 451 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3802  5 other 1 3802  </span>
<span class="s0">474 0 0 6 452 3611 0 0 69 /**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">475 0 0 6 453 3611 0 0 72 /**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">476 0 0 6 454 3763 0 0 127 /**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/ 1 4 this 3 3801  </span>
<span class="s0">477 0 0 7 455 3801 2466 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">478 0 0 7 456 3801 2466 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3802  4 onto 1 3802  </span>
<span class="s0">479 0 0 7 457 3801 2466 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3802  5 other 1 3802  </span>
<span class="s0">480 0 0 6 458 3763 0 0 0 2 4 this 3 3802  5 other 1 3802  </span>
<span class="s0">481 0 0 6 459 3763 0 0 0 2 4 this 3 3802  5 other 1 3802  </span>
<span class="s0">482 0 0 6 460 3763 0 0 0 2 4 this 3 3802  5 other 1 3802  </span>
<span class="s0">483 0 0 7 461 3801 2466 0 623 /**</span>
 <span class="s0">* Try to un-spin the hpr to a standard form.  Like all standards, someone</span>
 <span class="s0">* decides between many arbitrary possible standards.  This function assumes</span>
 <span class="s0">* that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the</span>
 <span class="s0">* same.  Another example is -90 and 270. Each element will be in the range</span>
 <span class="s0">* -180.0 to 179.99999. The original usage of this function is for human</span>
 <span class="s0">* readable output.</span>
 <span class="s0">*</span>
 <span class="s0">* It doesn't work so well for asserting that foo_hpr is roughly equal to</span>
 <span class="s0">* bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:</span>
 <span class="s0">* get_standardized_rotation, LQuaternion::is_same_direction</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">484 0 0 6 462 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3802  5 other 1 3802  </span>
<span class="s0">485 0 0 6 462 3614 0 0 233 /**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/ 3 4 this 3 3802  5 other 1 3802  9 threshold 1 3611  </span>
<span class="s0">486 0 0 6 463 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3802  </span>
<span class="s0">487 0 0 6 463 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 2 4 this 3 3802  9 threshold 1 3611  </span>
<span class="s0">488 0 0 6 464 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3802  4 hash 1 3756  </span>
<span class="s0">489 0 0 6 464 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 3 4 this 3 3802  4 hash 1 3756  9 threshold 1 3611  </span>
<span class="s0">490 0 0 4 465 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3802  7 hashgen 1 3764  </span>
<span class="s0">491 0 0 4 465 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 3 4 this 3 3802  7 hashgen 1 3764  9 threshold 1 3611  </span>
<span class="s0">492 0 0 7 466 3801 2466 0 0 1 4 this 3 3802  </span>
<span class="s0">493 0 0 7 467 3801 2466 0 0 2 4 this 3 3802  5 other 1 3802  </span>
<span class="s0">494 0 0 7 468 3801 2466 0 0 2 4 this 3 3802  5 other 1 3802  </span>
<span class="s0">495 0 0 7 469 3801 2466 0 0 2 4 this 3 3802  6 scalar 1 3611  </span>
<span class="s0">496 0 0 7 470 3801 2466 0 0 2 4 this 3 3802  6 scalar 1 3611  </span>
<span class="s0">497 0 0 6 471 3801 0 0 0 2 4 this 3 3801  5 other 1 3802  </span>
<span class="s0">498 0 0 6 472 3801 0 0 0 2 4 this 3 3801  5 other 1 3802  </span>
<span class="s0">499 0 0 6 473 3801 0 0 0 2 4 this 3 3801  6 scalar 1 3611  </span>
<span class="s0">500 0 0 6 474 3801 0 0 0 2 4 this 3 3801  6 scalar 1 3611  </span>
<span class="s0">501 0 0 4 475 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3801  5 other 1 3802  </span>
<span class="s0">502 0 0 38 476 3759 0 0 0 2 4 this 3 3802  6 scalar 1 3611  </span>
<span class="s0">503 0 0 38 477 3759 0 0 0 2 4 this 3 3801  6 scalar 1 3611  </span>
<span class="s0">504 0 0 38 478 3759 0 0 0 2 4 this 3 3802  8 exponent 1 3611  </span>
<span class="s0">505 0 0 38 479 3759 0 0 0 2 4 this 3 3801  8 exponent 1 3611  </span>
<span class="s0">506 0 0 38 480 3759 0 0 0 1 4 this 3 3801  </span>
<span class="s0">507 0 0 38 481 3759 0 0 0 1 4 this 3 3801  </span>
<span class="s0">508 0 0 38 482 3759 0 0 0 1 4 this 3 3801  </span>
<span class="s0">509 0 0 7 483 3801 2466 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3802  5 other 1 3802  </span>
<span class="s0">510 0 0 7 484 3801 2466 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3802  5 other 1 3802  </span>
<span class="s0">511 0 0 4 485 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3801  5 other 1 3802  </span>
<span class="s0">512 0 0 6 486 3763 0 0 116 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3802  5 other 1 3802  </span>
<span class="s0">513 0 0 6 486 3763 0 0 92 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3802  5 other 1 3802  9 threshold 1 3611  </span>
<span class="s0">514 0 0 4 487 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3802  3 out 1 3766  </span>
<span class="s0">515 0 0 38 488 3762 0 0 0 1 4 this 3 3802  </span>
<span class="s0">516 0 0 4 489 3758 0 0 332 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3802  11 destination 1 3768  </span>
<span class="s0">517 0 0 4 490 3758 0 0 114 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3801  6 source 1 3770  </span>
<span class="s0">518 0 0 4 491 3758 0 0 205 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3802  11 destination 1 3768  </span>
<span class="s0">519 0 0 4 492 3758 0 0 67 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3801  6 source 1 3770  </span>
<span class="s0">520 0 0 7 493 3773 0 0 0 0 </span>
<span class="s0">521 0 0 7 497 3804 2539 0 0 0 </span>
<span class="s0">522 0 0 23 497 3804 2539 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3778  1 z 1 3614  </span>
<span class="s0">523 0 0 15 497 3804 2539 0 0 1 6 param0 0 3805  </span>
<span class="s0">524 0 0 23 497 3804 2539 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3614  </span>
<span class="s0">525 0 0 23 497 3804 2539 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 1 x 1 3614  1 y 1 3614  1 z 1 3614  </span>
<span class="s0">526 0 0 4 498 3758 0 0 0 2 4 this 3 3804  4 size 1 3756  </span>
<span class="s0">527 0 0 6 501 3804 0 0 0 2 4 this 3 3804  4 copy 1 3805  </span>
<span class="s0">528 0 0 6 501 3804 0 0 0 2 4 this 3 3804  10 fill_value 1 3614  </span>
<span class="s0">529 0 0 6 502 3805 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">530 0 0 6 503 3805 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">531 0 0 6 504 3805 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">532 0 0 6 505 3805 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">533 0 0 38 506 3759 0 0 0 1 4 this 3 3805  </span>
<span class="s0">534 0 0 38 507 3759 0 0 0 2 4 this 3 3805  9 attr_name 1 3762  </span>
<span class="s0">535 0 0 38 508 3614 0 0 0 3 4 this 3 3804  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">536 0 0 4 509 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3804  1 i 1 3614  10 assign_val 1 3614  </span>
<span class="s0">537 0 0 6 509 3614 0 0 0 2 4 this 3 3805  1 i 1 3614  </span>
<span class="s0">538 0 0 6 510 3614 0 0 0 0 </span>
<span class="s0">539 0 0 6 511 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3805  </span>
<span class="s0">540 0 0 6 512 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3805  1 i 1 3614  </span>
<span class="s0">541 0 0 6 513 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3805  </span>
<span class="s0">542 0 0 6 514 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3805  </span>
<span class="s0">543 0 0 6 515 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3805  </span>
<span class="s0">544 0 0 4 516 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3804  1 i 1 3614  5 value 1 3614  </span>
<span class="s0">545 0 0 4 517 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3804  5 value 1 3614  </span>
<span class="s0">546 0 0 4 518 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3804  5 value 1 3614  </span>
<span class="s0">547 0 0 4 519 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3804  5 value 1 3614  </span>
<span class="s0">548 0 0 7 520 3777 2214 0 100 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3805  </span>
<span class="s0">549 0 0 7 521 3777 2214 0 105 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/ 1 4 this 3 3805  </span>
<span class="s0">550 0 0 7 522 3777 2214 0 99 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3805  </span>
<span class="s0">551 0 0 4 529 3758 0 0 152 // These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages: 3 4 this 3 3804  1 i 1 3614  5 value 1 3614  </span>
<span class="s0">552 0 0 4 530 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3804  5 value 1 3614  </span>
<span class="s0">553 0 0 4 531 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3804  5 value 1 3614  </span>
<span class="s0">554 0 0 4 532 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3804  5 value 1 3614  </span>
<span class="s0">555 0 0 4 533 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3805  </span>
<span class="s0">556 0 0 6 534 3614 0 0 0 0 </span>
<span class="s0">557 0 0 4 535 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3804  10 fill_value 1 3614  </span>
<span class="s0">558 0 0 4 536 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 3804  1 x 1 3614  1 y 1 3614  1 z 1 3614  </span>
<span class="s0">559 0 0 6 537 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3805  5 other 1 3805  </span>
<span class="s0">560 0 0 6 538 3614 0 0 69 /**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/ 1 4 this 3 3805  </span>
<span class="s0">561 0 0 7 539 3804 2539 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3805  5 other 1 3805  </span>
<span class="s0">562 0 0 6 540 3763 0 0 0 2 4 this 3 3805  5 other 1 3805  </span>
<span class="s0">563 0 0 6 541 3763 0 0 0 2 4 this 3 3805  5 other 1 3805  </span>
<span class="s0">564 0 0 6 542 3763 0 0 0 2 4 this 3 3805  5 other 1 3805  </span>
<span class="s0">565 0 0 6 543 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3805  5 other 1 3805  </span>
<span class="s0">566 0 0 6 544 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3805  </span>
<span class="s0">567 0 0 6 545 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3805  4 hash 1 3756  </span>
<span class="s0">568 0 0 4 546 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3805  7 hashgen 1 3764  </span>
<span class="s0">569 0 0 7 547 3804 2539 0 0 1 4 this 3 3805  </span>
<span class="s0">570 0 0 7 548 3804 2539 0 0 2 4 this 3 3805  5 other 1 3805  </span>
<span class="s0">571 0 0 7 549 3804 2539 0 0 2 4 this 3 3805  5 other 1 3805  </span>
<span class="s0">572 0 0 7 550 3804 2539 0 0 2 4 this 3 3805  6 scalar 1 3614  </span>
<span class="s0">573 0 0 7 551 3804 2539 0 0 2 4 this 3 3805  6 scalar 1 3614  </span>
<span class="s0">574 0 0 6 552 3804 0 0 0 2 4 this 3 3804  5 other 1 3805  </span>
<span class="s0">575 0 0 6 553 3804 0 0 0 2 4 this 3 3804  5 other 1 3805  </span>
<span class="s0">576 0 0 6 554 3804 0 0 0 2 4 this 3 3804  6 scalar 1 3614  </span>
<span class="s0">577 0 0 6 555 3804 0 0 0 2 4 this 3 3804  6 scalar 1 3614  </span>
<span class="s0">578 0 0 4 556 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3804  5 other 1 3805  </span>
<span class="s0">579 0 0 38 557 3759 0 0 0 2 4 this 3 3805  6 scalar 1 3614  </span>
<span class="s0">580 0 0 38 558 3759 0 0 0 2 4 this 3 3804  6 scalar 1 3614  </span>
<span class="s0">581 0 0 38 559 3759 0 0 0 2 4 this 3 3805  8 exponent 1 3614  </span>
<span class="s0">582 0 0 38 560 3759 0 0 0 2 4 this 3 3804  8 exponent 1 3614  </span>
<span class="s0">583 0 0 38 561 3759 0 0 0 1 4 this 3 3804  </span>
<span class="s0">584 0 0 38 562 3759 0 0 0 1 4 this 3 3804  </span>
<span class="s0">585 0 0 38 563 3759 0 0 0 1 4 this 3 3804  </span>
<span class="s0">586 0 0 7 564 3804 2539 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3805  5 other 1 3805  </span>
<span class="s0">587 0 0 7 565 3804 2539 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3805  5 other 1 3805  </span>
<span class="s0">588 0 0 4 566 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3804  5 other 1 3805  </span>
<span class="s0">589 0 0 6 567 3763 0 0 116 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3805  5 other 1 3805  </span>
<span class="s0">590 0 0 6 567 3763 0 0 92 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3805  5 other 1 3805  9 threshold 1 3614  </span>
<span class="s0">591 0 0 4 568 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3805  3 out 1 3766  </span>
<span class="s0">592 0 0 38 569 3762 0 0 0 1 4 this 3 3805  </span>
<span class="s0">593 0 0 4 570 3758 0 0 332 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3805  11 destination 1 3768  </span>
<span class="s0">594 0 0 4 571 3758 0 0 114 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3804  6 source 1 3770  </span>
<span class="s0">595 0 0 4 572 3758 0 0 205 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3805  11 destination 1 3768  </span>
<span class="s0">596 0 0 4 573 3758 0 0 67 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3804  6 source 1 3770  </span>
<span class="s0">597 0 0 7 574 3773 0 0 0 0 </span>
<span class="s0">598 0 0 7 582 3807 2577 0 0 0 </span>
<span class="s0">599 0 0 23 582 3807 2577 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3754  1 z 1 3608  </span>
<span class="s0">600 0 0 23 582 3807 2577 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3799  </span>
<span class="s0">601 0 0 15 582 3807 2577 0 0 1 6 param0 0 3808  </span>
<span class="s0">602 0 0 23 582 3807 2577 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3608  </span>
<span class="s0">603 0 0 23 582 3807 2577 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 1 x 1 3608  1 y 1 3608  1 z 1 3608  </span>
<span class="s0">604 0 0 38 583 3759 0 0 0 2 4 this 3 3808  9 attr_name 1 3762  </span>
<span class="s0">605 0 0 38 584 3614 0 0 0 3 4 this 3 3807  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">606 0 0 6 585 3808 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">607 0 0 6 586 3808 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">608 0 0 6 587 3808 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">609 0 0 6 588 3808 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">610 0 0 7 589 3780 2232 0 100 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3808  </span>
<span class="s0">611 0 0 7 590 3780 2232 0 105 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/ 1 4 this 3 3808  </span>
<span class="s0">612 0 0 7 591 3780 2232 0 99 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3808  </span>
<span class="s0">613 0 0 7 595 3807 2577 0 0 1 4 this 3 3808  </span>
<span class="s0">614 0 0 7 596 3798 2388 0 0 2 4 this 3 3808  5 other 1 3799  </span>
<span class="s0">615 0 0 7 596 3807 2577 0 0 2 4 this 3 3808  5 other 1 3808  </span>
<span class="s0">616 0 0 7 597 3798 2388 0 0 2 4 this 3 3808  5 other 1 3799  </span>
<span class="s0">617 0 0 7 597 3807 2577 0 0 2 4 this 3 3808  5 other 1 3808  </span>
<span class="s0">618 0 0 7 598 3807 2577 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3808  5 other 1 3799  </span>
<span class="s0">619 0 0 7 599 3807 2577 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3808  </span>
<span class="s0">620 0 0 7 600 3807 2577 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3808  4 onto 1 3799  </span>
<span class="s0">621 0 0 6 601 3608 0 0 147 /**</span>
 <span class="s0">* Returns the unsigned angle between this vector and the other one, expressed</span>
 <span class="s0">* in radians.  Both vectors should be initially normalized.</span>
 <span class="s0">*/ 2 4 this 3 3808  5 other 1 3808  </span>
<span class="s0">622 0 0 6 602 3608 0 0 138 /**</span>
 <span class="s0">* Returns the angle between this vector and the other one, expressed in</span>
 <span class="s0">* degrees.  Both vectors should be initially normalized.</span>
 <span class="s0">*/ 2 4 this 3 3808  5 other 1 3808  </span>
<span class="s0">623 0 0 6 603 3608 0 0 259 /**</span>
 <span class="s0">* returns the signed angle between two vectors.  The angle is positive if the</span>
 <span class="s0">* rotation from this vector to other is clockwise when looking in the</span>
 <span class="s0">* direction of the ref vector.</span>
 <span class="s0">*</span>
 <span class="s0">* Vectors (except the ref vector) should be initially normalized.</span>
 <span class="s0">*/ 3 4 this 3 3808  5 other 1 3808  3 ref 1 3808  </span>
<span class="s0">624 0 0 6 604 3608 0 0 259 /**</span>
 <span class="s0">* Returns the signed angle between two vectors.  The angle is positive if the</span>
 <span class="s0">* rotation from this vector to other is clockwise when looking in the</span>
 <span class="s0">* direction of the ref vector.</span>
 <span class="s0">*</span>
 <span class="s0">* Vectors (except the ref vector) should be initially normalized.</span>
 <span class="s0">*/ 3 4 this 3 3808  5 other 1 3808  3 ref 1 3808  </span>
<span class="s0">625 0 0 6 605 3608 0 0 34 /**</span>
 <span class="s0">* @deprecated Do not use.</span>
 <span class="s0">*/ 2 4 this 3 3808  5 other 1 3808  </span>
<span class="s0">626 0 0 6 606 3608 0 0 34 /**</span>
 <span class="s0">* @deprecated Do not use.</span>
 <span class="s0">*/ 2 4 this 3 3808  5 other 1 3808  </span>
<span class="s0">627 0 0 7 607 3807 2577 0 0 2 4 this 3 3808  6 scalar 1 3608  </span>
<span class="s0">628 0 0 7 608 3807 2577 0 0 2 4 this 3 3808  6 scalar 1 3608  </span>
<span class="s0">629 0 0 7 609 3807 2577 0 65 /**</span>
 <span class="s0">* Returns the up vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">630 0 0 7 610 3807 2577 0 68 /**</span>
 <span class="s0">* Returns the right vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">631 0 0 7 611 3807 2577 0 70 /**</span>
 <span class="s0">* Returns the forward vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">632 0 0 7 612 3807 2577 0 67 /**</span>
 <span class="s0">* Returns the down vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">633 0 0 7 613 3807 2577 0 67 /**</span>
 <span class="s0">* Returns the left vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">634 0 0 7 614 3807 2577 0 67 /**</span>
 <span class="s0">* Returns the back vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">635 0 0 7 615 3807 2577 0 152 /**</span>
 <span class="s0">* Returns a vector that is described by its right, forward, and up</span>
 <span class="s0">* components, in whatever way the coordinate system represents that vector.</span>
 <span class="s0">*/ 4 5 right 1 3608  3 fwd 1 3608  2 up 1 3608  2 cs 5 3627  </span>
<span class="s0">636 0 0 38 616 3762 0 0 0 1 4 this 3 3808  </span>
<span class="s0">637 0 0 7 617 3773 0 0 0 0 </span>
<span class="s0">638 0 0 7 620 3810 2611 0 0 0 </span>
<span class="s0">639 0 0 23 620 3810 2611 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3775  1 z 1 3611  </span>
<span class="s0">640 0 0 23 620 3810 2611 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3802  </span>
<span class="s0">641 0 0 15 620 3810 2611 0 0 1 6 param0 0 3811  </span>
<span class="s0">642 0 0 23 620 3810 2611 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3611  </span>
<span class="s0">643 0 0 23 620 3810 2611 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 1 x 1 3611  1 y 1 3611  1 z 1 3611  </span>
<span class="s0">644 0 0 38 621 3759 0 0 0 2 4 this 3 3811  9 attr_name 1 3762  </span>
<span class="s0">645 0 0 38 622 3614 0 0 0 3 4 this 3 3810  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">646 0 0 6 623 3811 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">647 0 0 6 624 3811 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">648 0 0 6 625 3811 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">649 0 0 6 626 3811 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">650 0 0 7 627 3783 2250 0 100 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3811  </span>
<span class="s0">651 0 0 7 628 3783 2250 0 105 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/ 1 4 this 3 3811  </span>
<span class="s0">652 0 0 7 629 3783 2250 0 99 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3811  </span>
<span class="s0">653 0 0 7 633 3810 2611 0 0 1 4 this 3 3811  </span>
<span class="s0">654 0 0 7 634 3801 2466 0 0 2 4 this 3 3811  5 other 1 3802  </span>
<span class="s0">655 0 0 7 634 3810 2611 0 0 2 4 this 3 3811  5 other 1 3811  </span>
<span class="s0">656 0 0 7 635 3801 2466 0 0 2 4 this 3 3811  5 other 1 3802  </span>
<span class="s0">657 0 0 7 635 3810 2611 0 0 2 4 this 3 3811  5 other 1 3811  </span>
<span class="s0">658 0 0 7 636 3810 2611 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3811  5 other 1 3802  </span>
<span class="s0">659 0 0 7 637 3810 2611 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3811  </span>
<span class="s0">660 0 0 7 638 3810 2611 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3811  4 onto 1 3802  </span>
<span class="s0">661 0 0 6 639 3611 0 0 147 /**</span>
 <span class="s0">* Returns the unsigned angle between this vector and the other one, expressed</span>
 <span class="s0">* in radians.  Both vectors should be initially normalized.</span>
 <span class="s0">*/ 2 4 this 3 3811  5 other 1 3811  </span>
<span class="s0">662 0 0 6 640 3611 0 0 138 /**</span>
 <span class="s0">* Returns the angle between this vector and the other one, expressed in</span>
 <span class="s0">* degrees.  Both vectors should be initially normalized.</span>
 <span class="s0">*/ 2 4 this 3 3811  5 other 1 3811  </span>
<span class="s0">663 0 0 6 641 3611 0 0 259 /**</span>
 <span class="s0">* returns the signed angle between two vectors.  The angle is positive if the</span>
 <span class="s0">* rotation from this vector to other is clockwise when looking in the</span>
 <span class="s0">* direction of the ref vector.</span>
 <span class="s0">*</span>
 <span class="s0">* Vectors (except the ref vector) should be initially normalized.</span>
 <span class="s0">*/ 3 4 this 3 3811  5 other 1 3811  3 ref 1 3811  </span>
<span class="s0">664 0 0 6 642 3611 0 0 259 /**</span>
 <span class="s0">* Returns the signed angle between two vectors.  The angle is positive if the</span>
 <span class="s0">* rotation from this vector to other is clockwise when looking in the</span>
 <span class="s0">* direction of the ref vector.</span>
 <span class="s0">*</span>
 <span class="s0">* Vectors (except the ref vector) should be initially normalized.</span>
 <span class="s0">*/ 3 4 this 3 3811  5 other 1 3811  3 ref 1 3811  </span>
<span class="s0">665 0 0 6 643 3611 0 0 34 /**</span>
 <span class="s0">* @deprecated Do not use.</span>
 <span class="s0">*/ 2 4 this 3 3811  5 other 1 3811  </span>
<span class="s0">666 0 0 6 644 3611 0 0 34 /**</span>
 <span class="s0">* @deprecated Do not use.</span>
 <span class="s0">*/ 2 4 this 3 3811  5 other 1 3811  </span>
<span class="s0">667 0 0 7 645 3810 2611 0 0 2 4 this 3 3811  6 scalar 1 3611  </span>
<span class="s0">668 0 0 7 646 3810 2611 0 0 2 4 this 3 3811  6 scalar 1 3611  </span>
<span class="s0">669 0 0 7 647 3810 2611 0 65 /**</span>
 <span class="s0">* Returns the up vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">670 0 0 7 648 3810 2611 0 68 /**</span>
 <span class="s0">* Returns the right vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">671 0 0 7 649 3810 2611 0 70 /**</span>
 <span class="s0">* Returns the forward vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">672 0 0 7 650 3810 2611 0 67 /**</span>
 <span class="s0">* Returns the down vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">673 0 0 7 651 3810 2611 0 67 /**</span>
 <span class="s0">* Returns the left vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">674 0 0 7 652 3810 2611 0 67 /**</span>
 <span class="s0">* Returns the back vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">675 0 0 7 653 3810 2611 0 152 /**</span>
 <span class="s0">* Returns a vector that is described by its right, forward, and up</span>
 <span class="s0">* components, in whatever way the coordinate system represents that vector.</span>
 <span class="s0">*/ 4 5 right 1 3611  3 fwd 1 3611  2 up 1 3611  2 cs 5 3627  </span>
<span class="s0">676 0 0 38 654 3762 0 0 0 1 4 this 3 3811  </span>
<span class="s0">677 0 0 7 655 3773 0 0 0 0 </span>
<span class="s0">678 0 0 7 658 3813 2637 0 0 0 </span>
<span class="s0">679 0 0 23 658 3813 2637 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3778  1 z 1 3614  </span>
<span class="s0">680 0 0 23 658 3813 2637 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3805  </span>
<span class="s0">681 0 0 15 658 3813 2637 0 0 1 6 param0 0 3814  </span>
<span class="s0">682 0 0 23 658 3813 2637 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3614  </span>
<span class="s0">683 0 0 23 658 3813 2637 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 1 x 1 3614  1 y 1 3614  1 z 1 3614  </span>
<span class="s0">684 0 0 38 659 3759 0 0 0 2 4 this 3 3814  9 attr_name 1 3762  </span>
<span class="s0">685 0 0 38 660 3614 0 0 0 3 4 this 3 3813  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">686 0 0 6 661 3814 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">687 0 0 6 662 3814 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">688 0 0 6 663 3814 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">689 0 0 6 664 3814 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">690 0 0 7 665 3786 2264 0 100 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3814  </span>
<span class="s0">691 0 0 7 666 3786 2264 0 105 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/ 1 4 this 3 3814  </span>
<span class="s0">692 0 0 7 667 3786 2264 0 99 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3814  </span>
<span class="s0">693 0 0 7 671 3813 2637 0 0 1 4 this 3 3814  </span>
<span class="s0">694 0 0 7 672 3804 2539 0 0 2 4 this 3 3814  5 other 1 3805  </span>
<span class="s0">695 0 0 7 672 3813 2637 0 0 2 4 this 3 3814  5 other 1 3814  </span>
<span class="s0">696 0 0 7 673 3804 2539 0 0 2 4 this 3 3814  5 other 1 3805  </span>
<span class="s0">697 0 0 7 673 3813 2637 0 0 2 4 this 3 3814  5 other 1 3814  </span>
<span class="s0">698 0 0 7 674 3813 2637 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3814  5 other 1 3805  </span>
<span class="s0">699 0 0 7 675 3813 2637 0 0 2 4 this 3 3814  6 scalar 1 3614  </span>
<span class="s0">700 0 0 7 676 3813 2637 0 0 2 4 this 3 3814  6 scalar 1 3614  </span>
<span class="s0">701 0 0 7 677 3813 2637 0 65 /**</span>
 <span class="s0">* Returns the up vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">702 0 0 7 678 3813 2637 0 68 /**</span>
 <span class="s0">* Returns the right vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">703 0 0 7 679 3813 2637 0 70 /**</span>
 <span class="s0">* Returns the forward vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">704 0 0 7 680 3813 2637 0 67 /**</span>
 <span class="s0">* Returns the down vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">705 0 0 7 681 3813 2637 0 67 /**</span>
 <span class="s0">* Returns the left vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">706 0 0 7 682 3813 2637 0 67 /**</span>
 <span class="s0">* Returns the back vector for the given coordinate system.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">707 0 0 7 683 3813 2637 0 152 /**</span>
 <span class="s0">* Returns a vector that is described by its right, forward, and up</span>
 <span class="s0">* components, in whatever way the coordinate system represents that vector.</span>
 <span class="s0">*/ 4 5 right 1 3614  3 fwd 1 3614  2 up 1 3614  2 cs 5 3627  </span>
<span class="s0">708 0 0 38 684 3762 0 0 0 1 4 this 3 3814  </span>
<span class="s0">709 0 0 7 685 3773 0 0 0 0 </span>
<span class="s0">710 0 0 7 688 3816 2660 0 0 0 </span>
<span class="s0">711 0 0 15 688 3816 2660 0 0 1 6 param0 0 3817  </span>
<span class="s0">712 0 0 23 688 3816 2660 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3754  1 z 1 3608  </span>
<span class="s0">713 0 0 23 688 3816 2660 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3799  </span>
<span class="s0">714 0 0 23 688 3816 2660 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3608  </span>
<span class="s0">715 0 0 23 688 3816 2660 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 1 x 1 3608  1 y 1 3608  1 z 1 3608  </span>
<span class="s0">716 0 0 38 689 3759 0 0 0 2 4 this 3 3817  9 attr_name 1 3762  </span>
<span class="s0">717 0 0 38 690 3614 0 0 0 3 4 this 3 3816  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">718 0 0 6 691 3817 0 0 39 /**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">719 0 0 6 692 3817 0 0 34 /**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">720 0 0 6 693 3817 0 0 34 /**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">721 0 0 6 694 3817 0 0 34 /**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">722 0 0 7 695 3789 2280 0 100 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3817  </span>
<span class="s0">723 0 0 7 696 3789 2280 0 105 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/ 1 4 this 3 3817  </span>
<span class="s0">724 0 0 7 697 3789 2280 0 99 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3817  </span>
<span class="s0">725 0 0 7 701 3816 2660 0 0 1 4 this 3 3817  </span>
<span class="s0">726 0 0 7 702 3798 2388 0 0 2 4 this 3 3817  5 other 1 3799  </span>
<span class="s0">727 0 0 7 702 3816 2660 0 0 2 4 this 3 3817  5 other 1 3808  </span>
<span class="s0">728 0 0 7 703 3807 2577 0 0 2 4 this 3 3817  5 other 1 3817  </span>
<span class="s0">729 0 0 7 703 3798 2388 0 0 2 4 this 3 3817  5 other 1 3799  </span>
<span class="s0">730 0 0 7 703 3816 2660 0 0 2 4 this 3 3817  5 other 1 3808  </span>
<span class="s0">731 0 0 7 704 3816 2660 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3817  5 other 1 3799  </span>
<span class="s0">732 0 0 7 705 3816 2660 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3817  </span>
<span class="s0">733 0 0 7 706 3816 2660 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3817  4 onto 1 3799  </span>
<span class="s0">734 0 0 7 707 3816 2660 0 0 2 4 this 3 3817  6 scalar 1 3608  </span>
<span class="s0">735 0 0 7 708 3816 2660 0 0 2 4 this 3 3817  6 scalar 1 3608  </span>
<span class="s0">736 0 0 6 709 3817 0 0 186 /**</span>
 <span class="s0">* Returns the origin of the indicated coordinate system.  This is always 0,</span>
 <span class="s0">* 0, 0 with all of our existing coordinate systems; it's hard to imagine it</span>
 <span class="s0">* ever being different.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">737 0 0 7 710 3816 2660 0 146 /**</span>
 <span class="s0">* Returns a point described by right, forward, up displacements from the</span>
 <span class="s0">* origin, wherever that maps to in the given coordinate system.</span>
 <span class="s0">*/ 4 5 right 1 3608  3 fwd 1 3608  2 up 1 3608  2 cs 5 3627  </span>
<span class="s0">738 0 0 38 711 3762 0 0 0 1 4 this 3 3817  </span>
<span class="s0">739 0 0 7 712 3773 0 0 0 0 </span>
<span class="s0">740 0 0 7 715 3819 2683 0 0 0 </span>
<span class="s0">741 0 0 15 715 3819 2683 0 0 1 6 param0 0 3820  </span>
<span class="s0">742 0 0 23 715 3819 2683 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3775  1 z 1 3611  </span>
<span class="s0">743 0 0 23 715 3819 2683 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3802  </span>
<span class="s0">744 0 0 23 715 3819 2683 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3611  </span>
<span class="s0">745 0 0 23 715 3819 2683 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 1 x 1 3611  1 y 1 3611  1 z 1 3611  </span>
<span class="s0">746 0 0 38 716 3759 0 0 0 2 4 this 3 3820  9 attr_name 1 3762  </span>
<span class="s0">747 0 0 38 717 3614 0 0 0 3 4 this 3 3819  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">748 0 0 6 718 3820 0 0 39 /**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">749 0 0 6 719 3820 0 0 34 /**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">750 0 0 6 720 3820 0 0 34 /**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">751 0 0 6 721 3820 0 0 34 /**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">752 0 0 7 722 3792 2296 0 100 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3820  </span>
<span class="s0">753 0 0 7 723 3792 2296 0 105 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/ 1 4 this 3 3820  </span>
<span class="s0">754 0 0 7 724 3792 2296 0 99 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3820  </span>
<span class="s0">755 0 0 7 728 3819 2683 0 0 1 4 this 3 3820  </span>
<span class="s0">756 0 0 7 729 3801 2466 0 0 2 4 this 3 3820  5 other 1 3802  </span>
<span class="s0">757 0 0 7 729 3819 2683 0 0 2 4 this 3 3820  5 other 1 3811  </span>
<span class="s0">758 0 0 7 730 3810 2611 0 0 2 4 this 3 3820  5 other 1 3820  </span>
<span class="s0">759 0 0 7 730 3801 2466 0 0 2 4 this 3 3820  5 other 1 3802  </span>
<span class="s0">760 0 0 7 730 3819 2683 0 0 2 4 this 3 3820  5 other 1 3811  </span>
<span class="s0">761 0 0 7 731 3819 2683 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3820  5 other 1 3802  </span>
<span class="s0">762 0 0 7 732 3819 2683 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3820  </span>
<span class="s0">763 0 0 7 733 3819 2683 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3820  4 onto 1 3802  </span>
<span class="s0">764 0 0 7 734 3819 2683 0 0 2 4 this 3 3820  6 scalar 1 3611  </span>
<span class="s0">765 0 0 7 735 3819 2683 0 0 2 4 this 3 3820  6 scalar 1 3611  </span>
<span class="s0">766 0 0 6 736 3820 0 0 186 /**</span>
 <span class="s0">* Returns the origin of the indicated coordinate system.  This is always 0,</span>
 <span class="s0">* 0, 0 with all of our existing coordinate systems; it's hard to imagine it</span>
 <span class="s0">* ever being different.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">767 0 0 7 737 3819 2683 0 146 /**</span>
 <span class="s0">* Returns a point described by right, forward, up displacements from the</span>
 <span class="s0">* origin, wherever that maps to in the given coordinate system.</span>
 <span class="s0">*/ 4 5 right 1 3611  3 fwd 1 3611  2 up 1 3611  2 cs 5 3627  </span>
<span class="s0">768 0 0 38 738 3762 0 0 0 1 4 this 3 3820  </span>
<span class="s0">769 0 0 7 739 3773 0 0 0 0 </span>
<span class="s0">770 0 0 7 742 3822 2704 0 0 0 </span>
<span class="s0">771 0 0 15 742 3822 2704 0 0 1 6 param0 0 3823  </span>
<span class="s0">772 0 0 23 742 3822 2704 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3778  1 z 1 3614  </span>
<span class="s0">773 0 0 23 742 3822 2704 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3805  </span>
<span class="s0">774 0 0 23 742 3822 2704 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3614  </span>
<span class="s0">775 0 0 23 742 3822 2704 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 1 x 1 3614  1 y 1 3614  1 z 1 3614  </span>
<span class="s0">776 0 0 38 743 3759 0 0 0 2 4 this 3 3823  9 attr_name 1 3762  </span>
<span class="s0">777 0 0 38 744 3614 0 0 0 3 4 this 3 3822  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">778 0 0 6 745 3823 0 0 39 /**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">779 0 0 6 746 3823 0 0 34 /**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">780 0 0 6 747 3823 0 0 34 /**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">781 0 0 6 748 3823 0 0 34 /**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">782 0 0 7 749 3795 2310 0 100 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3823  </span>
<span class="s0">783 0 0 7 750 3795 2310 0 105 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the first and last components</span>
 <span class="s0">* of this vector.</span>
 <span class="s0">*/ 1 4 this 3 3823  </span>
<span class="s0">784 0 0 7 751 3795 2310 0 99 /**</span>
 <span class="s0">* Returns a 2-component vector that shares just the last two components of</span>
 <span class="s0">* this vector.</span>
 <span class="s0">*/ 1 4 this 3 3823  </span>
<span class="s0">785 0 0 7 755 3822 2704 0 0 1 4 this 3 3823  </span>
<span class="s0">786 0 0 7 756 3804 2539 0 0 2 4 this 3 3823  5 other 1 3805  </span>
<span class="s0">787 0 0 7 756 3822 2704 0 0 2 4 this 3 3823  5 other 1 3814  </span>
<span class="s0">788 0 0 7 757 3813 2637 0 0 2 4 this 3 3823  5 other 1 3823  </span>
<span class="s0">789 0 0 7 757 3804 2539 0 0 2 4 this 3 3823  5 other 1 3805  </span>
<span class="s0">790 0 0 7 757 3822 2704 0 0 2 4 this 3 3823  5 other 1 3814  </span>
<span class="s0">791 0 0 7 758 3822 2704 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3823  5 other 1 3805  </span>
<span class="s0">792 0 0 7 759 3822 2704 0 0 2 4 this 3 3823  6 scalar 1 3614  </span>
<span class="s0">793 0 0 7 760 3822 2704 0 0 2 4 this 3 3823  6 scalar 1 3614  </span>
<span class="s0">794 0 0 6 761 3823 0 0 186 /**</span>
 <span class="s0">* Returns the origin of the indicated coordinate system.  This is always 0,</span>
 <span class="s0">* 0, 0 with all of our existing coordinate systems; it's hard to imagine it</span>
 <span class="s0">* ever being different.</span>
 <span class="s0">*/ 1 2 cs 5 3627  </span>
<span class="s0">795 0 0 7 762 3822 2704 0 146 /**</span>
 <span class="s0">* Returns a point described by right, forward, up displacements from the</span>
 <span class="s0">* origin, wherever that maps to in the given coordinate system.</span>
 <span class="s0">*/ 4 5 right 1 3614  3 fwd 1 3614  2 up 1 3614  2 cs 5 3627  </span>
<span class="s0">796 0 0 38 763 3762 0 0 0 1 4 this 3 3823  </span>
<span class="s0">797 0 0 7 764 3773 0 0 0 0 </span>
<span class="s0">798 0 0 7 768 3825 2783 0 0 0 </span>
<span class="s0">799 0 0 23 768 3825 2783 0 84 /**</span>
 <span class="s0">* Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.</span>
 <span class="s0">*/ 1 5 point 1 3817  </span>
<span class="s0">800 0 0 23 768 3825 2783 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3799  1 w 1 3608  </span>
<span class="s0">801 0 0 15 768 3825 2783 0 0 1 6 param0 0 3826  </span>
<span class="s0">802 0 0 23 768 3825 2783 0 85 /**</span>
 <span class="s0">* Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.</span>
 <span class="s0">*/ 1 6 vector 1 3808  </span>
<span class="s0">803 0 0 23 768 3825 2783 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3828  </span>
<span class="s0">804 0 0 23 768 3825 2783 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3608  </span>
<span class="s0">805 0 0 23 768 3825 2783 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  </span>
<span class="s0">806 0 0 4 769 3758 0 0 0 2 4 this 3 3825  4 size 1 3756  </span>
<span class="s0">807 0 0 6 772 3825 0 0 0 2 4 this 3 3825  4 copy 1 3826  </span>
<span class="s0">808 0 0 6 772 3825 0 0 0 2 4 this 3 3825  10 fill_value 1 3608  </span>
<span class="s0">809 0 0 6 773 3826 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">810 0 0 6 774 3826 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">811 0 0 6 775 3826 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">812 0 0 6 776 3826 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">813 0 0 6 777 3826 0 0 35 /**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">814 0 0 38 778 3759 0 0 0 1 4 this 3 3826  </span>
<span class="s0">815 0 0 38 779 3759 0 0 0 2 4 this 3 3826  9 attr_name 1 3762  </span>
<span class="s0">816 0 0 38 780 3614 0 0 0 3 4 this 3 3825  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">817 0 0 4 781 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3825  1 i 1 3614  10 assign_val 1 3608  </span>
<span class="s0">818 0 0 6 781 3608 0 0 0 2 4 this 3 3826  1 i 1 3614  </span>
<span class="s0">819 0 0 6 782 3614 0 0 0 0 </span>
<span class="s0">820 0 0 6 783 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">821 0 0 6 784 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3826  1 i 1 3614  </span>
<span class="s0">822 0 0 4 785 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3825  1 i 1 3614  5 value 1 3608  </span>
<span class="s0">823 0 0 6 786 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">824 0 0 6 787 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">825 0 0 6 788 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">826 0 0 6 789 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">827 0 0 7 790 3798 2388 0 58 /**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">828 0 0 7 791 3753 2082 0 55 /**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">829 0 0 4 792 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3825  5 value 1 3608  </span>
<span class="s0">830 0 0 4 793 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3825  5 value 1 3608  </span>
<span class="s0">831 0 0 4 794 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3825  5 value 1 3608  </span>
<span class="s0">832 0 0 4 795 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3825  5 value 1 3608  </span>
<span class="s0">833 0 0 4 801 3758 0 0 152 // These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages: 3 4 this 3 3825  1 i 1 3614  5 value 1 3608  </span>
<span class="s0">834 0 0 4 802 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3825  5 value 1 3608  </span>
<span class="s0">835 0 0 4 803 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3825  5 value 1 3608  </span>
<span class="s0">836 0 0 4 804 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3825  5 value 1 3608  </span>
<span class="s0">837 0 0 4 805 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3825  5 value 1 3608  </span>
<span class="s0">838 0 0 4 806 3758 0 0 161 /**</span>
 <span class="s0">* Returns the address of the first of the four data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">839 0 0 6 807 3614 0 0 0 0 </span>
<span class="s0">840 0 0 4 809 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3825  10 fill_value 1 3608  </span>
<span class="s0">841 0 0 4 810 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 4 this 3 3825  1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  </span>
<span class="s0">842 0 0 6 811 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3826  5 other 1 3826  </span>
<span class="s0">843 0 0 6 812 3608 0 0 69 /**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">844 0 0 6 813 3608 0 0 72 /**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">845 0 0 6 814 3763 0 0 127 /**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">846 0 0 7 815 3825 2783 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">847 0 0 7 816 3825 2783 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3826  4 onto 1 3826  </span>
<span class="s0">848 0 0 6 817 3763 0 0 0 2 4 this 3 3826  5 other 1 3826  </span>
<span class="s0">849 0 0 6 818 3763 0 0 0 2 4 this 3 3826  5 other 1 3826  </span>
<span class="s0">850 0 0 6 819 3763 0 0 0 2 4 this 3 3826  5 other 1 3826  </span>
<span class="s0">851 0 0 6 820 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3826  5 other 1 3826  </span>
<span class="s0">852 0 0 6 820 3614 0 0 233 /**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/ 3 4 this 3 3826  5 other 1 3826  9 threshold 1 3608  </span>
<span class="s0">853 0 0 6 821 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3826  </span>
<span class="s0">854 0 0 6 821 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 2 4 this 3 3826  9 threshold 1 3608  </span>
<span class="s0">855 0 0 6 822 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3826  4 hash 1 3756  </span>
<span class="s0">856 0 0 6 822 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 3 4 this 3 3826  4 hash 1 3756  9 threshold 1 3608  </span>
<span class="s0">857 0 0 4 823 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3826  7 hashgen 1 3764  </span>
<span class="s0">858 0 0 4 823 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 3 4 this 3 3826  7 hashgen 1 3764  9 threshold 1 3608  </span>
<span class="s0">859 0 0 7 824 3825 2783 0 0 1 4 this 3 3826  </span>
<span class="s0">860 0 0 7 825 3825 2783 0 0 2 4 this 3 3826  5 other 1 3826  </span>
<span class="s0">861 0 0 7 826 3825 2783 0 0 2 4 this 3 3826  5 other 1 3826  </span>
<span class="s0">862 0 0 7 827 3825 2783 0 0 2 4 this 3 3826  6 scalar 1 3608  </span>
<span class="s0">863 0 0 7 828 3825 2783 0 0 2 4 this 3 3826  6 scalar 1 3608  </span>
<span class="s0">864 0 0 6 829 3825 0 0 0 2 4 this 3 3825  5 other 1 3826  </span>
<span class="s0">865 0 0 6 830 3825 0 0 0 2 4 this 3 3825  5 other 1 3826  </span>
<span class="s0">866 0 0 6 831 3825 0 0 0 2 4 this 3 3825  6 scalar 1 3608  </span>
<span class="s0">867 0 0 6 832 3825 0 0 0 2 4 this 3 3825  6 scalar 1 3608  </span>
<span class="s0">868 0 0 4 833 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3825  5 other 1 3826  </span>
<span class="s0">869 0 0 38 834 3759 0 0 0 2 4 this 3 3826  6 scalar 1 3608  </span>
<span class="s0">870 0 0 38 835 3759 0 0 0 2 4 this 3 3825  6 scalar 1 3608  </span>
<span class="s0">871 0 0 38 836 3759 0 0 0 2 4 this 3 3826  8 exponent 1 3608  </span>
<span class="s0">872 0 0 38 837 3759 0 0 0 2 4 this 3 3825  8 exponent 1 3608  </span>
<span class="s0">873 0 0 38 838 3759 0 0 0 1 4 this 3 3825  </span>
<span class="s0">874 0 0 38 839 3759 0 0 0 1 4 this 3 3825  </span>
<span class="s0">875 0 0 38 840 3759 0 0 0 1 4 this 3 3825  </span>
<span class="s0">876 0 0 7 841 3825 2783 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3826  5 other 1 3826  </span>
<span class="s0">877 0 0 7 842 3825 2783 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3826  5 other 1 3826  </span>
<span class="s0">878 0 0 6 843 3763 0 0 116 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3826  5 other 1 3826  </span>
<span class="s0">879 0 0 6 843 3763 0 0 92 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3826  5 other 1 3826  9 threshold 1 3608  </span>
<span class="s0">880 0 0 4 844 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3826  3 out 1 3766  </span>
<span class="s0">881 0 0 38 845 3762 0 0 0 1 4 this 3 3826  </span>
<span class="s0">882 0 0 4 846 3758 0 0 332 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3826  11 destination 1 3768  </span>
<span class="s0">883 0 0 4 847 3758 0 0 114 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3825  6 source 1 3770  </span>
<span class="s0">884 0 0 4 848 3758 0 0 205 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3826  11 destination 1 3768  </span>
<span class="s0">885 0 0 4 849 3758 0 0 67 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3825  6 source 1 3770  </span>
<span class="s0">886 0 0 7 850 3773 0 0 0 0 </span>
<span class="s0">887 0 0 7 854 3830 2794 0 0 0 </span>
<span class="s0">888 0 0 23 854 3830 2794 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3826  </span>
<span class="s0">889 0 0 15 854 3830 2794 0 0 1 6 param0 0 3828  </span>
<span class="s0">890 0 0 23 854 3830 2794 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3608  </span>
<span class="s0">891 0 0 23 854 3830 2794 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  </span>
<span class="s0">892 0 0 4 855 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3830  10 fill_value 1 3608  </span>
<span class="s0">893 0 0 4 856 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 4 this 3 3830  1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  </span>
<span class="s0">894 0 0 4 857 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3830  1 i 1 3614  10 assign_val 1 3608  </span>
<span class="s0">895 0 0 6 857 3608 0 0 0 2 4 this 3 3828  1 i 1 3614  </span>
<span class="s0">896 0 0 6 858 3614 0 0 0 0 </span>
<span class="s0">897 0 0 4 859 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3828  </span>
<span class="s0">898 0 0 6 860 3614 0 0 0 0 </span>
<span class="s0">899 0 0 6 861 3763 0 0 0 2 4 this 3 3828  5 other 1 3828  </span>
<span class="s0">900 0 0 6 862 3763 0 0 0 2 4 this 3 3828  5 other 1 3828  </span>
<span class="s0">901 0 0 7 863 3773 0 0 0 0 </span>
<span class="s0">902 0 0 7 867 3831 2873 0 0 0 </span>
<span class="s0">903 0 0 23 867 3831 2873 0 84 /**</span>
 <span class="s0">* Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.</span>
 <span class="s0">*/ 1 5 point 1 3820  </span>
<span class="s0">904 0 0 23 867 3831 2873 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3802  1 w 1 3611  </span>
<span class="s0">905 0 0 15 867 3831 2873 0 0 1 6 param0 0 3832  </span>
<span class="s0">906 0 0 23 867 3831 2873 0 85 /**</span>
 <span class="s0">* Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.</span>
 <span class="s0">*/ 1 6 vector 1 3811  </span>
<span class="s0">907 0 0 23 867 3831 2873 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3834  </span>
<span class="s0">908 0 0 23 867 3831 2873 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3611  </span>
<span class="s0">909 0 0 23 867 3831 2873 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  </span>
<span class="s0">910 0 0 4 868 3758 0 0 0 2 4 this 3 3831  4 size 1 3756  </span>
<span class="s0">911 0 0 6 871 3831 0 0 0 2 4 this 3 3831  4 copy 1 3832  </span>
<span class="s0">912 0 0 6 871 3831 0 0 0 2 4 this 3 3831  10 fill_value 1 3611  </span>
<span class="s0">913 0 0 6 872 3832 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">914 0 0 6 873 3832 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">915 0 0 6 874 3832 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">916 0 0 6 875 3832 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">917 0 0 6 876 3832 0 0 35 /**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">918 0 0 38 877 3759 0 0 0 1 4 this 3 3832  </span>
<span class="s0">919 0 0 38 878 3759 0 0 0 2 4 this 3 3832  9 attr_name 1 3762  </span>
<span class="s0">920 0 0 38 879 3614 0 0 0 3 4 this 3 3831  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">921 0 0 4 880 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3831  1 i 1 3614  10 assign_val 1 3611  </span>
<span class="s0">922 0 0 6 880 3611 0 0 0 2 4 this 3 3832  1 i 1 3614  </span>
<span class="s0">923 0 0 6 881 3614 0 0 0 0 </span>
<span class="s0">924 0 0 6 882 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">925 0 0 6 883 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3832  1 i 1 3614  </span>
<span class="s0">926 0 0 4 884 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3831  1 i 1 3614  5 value 1 3611  </span>
<span class="s0">927 0 0 6 885 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">928 0 0 6 886 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">929 0 0 6 887 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">930 0 0 6 888 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">931 0 0 7 889 3801 2466 0 58 /**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">932 0 0 7 890 3774 2150 0 55 /**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">933 0 0 4 891 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3831  5 value 1 3611  </span>
<span class="s0">934 0 0 4 892 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3831  5 value 1 3611  </span>
<span class="s0">935 0 0 4 893 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3831  5 value 1 3611  </span>
<span class="s0">936 0 0 4 894 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3831  5 value 1 3611  </span>
<span class="s0">937 0 0 4 900 3758 0 0 152 // These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages: 3 4 this 3 3831  1 i 1 3614  5 value 1 3611  </span>
<span class="s0">938 0 0 4 901 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3831  5 value 1 3611  </span>
<span class="s0">939 0 0 4 902 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3831  5 value 1 3611  </span>
<span class="s0">940 0 0 4 903 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3831  5 value 1 3611  </span>
<span class="s0">941 0 0 4 904 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3831  5 value 1 3611  </span>
<span class="s0">942 0 0 4 905 3758 0 0 161 /**</span>
 <span class="s0">* Returns the address of the first of the four data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">943 0 0 6 906 3614 0 0 0 0 </span>
<span class="s0">944 0 0 4 908 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3831  10 fill_value 1 3611  </span>
<span class="s0">945 0 0 4 909 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 4 this 3 3831  1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  </span>
<span class="s0">946 0 0 6 910 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3832  5 other 1 3832  </span>
<span class="s0">947 0 0 6 911 3611 0 0 69 /**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">948 0 0 6 912 3611 0 0 72 /**</span>
 <span class="s0">* Returns the length of the vector, by the Pythagorean theorem.</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">949 0 0 6 913 3763 0 0 127 /**</span>
 <span class="s0">* Normalizes the vector in place.  Returns true if the vector was normalized,</span>
 <span class="s0">* false if it was a zero-length vector.</span>
 <span class="s0">*/ 1 4 this 3 3831  </span>
<span class="s0">950 0 0 7 914 3831 2873 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">951 0 0 7 915 3831 2873 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3832  4 onto 1 3832  </span>
<span class="s0">952 0 0 6 916 3763 0 0 0 2 4 this 3 3832  5 other 1 3832  </span>
<span class="s0">953 0 0 6 917 3763 0 0 0 2 4 this 3 3832  5 other 1 3832  </span>
<span class="s0">954 0 0 6 918 3763 0 0 0 2 4 this 3 3832  5 other 1 3832  </span>
<span class="s0">955 0 0 6 919 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3832  5 other 1 3832  </span>
<span class="s0">956 0 0 6 919 3614 0 0 233 /**</span>
 <span class="s0">* Sorts vectors lexicographically, componentwise.  Returns a number less than</span>
 <span class="s0">* 0 if this vector sorts before the other one, greater than zero if it sorts</span>
 <span class="s0">* after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/ 3 4 this 3 3832  5 other 1 3832  9 threshold 1 3611  </span>
<span class="s0">957 0 0 6 920 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3832  </span>
<span class="s0">958 0 0 6 920 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 2 4 this 3 3832  9 threshold 1 3611  </span>
<span class="s0">959 0 0 6 921 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3832  4 hash 1 3756  </span>
<span class="s0">960 0 0 6 921 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 3 4 this 3 3832  4 hash 1 3756  9 threshold 1 3611  </span>
<span class="s0">961 0 0 4 922 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3832  7 hashgen 1 3764  </span>
<span class="s0">962 0 0 4 922 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 3 4 this 3 3832  7 hashgen 1 3764  9 threshold 1 3611  </span>
<span class="s0">963 0 0 7 923 3831 2873 0 0 1 4 this 3 3832  </span>
<span class="s0">964 0 0 7 924 3831 2873 0 0 2 4 this 3 3832  5 other 1 3832  </span>
<span class="s0">965 0 0 7 925 3831 2873 0 0 2 4 this 3 3832  5 other 1 3832  </span>
<span class="s0">966 0 0 7 926 3831 2873 0 0 2 4 this 3 3832  6 scalar 1 3611  </span>
<span class="s0">967 0 0 7 927 3831 2873 0 0 2 4 this 3 3832  6 scalar 1 3611  </span>
<span class="s0">968 0 0 6 928 3831 0 0 0 2 4 this 3 3831  5 other 1 3832  </span>
<span class="s0">969 0 0 6 929 3831 0 0 0 2 4 this 3 3831  5 other 1 3832  </span>
<span class="s0">970 0 0 6 930 3831 0 0 0 2 4 this 3 3831  6 scalar 1 3611  </span>
<span class="s0">971 0 0 6 931 3831 0 0 0 2 4 this 3 3831  6 scalar 1 3611  </span>
<span class="s0">972 0 0 4 932 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3831  5 other 1 3832  </span>
<span class="s0">973 0 0 38 933 3759 0 0 0 2 4 this 3 3832  6 scalar 1 3611  </span>
<span class="s0">974 0 0 38 934 3759 0 0 0 2 4 this 3 3831  6 scalar 1 3611  </span>
<span class="s0">975 0 0 38 935 3759 0 0 0 2 4 this 3 3832  8 exponent 1 3611  </span>
<span class="s0">976 0 0 38 936 3759 0 0 0 2 4 this 3 3831  8 exponent 1 3611  </span>
<span class="s0">977 0 0 38 937 3759 0 0 0 1 4 this 3 3831  </span>
<span class="s0">978 0 0 38 938 3759 0 0 0 1 4 this 3 3831  </span>
<span class="s0">979 0 0 38 939 3759 0 0 0 1 4 this 3 3831  </span>
<span class="s0">980 0 0 7 940 3831 2873 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3832  5 other 1 3832  </span>
<span class="s0">981 0 0 7 941 3831 2873 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3832  5 other 1 3832  </span>
<span class="s0">982 0 0 6 942 3763 0 0 116 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3832  5 other 1 3832  </span>
<span class="s0">983 0 0 6 942 3763 0 0 92 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3832  5 other 1 3832  9 threshold 1 3611  </span>
<span class="s0">984 0 0 4 943 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3832  3 out 1 3766  </span>
<span class="s0">985 0 0 38 944 3762 0 0 0 1 4 this 3 3832  </span>
<span class="s0">986 0 0 4 945 3758 0 0 332 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3832  11 destination 1 3768  </span>
<span class="s0">987 0 0 4 946 3758 0 0 114 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3831  6 source 1 3770  </span>
<span class="s0">988 0 0 4 947 3758 0 0 205 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3832  11 destination 1 3768  </span>
<span class="s0">989 0 0 4 948 3758 0 0 67 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3831  6 source 1 3770  </span>
<span class="s0">990 0 0 7 949 3773 0 0 0 0 </span>
<span class="s0">991 0 0 7 953 3836 2884 0 0 0 </span>
<span class="s0">992 0 0 23 953 3836 2884 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3832  </span>
<span class="s0">993 0 0 15 953 3836 2884 0 0 1 6 param0 0 3834  </span>
<span class="s0">994 0 0 23 953 3836 2884 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3611  </span>
<span class="s0">995 0 0 23 953 3836 2884 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  </span>
<span class="s0">996 0 0 4 954 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3836  10 fill_value 1 3611  </span>
<span class="s0">997 0 0 4 955 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 4 this 3 3836  1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  </span>
<span class="s0">998 0 0 4 956 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3836  1 i 1 3614  10 assign_val 1 3611  </span>
<span class="s0">999 0 0 6 956 3611 0 0 0 2 4 this 3 3834  1 i 1 3614  </span>
<span class="s0">1000 0 0 6 957 3614 0 0 0 0 </span>
<span class="s0">1001 0 0 4 958 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3834  </span>
<span class="s0">1002 0 0 6 959 3614 0 0 0 0 </span>
<span class="s0">1003 0 0 6 960 3763 0 0 0 2 4 this 3 3834  5 other 1 3834  </span>
<span class="s0">1004 0 0 6 961 3763 0 0 0 2 4 this 3 3834  5 other 1 3834  </span>
<span class="s0">1005 0 0 7 962 3773 0 0 0 0 </span>
<span class="s0">1006 0 0 7 966 3837 2959 0 0 0 </span>
<span class="s0">1007 0 0 23 966 3837 2959 0 84 /**</span>
 <span class="s0">* Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.</span>
 <span class="s0">*/ 1 5 point 1 3823  </span>
<span class="s0">1008 0 0 23 966 3837 2959 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3805  1 w 1 3614  </span>
<span class="s0">1009 0 0 15 966 3837 2959 0 0 1 6 param0 0 3838  </span>
<span class="s0">1010 0 0 23 966 3837 2959 0 85 /**</span>
 <span class="s0">* Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.</span>
 <span class="s0">*/ 1 6 vector 1 3814  </span>
<span class="s0">1011 0 0 23 966 3837 2959 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3840  </span>
<span class="s0">1012 0 0 23 966 3837 2959 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3614  </span>
<span class="s0">1013 0 0 23 966 3837 2959 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  </span>
<span class="s0">1014 0 0 4 967 3758 0 0 0 2 4 this 3 3837  4 size 1 3756  </span>
<span class="s0">1015 0 0 6 970 3837 0 0 0 2 4 this 3 3837  4 copy 1 3838  </span>
<span class="s0">1016 0 0 6 970 3837 0 0 0 2 4 this 3 3837  10 fill_value 1 3614  </span>
<span class="s0">1017 0 0 6 971 3838 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1018 0 0 6 972 3838 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1019 0 0 6 973 3838 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1020 0 0 6 974 3838 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1021 0 0 6 975 3838 0 0 35 /**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1022 0 0 38 976 3759 0 0 0 1 4 this 3 3838  </span>
<span class="s0">1023 0 0 38 977 3759 0 0 0 2 4 this 3 3838  9 attr_name 1 3762  </span>
<span class="s0">1024 0 0 38 978 3614 0 0 0 3 4 this 3 3837  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">1025 0 0 4 979 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3837  1 i 1 3614  10 assign_val 1 3614  </span>
<span class="s0">1026 0 0 6 979 3614 0 0 0 2 4 this 3 3838  1 i 1 3614  </span>
<span class="s0">1027 0 0 6 980 3614 0 0 0 0 </span>
<span class="s0">1028 0 0 6 981 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the vector is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3838  </span>
<span class="s0">1029 0 0 6 982 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3838  1 i 1 3614  </span>
<span class="s0">1030 0 0 4 983 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3837  1 i 1 3614  5 value 1 3614  </span>
<span class="s0">1031 0 0 6 984 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3838  </span>
<span class="s0">1032 0 0 6 985 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3838  </span>
<span class="s0">1033 0 0 6 986 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3838  </span>
<span class="s0">1034 0 0 6 987 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3838  </span>
<span class="s0">1035 0 0 7 988 3804 2539 0 58 /**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3838  </span>
<span class="s0">1036 0 0 7 989 3777 2214 0 55 /**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3838  </span>
<span class="s0">1037 0 0 4 990 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3837  5 value 1 3614  </span>
<span class="s0">1038 0 0 4 991 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3837  5 value 1 3614  </span>
<span class="s0">1039 0 0 4 992 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3837  5 value 1 3614  </span>
<span class="s0">1040 0 0 4 993 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3837  5 value 1 3614  </span>
<span class="s0">1041 0 0 4 999 3758 0 0 152 // These next functions add to an existing value.  i.e.</span>
<span class="s0">// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in</span>
<span class="s0">// scripting languages: 3 4 this 3 3837  1 i 1 3614  5 value 1 3614  </span>
<span class="s0">1042 0 0 4 1000 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3837  5 value 1 3614  </span>
<span class="s0">1043 0 0 4 1001 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3837  5 value 1 3614  </span>
<span class="s0">1044 0 0 4 1002 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3837  5 value 1 3614  </span>
<span class="s0">1045 0 0 4 1003 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3837  5 value 1 3614  </span>
<span class="s0">1046 0 0 4 1004 3758 0 0 161 /**</span>
 <span class="s0">* Returns the address of the first of the four data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3838  </span>
<span class="s0">1047 0 0 6 1005 3614 0 0 0 0 </span>
<span class="s0">1048 0 0 4 1007 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3837  10 fill_value 1 3614  </span>
<span class="s0">1049 0 0 4 1008 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 4 this 3 3837  1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  </span>
<span class="s0">1050 0 0 6 1009 3614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3838  5 other 1 3838  </span>
<span class="s0">1051 0 0 6 1010 3614 0 0 69 /**</span>
 <span class="s0">* Returns the square of the vector's length, cheap and easy.</span>
 <span class="s0">*/ 1 4 this 3 3838  </span>
<span class="s0">1052 0 0 6 1011 3763 0 0 0 2 4 this 3 3838  5 other 1 3838  </span>
<span class="s0">1053 0 0 6 1012 3763 0 0 0 2 4 this 3 3838  5 other 1 3838  </span>
<span class="s0">1054 0 0 6 1013 3763 0 0 0 2 4 this 3 3838  5 other 1 3838  </span>
<span class="s0">1055 0 0 6 1014 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3838  5 other 1 3838  </span>
<span class="s0">1056 0 0 6 1015 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3838  </span>
<span class="s0">1057 0 0 6 1016 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3838  4 hash 1 3756  </span>
<span class="s0">1058 0 0 4 1017 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3838  7 hashgen 1 3764  </span>
<span class="s0">1059 0 0 7 1018 3837 2959 0 0 1 4 this 3 3838  </span>
<span class="s0">1060 0 0 7 1019 3837 2959 0 0 2 4 this 3 3838  5 other 1 3838  </span>
<span class="s0">1061 0 0 7 1020 3837 2959 0 0 2 4 this 3 3838  5 other 1 3838  </span>
<span class="s0">1062 0 0 7 1021 3837 2959 0 0 2 4 this 3 3838  6 scalar 1 3614  </span>
<span class="s0">1063 0 0 7 1022 3837 2959 0 0 2 4 this 3 3838  6 scalar 1 3614  </span>
<span class="s0">1064 0 0 6 1023 3837 0 0 0 2 4 this 3 3837  5 other 1 3838  </span>
<span class="s0">1065 0 0 6 1024 3837 0 0 0 2 4 this 3 3837  5 other 1 3838  </span>
<span class="s0">1066 0 0 6 1025 3837 0 0 0 2 4 this 3 3837  6 scalar 1 3614  </span>
<span class="s0">1067 0 0 6 1026 3837 0 0 0 2 4 this 3 3837  6 scalar 1 3614  </span>
<span class="s0">1068 0 0 4 1027 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3837  5 other 1 3838  </span>
<span class="s0">1069 0 0 38 1028 3759 0 0 0 2 4 this 3 3838  6 scalar 1 3614  </span>
<span class="s0">1070 0 0 38 1029 3759 0 0 0 2 4 this 3 3837  6 scalar 1 3614  </span>
<span class="s0">1071 0 0 38 1030 3759 0 0 0 2 4 this 3 3838  8 exponent 1 3614  </span>
<span class="s0">1072 0 0 38 1031 3759 0 0 0 2 4 this 3 3837  8 exponent 1 3614  </span>
<span class="s0">1073 0 0 38 1032 3759 0 0 0 1 4 this 3 3837  </span>
<span class="s0">1074 0 0 38 1033 3759 0 0 0 1 4 this 3 3837  </span>
<span class="s0">1075 0 0 38 1034 3759 0 0 0 1 4 this 3 3837  </span>
<span class="s0">1076 0 0 7 1035 3837 2959 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3838  5 other 1 3838  </span>
<span class="s0">1077 0 0 7 1036 3837 2959 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3838  5 other 1 3838  </span>
<span class="s0">1078 0 0 6 1037 3763 0 0 116 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a default tolerance</span>
 <span class="s0">* based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3838  5 other 1 3838  </span>
<span class="s0">1079 0 0 6 1037 3763 0 0 92 /**</span>
 <span class="s0">* Returns true if two vectors are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3838  5 other 1 3838  9 threshold 1 3614  </span>
<span class="s0">1080 0 0 4 1038 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3838  3 out 1 3766  </span>
<span class="s0">1081 0 0 38 1039 3762 0 0 0 1 4 this 3 3838  </span>
<span class="s0">1082 0 0 4 1040 3758 0 0 332 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the vector, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3838  11 destination 1 3768  </span>
<span class="s0">1083 0 0 4 1041 3758 0 0 114 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3837  6 source 1 3770  </span>
<span class="s0">1084 0 0 4 1042 3758 0 0 205 /**</span>
 <span class="s0">* Writes the vector to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the vector using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3838  11 destination 1 3768  </span>
<span class="s0">1085 0 0 4 1043 3758 0 0 67 /**</span>
 <span class="s0">* Reads the vector from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3837  6 source 1 3770  </span>
<span class="s0">1086 0 0 7 1044 3773 0 0 0 0 </span>
<span class="s0">1087 0 0 7 1048 3842 2970 0 0 0 </span>
<span class="s0">1088 0 0 23 1048 3842 2970 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3838  </span>
<span class="s0">1089 0 0 15 1048 3842 2970 0 0 1 6 param0 0 3840  </span>
<span class="s0">1090 0 0 23 1048 3842 2970 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3614  </span>
<span class="s0">1091 0 0 23 1048 3842 2970 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  </span>
<span class="s0">1092 0 0 4 1049 3758 0 0 129 /**</span>
 <span class="s0">* Sets each element of the vector to the indicated fill_value.  This is</span>
 <span class="s0">* particularly useful for initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3842  10 fill_value 1 3614  </span>
<span class="s0">1093 0 0 4 1050 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 4 this 3 3842  1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  </span>
<span class="s0">1094 0 0 4 1051 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3842  1 i 1 3614  10 assign_val 1 3614  </span>
<span class="s0">1095 0 0 6 1051 3614 0 0 0 2 4 this 3 3840  1 i 1 3614  </span>
<span class="s0">1096 0 0 6 1052 3614 0 0 0 0 </span>
<span class="s0">1097 0 0 4 1053 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the three data elements in the vector.</span>
 <span class="s0">* The remaining elements occupy the next positions consecutively in memory.</span>
 <span class="s0">*/ 1 4 this 3 3840  </span>
<span class="s0">1098 0 0 6 1054 3614 0 0 0 0 </span>
<span class="s0">1099 0 0 6 1055 3763 0 0 0 2 4 this 3 3840  5 other 1 3840  </span>
<span class="s0">1100 0 0 6 1056 3763 0 0 0 2 4 this 3 3840  5 other 1 3840  </span>
<span class="s0">1101 0 0 7 1057 3773 0 0 0 0 </span>
<span class="s0">1102 0 0 7 1060 3843 2990 0 0 0 </span>
<span class="s0">1103 0 0 23 1060 3843 2990 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3799  1 w 1 3608  </span>
<span class="s0">1104 0 0 23 1060 3843 2990 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3826  </span>
<span class="s0">1105 0 0 15 1060 3843 2990 0 0 1 6 param0 0 3844  </span>
<span class="s0">1106 0 0 23 1060 3843 2990 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3608  </span>
<span class="s0">1107 0 0 23 1060 3843 2990 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  </span>
<span class="s0">1108 0 0 38 1061 3759 0 0 0 2 4 this 3 3844  9 attr_name 1 3762  </span>
<span class="s0">1109 0 0 38 1062 3614 0 0 0 3 4 this 3 3843  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">1110 0 0 6 1063 3844 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1111 0 0 6 1064 3844 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1112 0 0 6 1065 3844 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1113 0 0 6 1066 3844 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1114 0 0 6 1067 3844 0 0 35 /**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1115 0 0 7 1068 3807 2577 0 58 /**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3844  </span>
<span class="s0">1116 0 0 7 1069 3780 2232 0 55 /**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3844  </span>
<span class="s0">1117 0 0 7 1072 3843 2990 0 0 1 4 this 3 3844  </span>
<span class="s0">1118 0 0 7 1073 3825 2783 0 0 2 4 this 3 3844  5 other 1 3826  </span>
<span class="s0">1119 0 0 7 1073 3843 2990 0 0 2 4 this 3 3844  5 other 1 3844  </span>
<span class="s0">1120 0 0 7 1074 3825 2783 0 0 2 4 this 3 3844  5 other 1 3826  </span>
<span class="s0">1121 0 0 7 1074 3843 2990 0 0 2 4 this 3 3844  5 other 1 3844  </span>
<span class="s0">1122 0 0 7 1075 3843 2990 0 0 2 4 this 3 3844  6 scalar 1 3608  </span>
<span class="s0">1123 0 0 7 1076 3843 2990 0 0 2 4 this 3 3844  6 scalar 1 3608  </span>
<span class="s0">1124 0 0 7 1077 3843 2990 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3844  </span>
<span class="s0">1125 0 0 7 1078 3843 2990 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3844  4 onto 1 3826  </span>
<span class="s0">1126 0 0 38 1079 3762 0 0 0 1 4 this 3 3844  </span>
<span class="s0">1127 0 0 7 1080 3773 0 0 0 0 </span>
<span class="s0">1128 0 0 7 1083 3846 3010 0 0 0 </span>
<span class="s0">1129 0 0 23 1083 3846 3010 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3802  1 w 1 3611  </span>
<span class="s0">1130 0 0 23 1083 3846 3010 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3832  </span>
<span class="s0">1131 0 0 15 1083 3846 3010 0 0 1 6 param0 0 3847  </span>
<span class="s0">1132 0 0 23 1083 3846 3010 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3611  </span>
<span class="s0">1133 0 0 23 1083 3846 3010 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  </span>
<span class="s0">1134 0 0 38 1084 3759 0 0 0 2 4 this 3 3847  9 attr_name 1 3762  </span>
<span class="s0">1135 0 0 38 1085 3614 0 0 0 3 4 this 3 3846  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">1136 0 0 6 1086 3847 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1137 0 0 6 1087 3847 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1138 0 0 6 1088 3847 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1139 0 0 6 1089 3847 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1140 0 0 6 1090 3847 0 0 35 /**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1141 0 0 7 1091 3810 2611 0 58 /**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3847  </span>
<span class="s0">1142 0 0 7 1092 3783 2250 0 55 /**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3847  </span>
<span class="s0">1143 0 0 7 1095 3846 3010 0 0 1 4 this 3 3847  </span>
<span class="s0">1144 0 0 7 1096 3831 2873 0 0 2 4 this 3 3847  5 other 1 3832  </span>
<span class="s0">1145 0 0 7 1096 3846 3010 0 0 2 4 this 3 3847  5 other 1 3847  </span>
<span class="s0">1146 0 0 7 1097 3831 2873 0 0 2 4 this 3 3847  5 other 1 3832  </span>
<span class="s0">1147 0 0 7 1097 3846 3010 0 0 2 4 this 3 3847  5 other 1 3847  </span>
<span class="s0">1148 0 0 7 1098 3846 3010 0 0 2 4 this 3 3847  6 scalar 1 3611  </span>
<span class="s0">1149 0 0 7 1099 3846 3010 0 0 2 4 this 3 3847  6 scalar 1 3611  </span>
<span class="s0">1150 0 0 7 1100 3846 3010 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3847  </span>
<span class="s0">1151 0 0 7 1101 3846 3010 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3847  4 onto 1 3832  </span>
<span class="s0">1152 0 0 38 1102 3762 0 0 0 1 4 this 3 3847  </span>
<span class="s0">1153 0 0 7 1103 3773 0 0 0 0 </span>
<span class="s0">1154 0 0 7 1106 3849 3028 0 0 0 </span>
<span class="s0">1155 0 0 23 1106 3849 3028 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3805  1 w 1 3614  </span>
<span class="s0">1156 0 0 23 1106 3849 3028 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3838  </span>
<span class="s0">1157 0 0 15 1106 3849 3028 0 0 1 6 param0 0 3850  </span>
<span class="s0">1158 0 0 23 1106 3849 3028 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3614  </span>
<span class="s0">1159 0 0 23 1106 3849 3028 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  </span>
<span class="s0">1160 0 0 38 1107 3759 0 0 0 2 4 this 3 3850  9 attr_name 1 3762  </span>
<span class="s0">1161 0 0 38 1108 3614 0 0 0 3 4 this 3 3849  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">1162 0 0 6 1109 3850 0 0 40 /**</span>
 <span class="s0">* Returns a zero-length vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1163 0 0 6 1110 3850 0 0 35 /**</span>
 <span class="s0">* Returns a unit X vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1164 0 0 6 1111 3850 0 0 35 /**</span>
 <span class="s0">* Returns a unit Y vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1165 0 0 6 1112 3850 0 0 35 /**</span>
 <span class="s0">* Returns a unit Z vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1166 0 0 6 1113 3850 0 0 35 /**</span>
 <span class="s0">* Returns a unit W vector.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1167 0 0 7 1114 3813 2637 0 58 /**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3850  </span>
<span class="s0">1168 0 0 7 1115 3786 2264 0 55 /**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3850  </span>
<span class="s0">1169 0 0 7 1118 3849 3028 0 0 1 4 this 3 3850  </span>
<span class="s0">1170 0 0 7 1119 3837 2959 0 0 2 4 this 3 3850  5 other 1 3838  </span>
<span class="s0">1171 0 0 7 1119 3849 3028 0 0 2 4 this 3 3850  5 other 1 3850  </span>
<span class="s0">1172 0 0 7 1120 3837 2959 0 0 2 4 this 3 3850  5 other 1 3838  </span>
<span class="s0">1173 0 0 7 1120 3849 3028 0 0 2 4 this 3 3850  5 other 1 3850  </span>
<span class="s0">1174 0 0 7 1121 3849 3028 0 0 2 4 this 3 3850  6 scalar 1 3614  </span>
<span class="s0">1175 0 0 7 1122 3849 3028 0 0 2 4 this 3 3850  6 scalar 1 3614  </span>
<span class="s0">1176 0 0 38 1123 3762 0 0 0 1 4 this 3 3850  </span>
<span class="s0">1177 0 0 7 1124 3773 0 0 0 0 </span>
<span class="s0">1178 0 0 7 1127 3852 3048 0 0 0 </span>
<span class="s0">1179 0 0 15 1127 3852 3048 0 0 1 6 param0 0 3853  </span>
<span class="s0">1180 0 0 23 1127 3852 3048 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3799  1 w 1 3608  </span>
<span class="s0">1181 0 0 23 1127 3852 3048 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3826  </span>
<span class="s0">1182 0 0 23 1127 3852 3048 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3608  </span>
<span class="s0">1183 0 0 23 1127 3852 3048 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  </span>
<span class="s0">1184 0 0 38 1128 3759 0 0 0 2 4 this 3 3853  9 attr_name 1 3762  </span>
<span class="s0">1185 0 0 38 1129 3614 0 0 0 3 4 this 3 3852  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">1186 0 0 6 1130 3853 0 0 39 /**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1187 0 0 6 1131 3853 0 0 34 /**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1188 0 0 6 1132 3853 0 0 34 /**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1189 0 0 6 1133 3853 0 0 34 /**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1190 0 0 6 1134 3853 0 0 34 /**</span>
 <span class="s0">* Returns a unit W point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1191 0 0 7 1135 3816 2660 0 58 /**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3853  </span>
<span class="s0">1192 0 0 7 1136 3789 2280 0 55 /**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3853  </span>
<span class="s0">1193 0 0 7 1139 3852 3048 0 0 1 4 this 3 3853  </span>
<span class="s0">1194 0 0 7 1140 3825 2783 0 0 2 4 this 3 3853  5 other 1 3826  </span>
<span class="s0">1195 0 0 7 1140 3852 3048 0 0 2 4 this 3 3853  5 other 1 3844  </span>
<span class="s0">1196 0 0 7 1141 3843 2990 0 0 2 4 this 3 3853  5 other 1 3853  </span>
<span class="s0">1197 0 0 7 1141 3825 2783 0 0 2 4 this 3 3853  5 other 1 3826  </span>
<span class="s0">1198 0 0 7 1141 3852 3048 0 0 2 4 this 3 3853  5 other 1 3844  </span>
<span class="s0">1199 0 0 7 1142 3852 3048 0 0 2 4 this 3 3853  6 scalar 1 3608  </span>
<span class="s0">1200 0 0 7 1143 3852 3048 0 0 2 4 this 3 3853  6 scalar 1 3608  </span>
<span class="s0">1201 0 0 7 1144 3852 3048 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3853  </span>
<span class="s0">1202 0 0 7 1145 3852 3048 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3853  4 onto 1 3826  </span>
<span class="s0">1203 0 0 38 1146 3762 0 0 0 1 4 this 3 3853  </span>
<span class="s0">1204 0 0 7 1147 3773 0 0 0 0 </span>
<span class="s0">1205 0 0 7 1150 3855 3068 0 0 0 </span>
<span class="s0">1206 0 0 15 1150 3855 3068 0 0 1 6 param0 0 3856  </span>
<span class="s0">1207 0 0 23 1150 3855 3068 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3802  1 w 1 3611  </span>
<span class="s0">1208 0 0 23 1150 3855 3068 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3832  </span>
<span class="s0">1209 0 0 23 1150 3855 3068 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3611  </span>
<span class="s0">1210 0 0 23 1150 3855 3068 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  </span>
<span class="s0">1211 0 0 38 1151 3759 0 0 0 2 4 this 3 3856  9 attr_name 1 3762  </span>
<span class="s0">1212 0 0 38 1152 3614 0 0 0 3 4 this 3 3855  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">1213 0 0 6 1153 3856 0 0 39 /**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1214 0 0 6 1154 3856 0 0 34 /**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1215 0 0 6 1155 3856 0 0 34 /**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1216 0 0 6 1156 3856 0 0 34 /**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1217 0 0 6 1157 3856 0 0 34 /**</span>
 <span class="s0">* Returns a unit W point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1218 0 0 7 1158 3819 2683 0 58 /**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3856  </span>
<span class="s0">1219 0 0 7 1159 3792 2296 0 55 /**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3856  </span>
<span class="s0">1220 0 0 7 1162 3855 3068 0 0 1 4 this 3 3856  </span>
<span class="s0">1221 0 0 7 1163 3831 2873 0 0 2 4 this 3 3856  5 other 1 3832  </span>
<span class="s0">1222 0 0 7 1163 3855 3068 0 0 2 4 this 3 3856  5 other 1 3847  </span>
<span class="s0">1223 0 0 7 1164 3846 3010 0 0 2 4 this 3 3856  5 other 1 3856  </span>
<span class="s0">1224 0 0 7 1164 3831 2873 0 0 2 4 this 3 3856  5 other 1 3832  </span>
<span class="s0">1225 0 0 7 1164 3855 3068 0 0 2 4 this 3 3856  5 other 1 3847  </span>
<span class="s0">1226 0 0 7 1165 3855 3068 0 0 2 4 this 3 3856  6 scalar 1 3611  </span>
<span class="s0">1227 0 0 7 1166 3855 3068 0 0 2 4 this 3 3856  6 scalar 1 3611  </span>
<span class="s0">1228 0 0 7 1167 3855 3068 0 160 /**</span>
 <span class="s0">* Normalizes the vector and returns the normalized vector as a copy.  If the</span>
 <span class="s0">* vector was a zero-length vector, a zero length vector will be returned.</span>
 <span class="s0">*/ 1 4 this 3 3856  </span>
<span class="s0">1229 0 0 7 1168 3855 3068 0 152 /**</span>
 <span class="s0">* Returns a new vector representing the projection of this vector onto</span>
 <span class="s0">* another one.  The resulting vector will be a scalar multiple of onto.</span>
 <span class="s0">*/ 2 4 this 3 3856  4 onto 1 3832  </span>
<span class="s0">1230 0 0 38 1169 3762 0 0 0 1 4 this 3 3856  </span>
<span class="s0">1231 0 0 7 1170 3773 0 0 0 0 </span>
<span class="s0">1232 0 0 7 1173 3858 3086 0 0 0 </span>
<span class="s0">1233 0 0 15 1173 3858 3086 0 0 1 6 param0 0 3859  </span>
<span class="s0">1234 0 0 23 1173 3858 3086 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 copy 1 3805  1 w 1 3614  </span>
<span class="s0">1235 0 0 23 1173 3858 3086 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3838  </span>
<span class="s0">1236 0 0 23 1173 3858 3086 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 fill_value 1 3614  </span>
<span class="s0">1237 0 0 23 1173 3858 3086 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  </span>
<span class="s0">1238 0 0 38 1174 3759 0 0 0 2 4 this 3 3859  9 attr_name 1 3762  </span>
<span class="s0">1239 0 0 38 1175 3614 0 0 0 3 4 this 3 3858  9 attr_name 1 3762  6 assign 1 3759  </span>
<span class="s0">1240 0 0 6 1176 3859 0 0 39 /**</span>
 <span class="s0">* Returns a zero-length point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1241 0 0 6 1177 3859 0 0 34 /**</span>
 <span class="s0">* Returns a unit X point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1242 0 0 6 1178 3859 0 0 34 /**</span>
 <span class="s0">* Returns a unit Y point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1243 0 0 6 1179 3859 0 0 34 /**</span>
 <span class="s0">* Returns a unit Z point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1244 0 0 6 1180 3859 0 0 34 /**</span>
 <span class="s0">* Returns a unit W point.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1245 0 0 7 1181 3822 2704 0 58 /**</span>
 <span class="s0">* Returns the x, y and z component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3859  </span>
<span class="s0">1246 0 0 7 1182 3795 2310 0 55 /**</span>
 <span class="s0">* Returns the x and y component of this vector</span>
 <span class="s0">*/ 1 4 this 3 3859  </span>
<span class="s0">1247 0 0 7 1185 3858 3086 0 0 1 4 this 3 3859  </span>
<span class="s0">1248 0 0 7 1186 3837 2959 0 0 2 4 this 3 3859  5 other 1 3838  </span>
<span class="s0">1249 0 0 7 1186 3858 3086 0 0 2 4 this 3 3859  5 other 1 3850  </span>
<span class="s0">1250 0 0 7 1187 3849 3028 0 0 2 4 this 3 3859  5 other 1 3859  </span>
<span class="s0">1251 0 0 7 1187 3837 2959 0 0 2 4 this 3 3859  5 other 1 3838  </span>
<span class="s0">1252 0 0 7 1187 3858 3086 0 0 2 4 this 3 3859  5 other 1 3850  </span>
<span class="s0">1253 0 0 7 1188 3858 3086 0 0 2 4 this 3 3859  6 scalar 1 3614  </span>
<span class="s0">1254 0 0 7 1189 3858 3086 0 0 2 4 this 3 3859  6 scalar 1 3614  </span>
<span class="s0">1255 0 0 38 1190 3762 0 0 0 1 4 this 3 3859  </span>
<span class="s0">1256 0 0 7 1191 3773 0 0 0 0 </span>
<span class="s0">1257 0 0 7 1207 3861 3172 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1258 0 0 15 1207 3861 3172 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 5 other 1 3862  </span>
<span class="s0">1259 0 0 23 1207 3861 3172 0 60 /**</span>
 <span class="s0">* Constructs the matrix from three individual rows.</span>
 <span class="s0">*/ 3 6 param0 0 3799  6 param1 0 3799  6 param2 0 3799  </span>
<span class="s0">1260 0 0 23 1207 3861 3172 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 9 6 param0 0 3608  6 param1 0 3608  6 param2 0 3608  6 param3 0 3608  6 param4 0 3608  6 param5 0 3608  6 param6 0 3608  6 param7 0 3608  6 param8 0 3608  </span>
<span class="s0">1261 0 0 6 1208 3861 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3861  5 other 1 3862  </span>
<span class="s0">1262 0 0 6 1208 3861 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3861  10 fill_value 1 3608  </span>
<span class="s0">1263 0 0 4 1209 3758 0 0 0 2 4 this 3 3861  4 size 1 3756  </span>
<span class="s0">1264 0 0 38 1212 3759 0 0 0 1 4 this 3 3862  </span>
<span class="s0">1265 0 0 4 1213 3758 0 0 157 /**</span>
 <span class="s0">* Sets each element of the matrix to the indicated fill_value.  This is of</span>
 <span class="s0">* questionable value, but is sometimes useful when initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3861  10 fill_value 1 3608  </span>
<span class="s0">1266 0 0 4 1214 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 10 4 this 3 3861  3 e00 1 3608  3 e01 1 3608  3 e02 1 3608  3 e10 1 3608  3 e11 1 3608  3 e12 1 3608  3 e20 1 3608  3 e21 1 3608  3 e22 1 3608  </span>
<span class="s0">1267 0 0 7 1215 3864 3091 0 0 2 4 this 3 3861  1 i 1 3614  </span>
<span class="s0">1268 0 0 7 1215 3865 3096 0 0 2 4 this 3 3862  1 i 1 3614  </span>
<span class="s0">1269 0 0 6 1216 3614 0 0 55 /**</span>
 <span class="s0">* Returns 3: the number of rows of a LMatrix3.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1270 0 0 4 1217 3758 0 0 109 /**</span>
 <span class="s0">* Replaces the indicated row of the matrix from a two-component vector,</span>
 <span class="s0">* ignoring the last column.</span>
 <span class="s0">*/ 3 4 this 3 3861  3 row 1 3614  1 v 1 3754  </span>
<span class="s0">1271 0 0 4 1217 3758 0 0 82 /**</span>
 <span class="s0">* Replaces the indicated row of the matrix from a three-component vector.</span>
 <span class="s0">*/ 3 4 this 3 3861  3 row 1 3614  1 v 1 3799  </span>
<span class="s0">1272 0 0 4 1218 3758 0 0 109 /**</span>
 <span class="s0">* Replaces the indicated column of the matrix from a two-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/ 3 4 this 3 3861  3 col 1 3614  1 v 1 3754  </span>
<span class="s0">1273 0 0 4 1218 3758 0 0 85 /**</span>
 <span class="s0">* Replaces the indicated column of the matrix from a three-component vector.</span>
 <span class="s0">*/ 3 4 this 3 3861  3 col 1 3614  1 v 1 3799  </span>
<span class="s0">1274 0 0 4 1219 3758 0 0 78 /**</span>
 <span class="s0">* Stores the indicated row of the matrix as a three-component vector.</span>
 <span class="s0">*/ 3 4 this 3 3862  10 result_vec 1 3798  3 row 1 3614  </span>
<span class="s0">1275 0 0 7 1219 3798 2388 0 79 /**</span>
 <span class="s0">* Returns the indicated row of the matrix as a three-component vector.</span>
 <span class="s0">*/ 2 4 this 3 3862  3 row 1 3614  </span>
<span class="s0">1276 0 0 7 1220 3798 2388 0 82 /**</span>
 <span class="s0">* Returns the indicated column of the matrix as a three-component vector.</span>
 <span class="s0">*/ 2 4 this 3 3862  3 col 1 3614  </span>
<span class="s0">1277 0 0 7 1225 3753 2082 0 106 /**</span>
 <span class="s0">* Returns the indicated row of the matrix as a two-component vector, ignoring</span>
 <span class="s0">* the last column.</span>
 <span class="s0">*/ 2 4 this 3 3862  3 row 1 3614  </span>
<span class="s0">1278 0 0 7 1226 3753 2082 0 106 /**</span>
 <span class="s0">* Returns the indicated column of the matrix as a two-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/ 2 4 this 3 3862  3 col 1 3614  </span>
<span class="s0">1279 0 0 4 1229 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3861  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1280 0 0 6 1229 3608 0 0 0 3 4 this 3 3862  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1281 0 0 6 1230 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the matrix is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3862  </span>
<span class="s0">1282 0 0 6 1231 3763 0 0 93 /**</span>
 <span class="s0">* Returns true if this is (close enough to) the identity matrix, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3862  </span>
<span class="s0">1283 0 0 6 1232 3608 0 0 54 /**</span>
 <span class="s0">* Returns a particular element of the matrix.</span>
 <span class="s0">*/ 3 4 this 3 3862  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1284 0 0 4 1233 3758 0 0 54 /**</span>
 <span class="s0">* Changes a particular element of the matrix.</span>
 <span class="s0">*/ 4 4 this 3 3861  3 row 1 3614  3 col 1 3614  5 value 1 3608  </span>
<span class="s0">1285 0 0 4 1234 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/ 1 4 this 3 3862  </span>
<span class="s0">1286 0 0 6 1235 3614 0 0 62 /**</span>
 <span class="s0">* Returns the number of elements in the matrix, nine.</span>
 <span class="s0">*/ 1 4 this 3 3862  </span>
<span class="s0">1287 0 0 6 1236 3763 0 0 0 2 4 this 3 3862  5 other 1 3862  </span>
<span class="s0">1288 0 0 6 1237 3763 0 0 0 2 4 this 3 3862  5 other 1 3862  </span>
<span class="s0">1289 0 0 6 1238 3763 0 0 0 2 4 this 3 3862  5 other 1 3862  </span>
<span class="s0">1290 0 0 6 1239 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3862  5 other 1 3862  </span>
<span class="s0">1291 0 0 6 1239 3614 0 0 234 /**</span>
 <span class="s0">* Sorts matrices lexicographically, componentwise.  Returns a number less</span>
 <span class="s0">* than 0 if this matrix sorts before the other one, greater than zero if it</span>
 <span class="s0">* sorts after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/ 3 4 this 3 3862  5 other 1 3862  9 threshold 1 3608  </span>
<span class="s0">1292 0 0 6 1240 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3862  </span>
<span class="s0">1293 0 0 6 1240 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 2 4 this 3 3862  9 threshold 1 3608  </span>
<span class="s0">1294 0 0 6 1241 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3862  4 hash 1 3756  </span>
<span class="s0">1295 0 0 6 1241 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 3 4 this 3 3862  4 hash 1 3756  9 threshold 1 3608  </span>
<span class="s0">1296 0 0 7 1242 3798 2388 0 52 /**</span>
 <span class="s0">* 3-component vector or point times matrix.</span>
 <span class="s0">*/ 2 4 this 3 3862  1 v 1 3799  </span>
<span class="s0">1297 0 0 7 1243 3753 2082 0 162 /**</span>
 <span class="s0">* The matrix transforms a 2-component point (including translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3862  1 v 1 3754  </span>
<span class="s0">1298 0 0 7 1244 3753 2082 0 161 /**</span>
 <span class="s0">* The matrix transforms a 2-component vector (without translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3862  1 v 1 3754  </span>
<span class="s0">1299 0 0 7 1244 3798 2388 0 194 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector and returns the result.  This</span>
 <span class="s0">* assumes the matrix is an orthonormal transform.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, this is the same computation as xform().</span>
 <span class="s0">*/ 2 4 this 3 3862  1 v 1 3799  </span>
<span class="s0">1300 0 0 7 1245 3798 2388 0 142 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3862  1 v 1 3799  </span>
<span class="s0">1301 0 0 4 1246 3758 0 0 52 /**</span>
 <span class="s0">* 3-component vector or point times matrix.</span>
 <span class="s0">*/ 2 4 this 3 3862  1 v 1 3798  </span>
<span class="s0">1302 0 0 4 1247 3758 0 0 139 /**</span>
 <span class="s0">* The matrix transforms a 2-component point (including translation</span>
 <span class="s0">* component).  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3862  1 v 1 3753  </span>
<span class="s0">1303 0 0 4 1248 3758 0 0 137 /**</span>
 <span class="s0">* The matrix transforms a 2-component vector (without translation component).</span>
 <span class="s0">* This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3862  1 v 1 3753  </span>
<span class="s0">1304 0 0 4 1248 3758 0 0 171 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector.  This assumes the matrix is an</span>
 <span class="s0">* orthonormal transform.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, this is the same computation as xform().</span>
 <span class="s0">*/ 2 4 this 3 3862  1 v 1 3798  </span>
<span class="s0">1305 0 0 4 1249 3758 0 0 119 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component),</span>
 <span class="s0">* as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3862  1 v 1 3798  </span>
<span class="s0">1306 0 0 4 1250 3758 0 0 25 // this = other1 * other2 3 4 this 3 3861  6 other1 1 3862  6 other2 1 3862  </span>
<span class="s0">1307 0 0 7 1251 3861 3172 0 0 2 4 this 3 3862  5 other 1 3862  </span>
<span class="s0">1308 0 0 7 1251 3861 3172 0 0 2 4 this 3 3862  6 scalar 1 3608  </span>
<span class="s0">1309 0 0 7 1252 3861 3172 0 0 2 4 this 3 3862  6 scalar 1 3608  </span>
<span class="s0">1310 0 0 6 1253 3861 0 0 63 /**</span>
 <span class="s0">* Performs a memberwise addition between two matrices.</span>
 <span class="s0">*/ 2 4 this 3 3861  5 other 1 3862  </span>
<span class="s0">1311 0 0 6 1254 3861 0 0 66 /**</span>
 <span class="s0">* Performs a memberwise subtraction between two matrices.</span>
 <span class="s0">*/ 2 4 this 3 3861  5 other 1 3862  </span>
<span class="s0">1312 0 0 6 1255 3861 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3861  5 other 1 3862  </span>
<span class="s0">1313 0 0 6 1255 3861 0 0 39 /**</span>
 <span class="s0">* Performs a memberwise scale.</span>
 <span class="s0">*/ 2 4 this 3 3861  6 scalar 1 3608  </span>
<span class="s0">1314 0 0 6 1256 3861 0 0 39 /**</span>
 <span class="s0">* Performs a memberwise scale.</span>
 <span class="s0">*/ 2 4 this 3 3861  6 scalar 1 3608  </span>
<span class="s0">1315 0 0 4 1257 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3861  5 other 1 3862  </span>
<span class="s0">1316 0 0 6 1258 3608 0 0 49 /**</span>
 <span class="s0">* Returns the determinant of the matrix.</span>
 <span class="s0">*/ 1 4 this 3 3862  </span>
<span class="s0">1317 0 0 4 1259 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3861  5 other 1 3862  </span>
<span class="s0">1318 0 0 4 1260 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3861  </span>
<span class="s0">1319 0 0 6 1261 3763 0 0 463 /**</span>
 <span class="s0">* Computes the inverse of the other matrix, and stores the result in this</span>
 <span class="s0">* matrix.  This is a fully general operation and makes no assumptions about</span>
 <span class="s0">* the type of transform represented by the matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* The other matrix must be a different object than this matrix.  However, if</span>
 <span class="s0">* you need to invert a matrix in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the matrix was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/ 2 4 this 3 3861  5 other 1 3862  </span>
<span class="s0">1320 0 0 6 1262 3763 0 0 119 /**</span>
 <span class="s0">* Inverts the current matrix.  Returns true if the inverse is successful,</span>
 <span class="s0">* false if the matrix was singular.</span>
 <span class="s0">*/ 1 4 this 3 3861  </span>
<span class="s0">1321 0 0 6 1263 3763 0 0 114 /**</span>
 <span class="s0">* Simultaneously computes the inverse of the indicated matrix, and then the</span>
 <span class="s0">* transpose of that inverse.</span>
 <span class="s0">*/ 2 4 this 3 3861  5 other 1 3862  </span>
<span class="s0">1322 0 0 6 1263 3763 0 0 114 /**</span>
 <span class="s0">* Simultaneously computes the inverse of the indicated matrix, and then the</span>
 <span class="s0">* transpose of that inverse.</span>
 <span class="s0">*/ 2 4 this 3 3861  5 other 1 3866  </span>
<span class="s0">1323 0 0 6 1264 3862 0 0 147 /**</span>
 <span class="s0">* Returns an identity matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* This function definition must appear first, since some inline functions</span>
 <span class="s0">* below take advantage of it.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1324 0 0 4 1265 3758 0 0 74 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 2 4 this 3 3861  5 trans 1 3754  </span>
<span class="s0">1325 0 0 4 1266 3758 0 0 98 /**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise.</span>
 <span class="s0">*/ 2 4 this 3 3861  5 angle 1 3608  </span>
<span class="s0">1326 0 0 4 1266 3758 0 0 125 /**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/ 4 4 this 3 3861  5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  </span>
<span class="s0">1327 0 0 4 1267 3758 0 0 95 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the two</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/ 2 4 this 3 3861  5 scale 1 3754  </span>
<span class="s0">1328 0 0 4 1267 3758 0 0 97 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the</span>
 <span class="s0">* three axes.</span>
 <span class="s0">*/ 2 4 this 3 3861  5 scale 1 3799  </span>
<span class="s0">1329 0 0 7 1268 3861 3172 0 67 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 1 5 trans 1 3754  </span>
<span class="s0">1330 0 0 7 1268 3861 3172 0 67 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 2 2 tx 1 3608  2 ty 1 3608  </span>
<span class="s0">1331 0 0 7 1269 3861 3172 0 91 /**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise.</span>
 <span class="s0">*/ 1 5 angle 1 3608  </span>
<span class="s0">1332 0 0 7 1269 3861 3172 0 118 /**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/ 3 5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  </span>
<span class="s0">1333 0 0 7 1270 3861 3172 0 85 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the two axes.</span>
 <span class="s0">*/ 1 5 scale 1 3754  </span>
<span class="s0">1334 0 0 7 1270 3861 3172 0 90 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/ 1 5 scale 1 3799  </span>
<span class="s0">1335 0 0 7 1270 3861 3172 0 85 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the two axes.</span>
 <span class="s0">*/ 2 2 sx 1 3608  2 sy 1 3608  </span>
<span class="s0">1336 0 0 7 1270 3861 3172 0 90 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/ 3 2 sx 1 3608  2 sy 1 3608  2 sz 1 3608  </span>
<span class="s0">1337 0 0 4 1271 3758 0 0 163 /**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* normalized.</span>
 <span class="s0">*/ 4 4 this 3 3861  5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  </span>
<span class="s0">1338 0 0 7 1272 3861 3172 0 156 /**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* normalized.</span>
 <span class="s0">*/ 3 5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  </span>
<span class="s0">1339 0 0 4 1273 3758 0 0 99 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated shear in each of the</span>
 <span class="s0">* three planes.</span>
 <span class="s0">*/ 3 4 this 3 3861  5 shear 1 3799  2 cs 5 3627  </span>
<span class="s0">1340 0 0 7 1274 3861 3172 0 92 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/ 2 5 shear 1 3799  2 cs 5 3627  </span>
<span class="s0">1341 0 0 7 1274 3861 3172 0 92 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/ 4 4 shxy 1 3608  4 shxz 1 3608  4 shyz 1 3608  2 cs 5 3627  </span>
<span class="s0">1342 0 0 4 1275 3758 0 0 78 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 4 4 this 3 3861  5 scale 1 3799  5 shear 1 3799  2 cs 5 3627  </span>
<span class="s0">1343 0 0 7 1276 3861 3172 0 71 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 3 5 scale 1 3799  5 shear 1 3799  2 cs 5 3627  </span>
<span class="s0">1344 0 0 7 1276 3861 3172 0 71 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 7 2 sx 1 3608  2 sy 1 3608  2 sz 1 3608  4 shxy 1 3608  4 shxz 1 3608  4 shyz 1 3608  2 cs 5 3627  </span>
<span class="s0">1345 0 0 6 1277 3862 0 0 119 /**</span>
 <span class="s0">* Returns a matrix that transforms from the indicated coordinate system to</span>
 <span class="s0">* the indicated coordinate system.</span>
 <span class="s0">*/ 2 4 from 1 3627  2 to 1 3627  </span>
<span class="s0">1346 0 0 6 1278 3763 0 0 117 /**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3862  5 other 1 3862  </span>
<span class="s0">1347 0 0 6 1278 3763 0 0 93 /**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3862  5 other 1 3862  9 threshold 1 3608  </span>
<span class="s0">1348 0 0 4 1279 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3862  3 out 1 3766  </span>
<span class="s0">1349 0 0 4 1280 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3862  3 out 1 3766  12 indent_level 5 3614  </span>
<span class="s0">1350 0 0 38 1281 3762 0 0 0 1 4 this 3 3862  </span>
<span class="s0">1351 0 0 4 1282 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3862  7 hashgen 1 3764  </span>
<span class="s0">1352 0 0 4 1282 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 3 4 this 3 3862  7 hashgen 1 3764  9 threshold 1 3608  </span>
<span class="s0">1353 0 0 4 1283 3758 0 0 332 /**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the matrix, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3862  11 destination 1 3768  </span>
<span class="s0">1354 0 0 4 1284 3758 0 0 114 /**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3861  4 scan 1 3770  </span>
<span class="s0">1355 0 0 4 1285 3758 0 0 205 /**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the matrix using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3862  11 destination 1 3768  </span>
<span class="s0">1356 0 0 4 1286 3758 0 0 67 /**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3861  6 source 1 3770  </span>
<span class="s0">1357 0 0 7 1287 3773 0 0 0 0 </span>
<span class="s0">1358 0 0 15 1199 3864 3091 0 0 1 6 param0 0 3868  </span>
<span class="s0">1359 0 0 4 1196 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3864  1 i 1 3614  10 assign_val 1 3608  </span>
<span class="s0">1360 0 0 6 1196 3608 0 0 0 2 4 this 3 3868  1 i 1 3614  </span>
<span class="s0">1361 0 0 6 1197 3614 0 0 58 /**</span>
 <span class="s0">* Returns 3: the number of columns of a LMatrix3.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1362 0 0 6 1198 3799 0 0 0 1 4 this 3 3868  </span>
<span class="s0">1363 0 0 15 1205 3865 3096 0 0 1 6 param0 0 3870  </span>
<span class="s0">1364 0 0 6 1202 3608 0 0 0 2 4 this 3 3870  1 i 1 3614  </span>
<span class="s0">1365 0 0 6 1203 3614 0 0 58 /**</span>
 <span class="s0">* Returns 3: the number of columns of a LMatrix3.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1366 0 0 6 1204 3799 0 0 0 1 4 this 3 3870  </span>
<span class="s0">1367 0 0 7 1305 3872 3270 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1368 0 0 23 1305 3872 3270 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional</span>
<span class="s0">// translation component. 1 6 upper3 1 3862  </span>
<span class="s0">1369 0 0 23 1305 3872 3270 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 upper3 1 3862  5 trans 1 3799  </span>
<span class="s0">1370 0 0 15 1305 3872 3270 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 5 other 1 3866  </span>
<span class="s0">1371 0 0 23 1305 3872 3270 0 59 /**</span>
 <span class="s0">* Constructs the matrix from four individual rows.</span>
 <span class="s0">*/ 4 6 param0 0 3826  6 param1 0 3826  6 param2 0 3826  6 param3 0 3826  </span>
<span class="s0">1372 0 0 23 1305 3872 3270 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 5 other 1 3873  </span>
<span class="s0">1373 0 0 23 1305 3872 3270 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 16 6 param0 0 3608  6 param1 0 3608  6 param2 0 3608  6 param3 0 3608  6 param4 0 3608  6 param5 0 3608  6 param6 0 3608  6 param7 0 3608  6 param8 0 3608  6 param9 0 3608  7 param10 0 3608  7 param11 0 3608  7 param12 0 3608  7 param13 0 3608  7 param14 0 3608  7 param15 0 3608  </span>
<span class="s0">1374 0 0 6 1306 3872 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3872  5 other 1 3866  </span>
<span class="s0">1375 0 0 6 1306 3872 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3872  5 other 1 3873  </span>
<span class="s0">1376 0 0 6 1306 3872 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3872  10 fill_value 1 3608  </span>
<span class="s0">1377 0 0 4 1307 3758 0 0 0 2 4 this 3 3872  4 size 1 3756  </span>
<span class="s0">1378 0 0 38 1310 3759 0 0 0 1 4 this 3 3866  </span>
<span class="s0">1379 0 0 4 1311 3758 0 0 157 /**</span>
 <span class="s0">* Sets each element of the matrix to the indicated fill_value.  This is of</span>
 <span class="s0">* questionable value, but is sometimes useful when initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3872  10 fill_value 1 3608  </span>
<span class="s0">1380 0 0 4 1312 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 17 4 this 3 3872  3 e00 1 3608  3 e01 1 3608  3 e02 1 3608  3 e03 1 3608  3 e10 1 3608  3 e11 1 3608  3 e12 1 3608  3 e13 1 3608  3 e20 1 3608  3 e21 1 3608  3 e22 1 3608  3 e23 1 3608  3 e30 1 3608  3 e31 1 3608  3 e32 1 3608  3 e33 1 3608  </span>
<span class="s0">1381 0 0 4 1313 3758 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3872  6 upper3 1 3862  </span>
<span class="s0">1382 0 0 7 1314 3861 3172 0 45 /**</span>
 <span class="s0">* Retrieves the upper 3x3 submatrix.</span>
 <span class="s0">*/ 1 4 this 3 3866  </span>
<span class="s0">1383 0 0 7 1315 3875 3179 0 0 2 4 this 3 3872  1 i 1 3614  </span>
<span class="s0">1384 0 0 7 1315 3876 3184 0 0 2 4 this 3 3866  1 i 1 3614  </span>
<span class="s0">1385 0 0 6 1316 3614 0 0 55 /**</span>
 <span class="s0">* Returns 4: the number of rows of a LMatrix4.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1386 0 0 4 1317 3758 0 0 119 /**</span>
 <span class="s0">* Replaces the indicated row of the matrix with the indicated 3-component</span>
 <span class="s0">* vector, ignoring the last column.</span>
 <span class="s0">*/ 3 4 this 3 3872  3 row 1 3614  1 v 1 3799  </span>
<span class="s0">1387 0 0 4 1317 3758 0 0 52 /**</span>
 <span class="s0">* Replaces the indicated row of the matrix.</span>
 <span class="s0">*/ 3 4 this 3 3872  3 row 1 3614  1 v 1 3826  </span>
<span class="s0">1388 0 0 4 1318 3758 0 0 119 /**</span>
 <span class="s0">* Replaces the indicated column of the matrix with the indicated 3-component</span>
 <span class="s0">* vector, ignoring the last row.</span>
 <span class="s0">*/ 3 4 this 3 3872  3 col 1 3614  1 v 1 3799  </span>
<span class="s0">1389 0 0 4 1318 3758 0 0 55 /**</span>
 <span class="s0">* Replaces the indicated column of the matrix.</span>
 <span class="s0">*/ 3 4 this 3 3872  3 col 1 3614  1 v 1 3826  </span>
<span class="s0">1390 0 0 4 1319 3758 0 0 74 /**</span>
 <span class="s0">* Stores the indicated row of the matrix as a 4-component vector.</span>
 <span class="s0">*/ 3 4 this 3 3866  10 result_vec 1 3825  3 row 1 3614  </span>
<span class="s0">1391 0 0 7 1319 3825 2783 0 77 /**</span>
 <span class="s0">* Retrieves the indicated row of the matrix as a 4-component vector.</span>
 <span class="s0">*/ 2 4 this 3 3866  3 row 1 3614  </span>
<span class="s0">1392 0 0 7 1320 3825 2783 0 80 /**</span>
 <span class="s0">* Retrieves the indicated column of the matrix as a 4-component vector.</span>
 <span class="s0">*/ 2 4 this 3 3866  3 col 1 3614  </span>
<span class="s0">1393 0 0 4 1321 3758 0 0 100 /**</span>
 <span class="s0">* Stores the row column of the matrix as a 3-component vector, ignoring the</span>
 <span class="s0">* last column.</span>
 <span class="s0">*/ 3 4 this 3 3866  10 result_vec 1 3798  3 row 1 3614  </span>
<span class="s0">1394 0 0 7 1321 3798 2388 0 103 /**</span>
 <span class="s0">* Retrieves the row column of the matrix as a 3-component vector, ignoring</span>
 <span class="s0">* the last column.</span>
 <span class="s0">*/ 2 4 this 3 3866  3 row 1 3614  </span>
<span class="s0">1395 0 0 7 1327 3798 2388 0 106 /**</span>
 <span class="s0">* Retrieves the indicated column of the matrix as a 3-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/ 2 4 this 3 3866  3 col 1 3614  </span>
<span class="s0">1396 0 0 4 1328 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3872  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1397 0 0 6 1328 3608 0 0 0 3 4 this 3 3866  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1398 0 0 6 1329 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the matrix is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3866  </span>
<span class="s0">1399 0 0 6 1330 3763 0 0 93 /**</span>
 <span class="s0">* Returns true if this is (close enough to) the identity matrix, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3866  </span>
<span class="s0">1400 0 0 6 1331 3608 0 0 54 /**</span>
 <span class="s0">* Returns a particular element of the matrix.</span>
 <span class="s0">*/ 3 4 this 3 3866  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1401 0 0 4 1332 3758 0 0 54 /**</span>
 <span class="s0">* Changes a particular element of the matrix.</span>
 <span class="s0">*/ 4 4 this 3 3872  3 row 1 3614  3 col 1 3614  5 value 1 3608  </span>
<span class="s0">1402 0 0 4 1333 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/ 1 4 this 3 3866  </span>
<span class="s0">1403 0 0 6 1334 3614 0 0 60 /**</span>
 <span class="s0">* Returns the number of elements in the matrix, 16.</span>
 <span class="s0">*/ 1 4 this 3 3866  </span>
<span class="s0">1404 0 0 4 1335 3758 0 0 101 /**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/ 1 4 this 3 3872  </span>
<span class="s0">1405 0 0 4 1335 3758 0 0 101 /**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/ 1 4 this 3 3866  </span>
<span class="s0">1406 0 0 4 1336 3758 0 0 101 /**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/ 1 4 this 3 3872  </span>
<span class="s0">1407 0 0 4 1336 3758 0 0 101 /**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/ 1 4 this 3 3866  </span>
<span class="s0">1408 0 0 6 1337 3763 0 0 0 2 4 this 3 3866  5 other 1 3866  </span>
<span class="s0">1409 0 0 6 1338 3763 0 0 0 2 4 this 3 3866  5 other 1 3866  </span>
<span class="s0">1410 0 0 6 1339 3763 0 0 0 2 4 this 3 3866  5 other 1 3866  </span>
<span class="s0">1411 0 0 6 1340 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3866  5 other 1 3866  </span>
<span class="s0">1412 0 0 6 1340 3614 0 0 234 /**</span>
 <span class="s0">* Sorts matrices lexicographically, componentwise.  Returns a number less</span>
 <span class="s0">* than 0 if this matrix sorts before the other one, greater than zero if it</span>
 <span class="s0">* sorts after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/ 3 4 this 3 3866  5 other 1 3866  9 threshold 1 3608  </span>
<span class="s0">1413 0 0 6 1341 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3866  </span>
<span class="s0">1414 0 0 6 1341 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 2 4 this 3 3866  9 threshold 1 3608  </span>
<span class="s0">1415 0 0 6 1342 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3866  4 hash 1 3756  </span>
<span class="s0">1416 0 0 6 1342 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 3 4 this 3 3866  4 hash 1 3756  9 threshold 1 3608  </span>
<span class="s0">1417 0 0 7 1343 3825 2783 0 91 /**</span>
 <span class="s0">* 4-component vector or point times matrix.  This is a fully general</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/ 2 4 this 3 3866  1 v 1 3826  </span>
<span class="s0">1418 0 0 7 1344 3798 2388 0 162 /**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3866  1 v 1 3799  </span>
<span class="s0">1419 0 0 7 1345 3798 2388 0 143 /**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3866  1 v 1 3799  </span>
<span class="s0">1420 0 0 7 1346 3798 2388 0 169 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an orthonormal</span>
 <span class="s0">* transform.</span>
 <span class="s0">*/ 2 4 this 3 3866  1 v 1 3799  </span>
<span class="s0">1421 0 0 7 1347 3798 2388 0 142 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3866  1 v 1 3799  </span>
<span class="s0">1422 0 0 4 1348 3758 0 0 91 /**</span>
 <span class="s0">* 4-component vector or point times matrix.  This is a fully general</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/ 2 4 this 3 3866  1 v 1 3825  </span>
<span class="s0">1423 0 0 4 1349 3758 0 0 139 /**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation</span>
 <span class="s0">* component).  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3866  1 v 1 3798  </span>
<span class="s0">1424 0 0 4 1350 3758 0 0 120 /**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation</span>
 <span class="s0">* component), as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3866  1 v 1 3798  </span>
<span class="s0">1425 0 0 4 1351 3758 0 0 142 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component).</span>
 <span class="s0">* This assumes the matrix is an orthonormal transform.</span>
 <span class="s0">*/ 2 4 this 3 3866  1 v 1 3798  </span>
<span class="s0">1426 0 0 4 1352 3758 0 0 119 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component),</span>
 <span class="s0">* as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3866  1 v 1 3798  </span>
<span class="s0">1427 0 0 4 1353 3758 0 0 25 // this = other1 * other2 3 4 this 3 3872  6 other1 1 3866  6 other2 1 3866  </span>
<span class="s0">1428 0 0 7 1354 3872 3270 0 0 2 4 this 3 3866  5 other 1 3866  </span>
<span class="s0">1429 0 0 7 1354 3872 3270 0 0 2 4 this 3 3866  6 scalar 1 3608  </span>
<span class="s0">1430 0 0 7 1355 3872 3270 0 0 2 4 this 3 3866  6 scalar 1 3608  </span>
<span class="s0">1431 0 0 6 1356 3872 0 0 63 /**</span>
 <span class="s0">* Performs a memberwise addition between two matrices.</span>
 <span class="s0">*/ 2 4 this 3 3872  5 other 1 3866  </span>
<span class="s0">1432 0 0 6 1357 3872 0 0 66 /**</span>
 <span class="s0">* Performs a memberwise subtraction between two matrices.</span>
 <span class="s0">*/ 2 4 this 3 3872  5 other 1 3866  </span>
<span class="s0">1433 0 0 6 1358 3872 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3872  5 other 1 3866  </span>
<span class="s0">1434 0 0 6 1358 3872 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3872  6 scalar 1 3608  </span>
<span class="s0">1435 0 0 6 1359 3872 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3872  6 scalar 1 3608  </span>
<span class="s0">1436 0 0 4 1360 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3872  5 other 1 3866  </span>
<span class="s0">1437 0 0 4 1361 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3872  5 other 1 3866  </span>
<span class="s0">1438 0 0 4 1362 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3872  </span>
<span class="s0">1439 0 0 6 1363 3763 0 0 461 /**</span>
 <span class="s0">* Computes the inverse of the other matrix, and stores the result in this</span>
 <span class="s0">* matrix.  This is a fully general operation and makes no assumptions about</span>
 <span class="s0">* the type of transform represented by the matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* The other matrix must be a different object than this matrix.  However, if</span>
 <span class="s0">* you need to invert a matrix in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the matrix was successfully inverted, false if</span>
 <span class="s0">* the was a singularity.</span>
 <span class="s0">*/ 2 4 this 3 3872  5 other 1 3866  </span>
<span class="s0">1440 0 0 6 1364 3763 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices</span>
<span class="s0">// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3872  5 other 1 3866  </span>
<span class="s0">1441 0 0 6 1365 3763 0 0 119 /**</span>
 <span class="s0">* Inverts the current matrix.  Returns true if the inverse is successful,</span>
 <span class="s0">* false if the matrix was singular.</span>
 <span class="s0">*/ 1 4 this 3 3872  </span>
<span class="s0">1442 0 0 4 1366 3758 0 0 48 /**</span>
 <span class="s0">* Computes `(*this) += other * weight`.</span>
 <span class="s0">*/ 3 4 this 3 3872  5 other 1 3866  6 weight 1 3608  </span>
<span class="s0">1443 0 0 6 1367 3866 0 0 147 /**</span>
 <span class="s0">* Returns an identity matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* This function definition must appear first, since some inline functions</span>
 <span class="s0">* below take advantage of it.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1444 0 0 6 1368 3866 0 0 46 /**</span>
 <span class="s0">* Returns an matrix filled with ones.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1445 0 0 6 1369 3866 0 0 47 /**</span>
 <span class="s0">* Returns an matrix filled with zeros.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1446 0 0 4 1370 3758 0 0 74 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 2 4 this 3 3872  5 trans 1 3799  </span>
<span class="s0">1447 0 0 4 1371 3758 0 0 122 /**</span>
 <span class="s0">* Sets mat to a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/ 4 4 this 3 3872  5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  </span>
<span class="s0">1448 0 0 4 1372 3758 0 0 166 /**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* prenormalized.</span>
 <span class="s0">*/ 4 4 this 3 3872  5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  </span>
<span class="s0">1449 0 0 4 1373 3758 0 0 97 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the</span>
 <span class="s0">* three axes.</span>
 <span class="s0">*/ 2 4 this 3 3872  5 scale 1 3799  </span>
<span class="s0">1450 0 0 4 1374 3758 0 0 99 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated shear in each of the</span>
 <span class="s0">* three planes.</span>
 <span class="s0">*/ 3 4 this 3 3872  5 shear 1 3799  2 cs 5 3627  </span>
<span class="s0">1451 0 0 4 1375 3758 0 0 78 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 4 4 this 3 3872  5 scale 1 3799  5 shear 1 3799  2 cs 5 3627  </span>
<span class="s0">1452 0 0 7 1376 3872 3270 0 67 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 1 5 trans 1 3799  </span>
<span class="s0">1453 0 0 7 1376 3872 3270 0 67 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 3 2 tx 1 3608  2 ty 1 3608  2 tz 1 3608  </span>
<span class="s0">1454 0 0 7 1377 3872 3270 0 118 /**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/ 3 5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  </span>
<span class="s0">1455 0 0 7 1378 3872 3270 0 159 /**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* prenormalized.</span>
 <span class="s0">*/ 3 5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  </span>
<span class="s0">1456 0 0 7 1379 3872 3270 0 90 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/ 1 5 scale 1 3799  </span>
<span class="s0">1457 0 0 7 1379 3872 3270 0 69 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated uniform scale.</span>
 <span class="s0">*/ 1 5 scale 1 3608  </span>
<span class="s0">1458 0 0 7 1379 3872 3270 0 90 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/ 3 2 sx 1 3608  2 sy 1 3608  2 sz 1 3608  </span>
<span class="s0">1459 0 0 7 1380 3872 3270 0 92 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/ 2 5 shear 1 3799  2 cs 5 3627  </span>
<span class="s0">1460 0 0 7 1380 3872 3270 0 92 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/ 4 4 shxy 1 3608  4 shxz 1 3608  4 shyz 1 3608  2 cs 5 3627  </span>
<span class="s0">1461 0 0 7 1381 3872 3270 0 71 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 3 5 scale 1 3799  5 shear 1 3799  2 cs 5 3627  </span>
<span class="s0">1462 0 0 7 1381 3872 3270 0 71 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 7 2 sx 1 3608  2 sy 1 3608  2 sz 1 3608  4 shxy 1 3608  4 shxz 1 3608  4 shyz 1 3608  2 cs 5 3627  </span>
<span class="s0">1463 0 0 6 1382 3866 0 0 109 /**</span>
 <span class="s0">* Returns a matrix that transforms from the Y-up coordinate system to the</span>
 <span class="s0">* Z-up coordinate system.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1464 0 0 6 1383 3866 0 0 109 /**</span>
 <span class="s0">* Returns a matrix that transforms from the Y-up coordinate system to the</span>
 <span class="s0">* Z-up coordinate system.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1465 0 0 6 1384 3866 0 0 119 /**</span>
 <span class="s0">* Returns a matrix that transforms from the indicated coordinate system to</span>
 <span class="s0">* the indicated coordinate system.</span>
 <span class="s0">*/ 2 4 from 1 3627  2 to 1 3627  </span>
<span class="s0">1466 0 0 6 1385 3763 0 0 117 /**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3866  5 other 1 3866  </span>
<span class="s0">1467 0 0 6 1385 3763 0 0 199 /**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a specified</span>
 <span class="s0">* tolerance.  This is faster than the equivalence operator as this doesn't</span>
 <span class="s0">* have to guarantee that it is transitive.</span>
 <span class="s0">*/ 3 4 this 3 3866  5 other 1 3866  9 threshold 1 3608  </span>
<span class="s0">1468 0 0 4 1386 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3866  3 out 1 3766  </span>
<span class="s0">1469 0 0 4 1387 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3866  3 out 1 3766  12 indent_level 5 3614  </span>
<span class="s0">1470 0 0 38 1388 3762 0 0 0 1 4 this 3 3866  </span>
<span class="s0">1471 0 0 4 1389 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3866  7 hashgen 1 3764  </span>
<span class="s0">1472 0 0 4 1389 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 3 4 this 3 3866  7 hashgen 1 3764  5 scale 1 3608  </span>
<span class="s0">1473 0 0 4 1390 3758 0 0 332 /**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the matrix, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3866  11 destination 1 3768  </span>
<span class="s0">1474 0 0 4 1391 3758 0 0 114 /**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3872  4 scan 1 3770  </span>
<span class="s0">1475 0 0 4 1392 3758 0 0 205 /**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the matrix using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3866  11 destination 1 3768  </span>
<span class="s0">1476 0 0 4 1393 3758 0 0 67 /**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3872  6 source 1 3770  </span>
<span class="s0">1477 0 0 7 1394 3773 0 0 0 0 </span>
<span class="s0">1478 0 0 15 1297 3875 3179 0 0 1 6 param0 0 3877  </span>
<span class="s0">1479 0 0 4 1294 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3875  1 i 1 3614  10 assign_val 1 3608  </span>
<span class="s0">1480 0 0 6 1294 3608 0 0 0 2 4 this 3 3877  1 i 1 3614  </span>
<span class="s0">1481 0 0 6 1295 3614 0 0 58 /**</span>
 <span class="s0">* Returns 4: the number of columns of a LMatrix4.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1482 0 0 6 1296 3826 0 0 0 1 4 this 3 3877  </span>
<span class="s0">1483 0 0 15 1303 3876 3184 0 0 1 6 param0 0 3879  </span>
<span class="s0">1484 0 0 6 1300 3608 0 0 0 2 4 this 3 3879  1 i 1 3614  </span>
<span class="s0">1485 0 0 6 1301 3614 0 0 58 /**</span>
 <span class="s0">* Returns 4: the number of columns of a LMatrix4.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1486 0 0 6 1302 3826 0 0 0 1 4 this 3 3879  </span>
<span class="s0">1487 0 0 7 1398 3881 3280 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1488 0 0 23 1398 3881 3280 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3866  </span>
<span class="s0">1489 0 0 15 1398 3881 3280 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3873  </span>
<span class="s0">1490 0 0 23 1398 3881 3280 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 16 3 e00 1 3608  3 e01 1 3608  3 e02 1 3608  3 e03 1 3608  3 e10 1 3608  3 e11 1 3608  3 e12 1 3608  3 e13 1 3608  3 e20 1 3608  3 e21 1 3608  3 e22 1 3608  3 e23 1 3608  3 e30 1 3608  3 e31 1 3608  3 e32 1 3608  3 e33 1 3608  </span>
<span class="s0">1491 0 0 6 1399 3881 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3881  4 copy 1 3866  </span>
<span class="s0">1492 0 0 6 1399 3881 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3881  4 copy 1 3873  </span>
<span class="s0">1493 0 0 4 1400 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 17 4 this 3 3881  3 e00 1 3608  3 e01 1 3608  3 e02 1 3608  3 e03 1 3608  3 e10 1 3608  3 e11 1 3608  3 e12 1 3608  3 e13 1 3608  3 e20 1 3608  3 e21 1 3608  3 e22 1 3608  3 e23 1 3608  3 e30 1 3608  3 e31 1 3608  3 e32 1 3608  3 e33 1 3608  </span>
<span class="s0">1494 0 0 4 1401 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3881  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1495 0 0 6 1401 3608 0 0 0 3 4 this 3 3873  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1496 0 0 4 1402 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/ 1 4 this 3 3873  </span>
<span class="s0">1497 0 0 6 1403 3614 0 0 65 /**</span>
 <span class="s0">* Returns the number of elements in the matrix, sixteen.</span>
 <span class="s0">*/ 1 4 this 3 3873  </span>
<span class="s0">1498 0 0 6 1404 3763 0 0 0 2 4 this 3 3873  5 other 1 3873  </span>
<span class="s0">1499 0 0 6 1405 3763 0 0 0 2 4 this 3 3873  5 other 1 3873  </span>
<span class="s0">1500 0 0 7 1406 3773 0 0 0 0 </span>
<span class="s0">1501 0 0 7 1422 3882 3366 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1502 0 0 15 1422 3882 3366 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 5 other 1 3883  </span>
<span class="s0">1503 0 0 23 1422 3882 3366 0 60 /**</span>
 <span class="s0">* Constructs the matrix from three individual rows.</span>
 <span class="s0">*/ 3 6 param0 0 3802  6 param1 0 3802  6 param2 0 3802  </span>
<span class="s0">1504 0 0 23 1422 3882 3366 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 9 6 param0 0 3611  6 param1 0 3611  6 param2 0 3611  6 param3 0 3611  6 param4 0 3611  6 param5 0 3611  6 param6 0 3611  6 param7 0 3611  6 param8 0 3611  </span>
<span class="s0">1505 0 0 6 1423 3882 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3882  5 other 1 3883  </span>
<span class="s0">1506 0 0 6 1423 3882 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3882  10 fill_value 1 3611  </span>
<span class="s0">1507 0 0 4 1424 3758 0 0 0 2 4 this 3 3882  4 size 1 3756  </span>
<span class="s0">1508 0 0 38 1427 3759 0 0 0 1 4 this 3 3883  </span>
<span class="s0">1509 0 0 4 1428 3758 0 0 157 /**</span>
 <span class="s0">* Sets each element of the matrix to the indicated fill_value.  This is of</span>
 <span class="s0">* questionable value, but is sometimes useful when initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3882  10 fill_value 1 3611  </span>
<span class="s0">1510 0 0 4 1429 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 10 4 this 3 3882  3 e00 1 3611  3 e01 1 3611  3 e02 1 3611  3 e10 1 3611  3 e11 1 3611  3 e12 1 3611  3 e20 1 3611  3 e21 1 3611  3 e22 1 3611  </span>
<span class="s0">1511 0 0 7 1430 3885 3285 0 0 2 4 this 3 3882  1 i 1 3614  </span>
<span class="s0">1512 0 0 7 1430 3886 3290 0 0 2 4 this 3 3883  1 i 1 3614  </span>
<span class="s0">1513 0 0 6 1431 3614 0 0 55 /**</span>
 <span class="s0">* Returns 3: the number of rows of a LMatrix3.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1514 0 0 4 1432 3758 0 0 109 /**</span>
 <span class="s0">* Replaces the indicated row of the matrix from a two-component vector,</span>
 <span class="s0">* ignoring the last column.</span>
 <span class="s0">*/ 3 4 this 3 3882  3 row 1 3614  1 v 1 3775  </span>
<span class="s0">1515 0 0 4 1432 3758 0 0 82 /**</span>
 <span class="s0">* Replaces the indicated row of the matrix from a three-component vector.</span>
 <span class="s0">*/ 3 4 this 3 3882  3 row 1 3614  1 v 1 3802  </span>
<span class="s0">1516 0 0 4 1433 3758 0 0 109 /**</span>
 <span class="s0">* Replaces the indicated column of the matrix from a two-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/ 3 4 this 3 3882  3 col 1 3614  1 v 1 3775  </span>
<span class="s0">1517 0 0 4 1433 3758 0 0 85 /**</span>
 <span class="s0">* Replaces the indicated column of the matrix from a three-component vector.</span>
 <span class="s0">*/ 3 4 this 3 3882  3 col 1 3614  1 v 1 3802  </span>
<span class="s0">1518 0 0 4 1434 3758 0 0 78 /**</span>
 <span class="s0">* Stores the indicated row of the matrix as a three-component vector.</span>
 <span class="s0">*/ 3 4 this 3 3883  10 result_vec 1 3801  3 row 1 3614  </span>
<span class="s0">1519 0 0 7 1434 3801 2466 0 79 /**</span>
 <span class="s0">* Returns the indicated row of the matrix as a three-component vector.</span>
 <span class="s0">*/ 2 4 this 3 3883  3 row 1 3614  </span>
<span class="s0">1520 0 0 7 1435 3801 2466 0 82 /**</span>
 <span class="s0">* Returns the indicated column of the matrix as a three-component vector.</span>
 <span class="s0">*/ 2 4 this 3 3883  3 col 1 3614  </span>
<span class="s0">1521 0 0 7 1440 3774 2150 0 106 /**</span>
 <span class="s0">* Returns the indicated row of the matrix as a two-component vector, ignoring</span>
 <span class="s0">* the last column.</span>
 <span class="s0">*/ 2 4 this 3 3883  3 row 1 3614  </span>
<span class="s0">1522 0 0 7 1441 3774 2150 0 106 /**</span>
 <span class="s0">* Returns the indicated column of the matrix as a two-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/ 2 4 this 3 3883  3 col 1 3614  </span>
<span class="s0">1523 0 0 4 1444 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3882  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1524 0 0 6 1444 3611 0 0 0 3 4 this 3 3883  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1525 0 0 6 1445 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the matrix is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3883  </span>
<span class="s0">1526 0 0 6 1446 3763 0 0 93 /**</span>
 <span class="s0">* Returns true if this is (close enough to) the identity matrix, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3883  </span>
<span class="s0">1527 0 0 6 1447 3611 0 0 54 /**</span>
 <span class="s0">* Returns a particular element of the matrix.</span>
 <span class="s0">*/ 3 4 this 3 3883  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1528 0 0 4 1448 3758 0 0 54 /**</span>
 <span class="s0">* Changes a particular element of the matrix.</span>
 <span class="s0">*/ 4 4 this 3 3882  3 row 1 3614  3 col 1 3614  5 value 1 3611  </span>
<span class="s0">1529 0 0 4 1449 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/ 1 4 this 3 3883  </span>
<span class="s0">1530 0 0 6 1450 3614 0 0 62 /**</span>
 <span class="s0">* Returns the number of elements in the matrix, nine.</span>
 <span class="s0">*/ 1 4 this 3 3883  </span>
<span class="s0">1531 0 0 6 1451 3763 0 0 0 2 4 this 3 3883  5 other 1 3883  </span>
<span class="s0">1532 0 0 6 1452 3763 0 0 0 2 4 this 3 3883  5 other 1 3883  </span>
<span class="s0">1533 0 0 6 1453 3763 0 0 0 2 4 this 3 3883  5 other 1 3883  </span>
<span class="s0">1534 0 0 6 1454 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3883  5 other 1 3883  </span>
<span class="s0">1535 0 0 6 1454 3614 0 0 234 /**</span>
 <span class="s0">* Sorts matrices lexicographically, componentwise.  Returns a number less</span>
 <span class="s0">* than 0 if this matrix sorts before the other one, greater than zero if it</span>
 <span class="s0">* sorts after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/ 3 4 this 3 3883  5 other 1 3883  9 threshold 1 3611  </span>
<span class="s0">1536 0 0 6 1455 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3883  </span>
<span class="s0">1537 0 0 6 1455 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 2 4 this 3 3883  9 threshold 1 3611  </span>
<span class="s0">1538 0 0 6 1456 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3883  4 hash 1 3756  </span>
<span class="s0">1539 0 0 6 1456 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 3 4 this 3 3883  4 hash 1 3756  9 threshold 1 3611  </span>
<span class="s0">1540 0 0 7 1457 3801 2466 0 52 /**</span>
 <span class="s0">* 3-component vector or point times matrix.</span>
 <span class="s0">*/ 2 4 this 3 3883  1 v 1 3802  </span>
<span class="s0">1541 0 0 7 1458 3774 2150 0 162 /**</span>
 <span class="s0">* The matrix transforms a 2-component point (including translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3883  1 v 1 3775  </span>
<span class="s0">1542 0 0 7 1459 3774 2150 0 161 /**</span>
 <span class="s0">* The matrix transforms a 2-component vector (without translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3883  1 v 1 3775  </span>
<span class="s0">1543 0 0 7 1459 3801 2466 0 194 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector and returns the result.  This</span>
 <span class="s0">* assumes the matrix is an orthonormal transform.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, this is the same computation as xform().</span>
 <span class="s0">*/ 2 4 this 3 3883  1 v 1 3802  </span>
<span class="s0">1544 0 0 7 1460 3801 2466 0 142 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3883  1 v 1 3802  </span>
<span class="s0">1545 0 0 4 1461 3758 0 0 52 /**</span>
 <span class="s0">* 3-component vector or point times matrix.</span>
 <span class="s0">*/ 2 4 this 3 3883  1 v 1 3801  </span>
<span class="s0">1546 0 0 4 1462 3758 0 0 139 /**</span>
 <span class="s0">* The matrix transforms a 2-component point (including translation</span>
 <span class="s0">* component).  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3883  1 v 1 3774  </span>
<span class="s0">1547 0 0 4 1463 3758 0 0 137 /**</span>
 <span class="s0">* The matrix transforms a 2-component vector (without translation component).</span>
 <span class="s0">* This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3883  1 v 1 3774  </span>
<span class="s0">1548 0 0 4 1463 3758 0 0 171 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector.  This assumes the matrix is an</span>
 <span class="s0">* orthonormal transform.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, this is the same computation as xform().</span>
 <span class="s0">*/ 2 4 this 3 3883  1 v 1 3801  </span>
<span class="s0">1549 0 0 4 1464 3758 0 0 119 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component),</span>
 <span class="s0">* as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3883  1 v 1 3801  </span>
<span class="s0">1550 0 0 4 1465 3758 0 0 25 // this = other1 * other2 3 4 this 3 3882  6 other1 1 3883  6 other2 1 3883  </span>
<span class="s0">1551 0 0 7 1466 3882 3366 0 0 2 4 this 3 3883  5 other 1 3883  </span>
<span class="s0">1552 0 0 7 1466 3882 3366 0 0 2 4 this 3 3883  6 scalar 1 3611  </span>
<span class="s0">1553 0 0 7 1467 3882 3366 0 0 2 4 this 3 3883  6 scalar 1 3611  </span>
<span class="s0">1554 0 0 6 1468 3882 0 0 63 /**</span>
 <span class="s0">* Performs a memberwise addition between two matrices.</span>
 <span class="s0">*/ 2 4 this 3 3882  5 other 1 3883  </span>
<span class="s0">1555 0 0 6 1469 3882 0 0 66 /**</span>
 <span class="s0">* Performs a memberwise subtraction between two matrices.</span>
 <span class="s0">*/ 2 4 this 3 3882  5 other 1 3883  </span>
<span class="s0">1556 0 0 6 1470 3882 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3882  5 other 1 3883  </span>
<span class="s0">1557 0 0 6 1470 3882 0 0 39 /**</span>
 <span class="s0">* Performs a memberwise scale.</span>
 <span class="s0">*/ 2 4 this 3 3882  6 scalar 1 3611  </span>
<span class="s0">1558 0 0 6 1471 3882 0 0 39 /**</span>
 <span class="s0">* Performs a memberwise scale.</span>
 <span class="s0">*/ 2 4 this 3 3882  6 scalar 1 3611  </span>
<span class="s0">1559 0 0 4 1472 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3882  5 other 1 3883  </span>
<span class="s0">1560 0 0 6 1473 3611 0 0 49 /**</span>
 <span class="s0">* Returns the determinant of the matrix.</span>
 <span class="s0">*/ 1 4 this 3 3883  </span>
<span class="s0">1561 0 0 4 1474 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3882  5 other 1 3883  </span>
<span class="s0">1562 0 0 4 1475 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3882  </span>
<span class="s0">1563 0 0 6 1476 3763 0 0 463 /**</span>
 <span class="s0">* Computes the inverse of the other matrix, and stores the result in this</span>
 <span class="s0">* matrix.  This is a fully general operation and makes no assumptions about</span>
 <span class="s0">* the type of transform represented by the matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* The other matrix must be a different object than this matrix.  However, if</span>
 <span class="s0">* you need to invert a matrix in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the matrix was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/ 2 4 this 3 3882  5 other 1 3883  </span>
<span class="s0">1564 0 0 6 1477 3763 0 0 119 /**</span>
 <span class="s0">* Inverts the current matrix.  Returns true if the inverse is successful,</span>
 <span class="s0">* false if the matrix was singular.</span>
 <span class="s0">*/ 1 4 this 3 3882  </span>
<span class="s0">1565 0 0 6 1478 3763 0 0 114 /**</span>
 <span class="s0">* Simultaneously computes the inverse of the indicated matrix, and then the</span>
 <span class="s0">* transpose of that inverse.</span>
 <span class="s0">*/ 2 4 this 3 3882  5 other 1 3883  </span>
<span class="s0">1566 0 0 6 1478 3763 0 0 114 /**</span>
 <span class="s0">* Simultaneously computes the inverse of the indicated matrix, and then the</span>
 <span class="s0">* transpose of that inverse.</span>
 <span class="s0">*/ 2 4 this 3 3882  5 other 1 3887  </span>
<span class="s0">1567 0 0 6 1479 3883 0 0 147 /**</span>
 <span class="s0">* Returns an identity matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* This function definition must appear first, since some inline functions</span>
 <span class="s0">* below take advantage of it.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1568 0 0 4 1480 3758 0 0 74 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 2 4 this 3 3882  5 trans 1 3775  </span>
<span class="s0">1569 0 0 4 1481 3758 0 0 98 /**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise.</span>
 <span class="s0">*/ 2 4 this 3 3882  5 angle 1 3611  </span>
<span class="s0">1570 0 0 4 1481 3758 0 0 125 /**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/ 4 4 this 3 3882  5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  </span>
<span class="s0">1571 0 0 4 1482 3758 0 0 95 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the two</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/ 2 4 this 3 3882  5 scale 1 3775  </span>
<span class="s0">1572 0 0 4 1482 3758 0 0 97 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the</span>
 <span class="s0">* three axes.</span>
 <span class="s0">*/ 2 4 this 3 3882  5 scale 1 3802  </span>
<span class="s0">1573 0 0 7 1483 3882 3366 0 67 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 1 5 trans 1 3775  </span>
<span class="s0">1574 0 0 7 1483 3882 3366 0 67 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 2 2 tx 1 3611  2 ty 1 3611  </span>
<span class="s0">1575 0 0 7 1484 3882 3366 0 91 /**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise.</span>
 <span class="s0">*/ 1 5 angle 1 3611  </span>
<span class="s0">1576 0 0 7 1484 3882 3366 0 118 /**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/ 3 5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  </span>
<span class="s0">1577 0 0 7 1485 3882 3366 0 85 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the two axes.</span>
 <span class="s0">*/ 1 5 scale 1 3775  </span>
<span class="s0">1578 0 0 7 1485 3882 3366 0 90 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/ 1 5 scale 1 3802  </span>
<span class="s0">1579 0 0 7 1485 3882 3366 0 85 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the two axes.</span>
 <span class="s0">*/ 2 2 sx 1 3611  2 sy 1 3611  </span>
<span class="s0">1580 0 0 7 1485 3882 3366 0 90 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/ 3 2 sx 1 3611  2 sy 1 3611  2 sz 1 3611  </span>
<span class="s0">1581 0 0 4 1486 3758 0 0 163 /**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* normalized.</span>
 <span class="s0">*/ 4 4 this 3 3882  5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  </span>
<span class="s0">1582 0 0 7 1487 3882 3366 0 156 /**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* normalized.</span>
 <span class="s0">*/ 3 5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  </span>
<span class="s0">1583 0 0 4 1488 3758 0 0 99 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated shear in each of the</span>
 <span class="s0">* three planes.</span>
 <span class="s0">*/ 3 4 this 3 3882  5 shear 1 3802  2 cs 5 3627  </span>
<span class="s0">1584 0 0 7 1489 3882 3366 0 92 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/ 2 5 shear 1 3802  2 cs 5 3627  </span>
<span class="s0">1585 0 0 7 1489 3882 3366 0 92 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/ 4 4 shxy 1 3611  4 shxz 1 3611  4 shyz 1 3611  2 cs 5 3627  </span>
<span class="s0">1586 0 0 4 1490 3758 0 0 78 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 4 4 this 3 3882  5 scale 1 3802  5 shear 1 3802  2 cs 5 3627  </span>
<span class="s0">1587 0 0 7 1491 3882 3366 0 71 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 3 5 scale 1 3802  5 shear 1 3802  2 cs 5 3627  </span>
<span class="s0">1588 0 0 7 1491 3882 3366 0 71 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 7 2 sx 1 3611  2 sy 1 3611  2 sz 1 3611  4 shxy 1 3611  4 shxz 1 3611  4 shyz 1 3611  2 cs 5 3627  </span>
<span class="s0">1589 0 0 6 1492 3883 0 0 119 /**</span>
 <span class="s0">* Returns a matrix that transforms from the indicated coordinate system to</span>
 <span class="s0">* the indicated coordinate system.</span>
 <span class="s0">*/ 2 4 from 1 3627  2 to 1 3627  </span>
<span class="s0">1590 0 0 6 1493 3763 0 0 117 /**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3883  5 other 1 3883  </span>
<span class="s0">1591 0 0 6 1493 3763 0 0 93 /**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3883  5 other 1 3883  9 threshold 1 3611  </span>
<span class="s0">1592 0 0 4 1494 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3883  3 out 1 3766  </span>
<span class="s0">1593 0 0 4 1495 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3883  3 out 1 3766  12 indent_level 5 3614  </span>
<span class="s0">1594 0 0 38 1496 3762 0 0 0 1 4 this 3 3883  </span>
<span class="s0">1595 0 0 4 1497 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3883  7 hashgen 1 3764  </span>
<span class="s0">1596 0 0 4 1497 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 3 4 this 3 3883  7 hashgen 1 3764  9 threshold 1 3611  </span>
<span class="s0">1597 0 0 4 1498 3758 0 0 332 /**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the matrix, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3883  11 destination 1 3768  </span>
<span class="s0">1598 0 0 4 1499 3758 0 0 114 /**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3882  4 scan 1 3770  </span>
<span class="s0">1599 0 0 4 1500 3758 0 0 205 /**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the matrix using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3883  11 destination 1 3768  </span>
<span class="s0">1600 0 0 4 1501 3758 0 0 67 /**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3882  6 source 1 3770  </span>
<span class="s0">1601 0 0 7 1502 3773 0 0 0 0 </span>
<span class="s0">1602 0 0 15 1414 3885 3285 0 0 1 6 param0 0 3889  </span>
<span class="s0">1603 0 0 4 1411 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3885  1 i 1 3614  10 assign_val 1 3611  </span>
<span class="s0">1604 0 0 6 1411 3611 0 0 0 2 4 this 3 3889  1 i 1 3614  </span>
<span class="s0">1605 0 0 6 1412 3614 0 0 58 /**</span>
 <span class="s0">* Returns 3: the number of columns of a LMatrix3.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1606 0 0 6 1413 3802 0 0 0 1 4 this 3 3889  </span>
<span class="s0">1607 0 0 15 1420 3886 3290 0 0 1 6 param0 0 3891  </span>
<span class="s0">1608 0 0 6 1417 3611 0 0 0 2 4 this 3 3891  1 i 1 3614  </span>
<span class="s0">1609 0 0 6 1418 3614 0 0 58 /**</span>
 <span class="s0">* Returns 3: the number of columns of a LMatrix3.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1610 0 0 6 1419 3802 0 0 0 1 4 this 3 3891  </span>
<span class="s0">1611 0 0 7 1518 3893 3462 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1612 0 0 23 1518 3893 3462 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional</span>
<span class="s0">// translation component. 1 6 upper3 1 3883  </span>
<span class="s0">1613 0 0 23 1518 3893 3462 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 upper3 1 3883  5 trans 1 3802  </span>
<span class="s0">1614 0 0 15 1518 3893 3462 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 5 other 1 3887  </span>
<span class="s0">1615 0 0 23 1518 3893 3462 0 59 /**</span>
 <span class="s0">* Constructs the matrix from four individual rows.</span>
 <span class="s0">*/ 4 6 param0 0 3832  6 param1 0 3832  6 param2 0 3832  6 param3 0 3832  </span>
<span class="s0">1616 0 0 23 1518 3893 3462 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 5 other 1 3894  </span>
<span class="s0">1617 0 0 23 1518 3893 3462 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 16 6 param0 0 3611  6 param1 0 3611  6 param2 0 3611  6 param3 0 3611  6 param4 0 3611  6 param5 0 3611  6 param6 0 3611  6 param7 0 3611  6 param8 0 3611  6 param9 0 3611  7 param10 0 3611  7 param11 0 3611  7 param12 0 3611  7 param13 0 3611  7 param14 0 3611  7 param15 0 3611  </span>
<span class="s0">1618 0 0 6 1519 3893 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3893  5 other 1 3887  </span>
<span class="s0">1619 0 0 6 1519 3893 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3893  5 other 1 3894  </span>
<span class="s0">1620 0 0 6 1519 3893 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3893  10 fill_value 1 3611  </span>
<span class="s0">1621 0 0 4 1520 3758 0 0 0 2 4 this 3 3893  4 size 1 3756  </span>
<span class="s0">1622 0 0 38 1523 3759 0 0 0 1 4 this 3 3887  </span>
<span class="s0">1623 0 0 4 1524 3758 0 0 157 /**</span>
 <span class="s0">* Sets each element of the matrix to the indicated fill_value.  This is of</span>
 <span class="s0">* questionable value, but is sometimes useful when initializing to zero.</span>
 <span class="s0">*/ 2 4 this 3 3893  10 fill_value 1 3611  </span>
<span class="s0">1624 0 0 4 1525 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 17 4 this 3 3893  3 e00 1 3611  3 e01 1 3611  3 e02 1 3611  3 e03 1 3611  3 e10 1 3611  3 e11 1 3611  3 e12 1 3611  3 e13 1 3611  3 e20 1 3611  3 e21 1 3611  3 e22 1 3611  3 e23 1 3611  3 e30 1 3611  3 e31 1 3611  3 e32 1 3611  3 e33 1 3611  </span>
<span class="s0">1625 0 0 4 1526 3758 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3893  6 upper3 1 3883  </span>
<span class="s0">1626 0 0 7 1527 3882 3366 0 45 /**</span>
 <span class="s0">* Retrieves the upper 3x3 submatrix.</span>
 <span class="s0">*/ 1 4 this 3 3887  </span>
<span class="s0">1627 0 0 7 1528 3896 3371 0 0 2 4 this 3 3893  1 i 1 3614  </span>
<span class="s0">1628 0 0 7 1528 3897 3376 0 0 2 4 this 3 3887  1 i 1 3614  </span>
<span class="s0">1629 0 0 6 1529 3614 0 0 55 /**</span>
 <span class="s0">* Returns 4: the number of rows of a LMatrix4.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1630 0 0 4 1530 3758 0 0 119 /**</span>
 <span class="s0">* Replaces the indicated row of the matrix with the indicated 3-component</span>
 <span class="s0">* vector, ignoring the last column.</span>
 <span class="s0">*/ 3 4 this 3 3893  3 row 1 3614  1 v 1 3802  </span>
<span class="s0">1631 0 0 4 1530 3758 0 0 52 /**</span>
 <span class="s0">* Replaces the indicated row of the matrix.</span>
 <span class="s0">*/ 3 4 this 3 3893  3 row 1 3614  1 v 1 3832  </span>
<span class="s0">1632 0 0 4 1531 3758 0 0 119 /**</span>
 <span class="s0">* Replaces the indicated column of the matrix with the indicated 3-component</span>
 <span class="s0">* vector, ignoring the last row.</span>
 <span class="s0">*/ 3 4 this 3 3893  3 col 1 3614  1 v 1 3802  </span>
<span class="s0">1633 0 0 4 1531 3758 0 0 55 /**</span>
 <span class="s0">* Replaces the indicated column of the matrix.</span>
 <span class="s0">*/ 3 4 this 3 3893  3 col 1 3614  1 v 1 3832  </span>
<span class="s0">1634 0 0 4 1532 3758 0 0 74 /**</span>
 <span class="s0">* Stores the indicated row of the matrix as a 4-component vector.</span>
 <span class="s0">*/ 3 4 this 3 3887  10 result_vec 1 3831  3 row 1 3614  </span>
<span class="s0">1635 0 0 7 1532 3831 2873 0 77 /**</span>
 <span class="s0">* Retrieves the indicated row of the matrix as a 4-component vector.</span>
 <span class="s0">*/ 2 4 this 3 3887  3 row 1 3614  </span>
<span class="s0">1636 0 0 7 1533 3831 2873 0 80 /**</span>
 <span class="s0">* Retrieves the indicated column of the matrix as a 4-component vector.</span>
 <span class="s0">*/ 2 4 this 3 3887  3 col 1 3614  </span>
<span class="s0">1637 0 0 4 1534 3758 0 0 100 /**</span>
 <span class="s0">* Stores the row column of the matrix as a 3-component vector, ignoring the</span>
 <span class="s0">* last column.</span>
 <span class="s0">*/ 3 4 this 3 3887  10 result_vec 1 3801  3 row 1 3614  </span>
<span class="s0">1638 0 0 7 1534 3801 2466 0 103 /**</span>
 <span class="s0">* Retrieves the row column of the matrix as a 3-component vector, ignoring</span>
 <span class="s0">* the last column.</span>
 <span class="s0">*/ 2 4 this 3 3887  3 row 1 3614  </span>
<span class="s0">1639 0 0 7 1540 3801 2466 0 106 /**</span>
 <span class="s0">* Retrieves the indicated column of the matrix as a 3-component vector,</span>
 <span class="s0">* ignoring the last row.</span>
 <span class="s0">*/ 2 4 this 3 3887  3 col 1 3614  </span>
<span class="s0">1640 0 0 4 1541 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3893  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1641 0 0 6 1541 3611 0 0 0 3 4 this 3 3887  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1642 0 0 6 1542 3763 0 0 91 /**</span>
 <span class="s0">* Returns true if any component of the matrix is not-a-number, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3887  </span>
<span class="s0">1643 0 0 6 1543 3763 0 0 93 /**</span>
 <span class="s0">* Returns true if this is (close enough to) the identity matrix, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3887  </span>
<span class="s0">1644 0 0 6 1544 3611 0 0 54 /**</span>
 <span class="s0">* Returns a particular element of the matrix.</span>
 <span class="s0">*/ 3 4 this 3 3887  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1645 0 0 4 1545 3758 0 0 54 /**</span>
 <span class="s0">* Changes a particular element of the matrix.</span>
 <span class="s0">*/ 4 4 this 3 3893  3 row 1 3614  3 col 1 3614  5 value 1 3611  </span>
<span class="s0">1646 0 0 4 1546 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/ 1 4 this 3 3887  </span>
<span class="s0">1647 0 0 6 1547 3614 0 0 60 /**</span>
 <span class="s0">* Returns the number of elements in the matrix, 16.</span>
 <span class="s0">*/ 1 4 this 3 3887  </span>
<span class="s0">1648 0 0 4 1548 3758 0 0 101 /**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/ 1 4 this 3 3893  </span>
<span class="s0">1649 0 0 4 1548 3758 0 0 101 /**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/ 1 4 this 3 3887  </span>
<span class="s0">1650 0 0 4 1549 3758 0 0 101 /**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/ 1 4 this 3 3893  </span>
<span class="s0">1651 0 0 4 1549 3758 0 0 101 /**</span>
 <span class="s0">* Returns an iterator that may be used to traverse the elements of the</span>
 <span class="s0">* matrix, STL-style.</span>
 <span class="s0">*/ 1 4 this 3 3887  </span>
<span class="s0">1652 0 0 6 1550 3763 0 0 0 2 4 this 3 3887  5 other 1 3887  </span>
<span class="s0">1653 0 0 6 1551 3763 0 0 0 2 4 this 3 3887  5 other 1 3887  </span>
<span class="s0">1654 0 0 6 1552 3763 0 0 0 2 4 this 3 3887  5 other 1 3887  </span>
<span class="s0">1655 0 0 6 1553 3614 0 0 97 /**</span>
 <span class="s0">* This flavor of compare_to uses a default threshold value based on the</span>
 <span class="s0">* numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3887  5 other 1 3887  </span>
<span class="s0">1656 0 0 6 1553 3614 0 0 234 /**</span>
 <span class="s0">* Sorts matrices lexicographically, componentwise.  Returns a number less</span>
 <span class="s0">* than 0 if this matrix sorts before the other one, greater than zero if it</span>
 <span class="s0">* sorts after, 0 if they are equivalent (within the indicated tolerance).</span>
 <span class="s0">*/ 3 4 this 3 3887  5 other 1 3887  9 threshold 1 3611  </span>
<span class="s0">1657 0 0 6 1554 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3887  </span>
<span class="s0">1658 0 0 6 1554 3756 0 0 49 /**</span>
 <span class="s0">* Returns a suitable hash for phash_map.</span>
 <span class="s0">*/ 2 4 this 3 3887  9 threshold 1 3611  </span>
<span class="s0">1659 0 0 6 1555 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 2 4 this 3 3887  4 hash 1 3756  </span>
<span class="s0">1660 0 0 6 1555 3756 0 0 49 /**</span>
 <span class="s0">* Adds the vector into the running hash.</span>
 <span class="s0">*/ 3 4 this 3 3887  4 hash 1 3756  9 threshold 1 3611  </span>
<span class="s0">1661 0 0 7 1556 3831 2873 0 91 /**</span>
 <span class="s0">* 4-component vector or point times matrix.  This is a fully general</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/ 2 4 this 3 3887  1 v 1 3832  </span>
<span class="s0">1662 0 0 7 1557 3801 2466 0 162 /**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3887  1 v 1 3802  </span>
<span class="s0">1663 0 0 7 1558 3801 2466 0 143 /**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3887  1 v 1 3802  </span>
<span class="s0">1664 0 0 7 1559 3801 2466 0 169 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result.  This assumes the matrix is an orthonormal</span>
 <span class="s0">* transform.</span>
 <span class="s0">*/ 2 4 this 3 3887  1 v 1 3802  </span>
<span class="s0">1665 0 0 7 1560 3801 2466 0 142 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component)</span>
 <span class="s0">* and returns the result, as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3887  1 v 1 3802  </span>
<span class="s0">1666 0 0 4 1561 3758 0 0 91 /**</span>
 <span class="s0">* 4-component vector or point times matrix.  This is a fully general</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/ 2 4 this 3 3887  1 v 1 3831  </span>
<span class="s0">1667 0 0 4 1562 3758 0 0 139 /**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation</span>
 <span class="s0">* component).  This assumes the matrix is an affine transform.</span>
 <span class="s0">*/ 2 4 this 3 3887  1 v 1 3801  </span>
<span class="s0">1668 0 0 4 1563 3758 0 0 120 /**</span>
 <span class="s0">* The matrix transforms a 3-component point (including translation</span>
 <span class="s0">* component), as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3887  1 v 1 3801  </span>
<span class="s0">1669 0 0 4 1564 3758 0 0 142 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component).</span>
 <span class="s0">* This assumes the matrix is an orthonormal transform.</span>
 <span class="s0">*/ 2 4 this 3 3887  1 v 1 3801  </span>
<span class="s0">1670 0 0 4 1565 3758 0 0 119 /**</span>
 <span class="s0">* The matrix transforms a 3-component vector (without translation component),</span>
 <span class="s0">* as a fully general operation.</span>
 <span class="s0">*/ 2 4 this 3 3887  1 v 1 3801  </span>
<span class="s0">1671 0 0 4 1566 3758 0 0 25 // this = other1 * other2 3 4 this 3 3893  6 other1 1 3887  6 other2 1 3887  </span>
<span class="s0">1672 0 0 7 1567 3893 3462 0 0 2 4 this 3 3887  5 other 1 3887  </span>
<span class="s0">1673 0 0 7 1567 3893 3462 0 0 2 4 this 3 3887  6 scalar 1 3611  </span>
<span class="s0">1674 0 0 7 1568 3893 3462 0 0 2 4 this 3 3887  6 scalar 1 3611  </span>
<span class="s0">1675 0 0 6 1569 3893 0 0 63 /**</span>
 <span class="s0">* Performs a memberwise addition between two matrices.</span>
 <span class="s0">*/ 2 4 this 3 3893  5 other 1 3887  </span>
<span class="s0">1676 0 0 6 1570 3893 0 0 66 /**</span>
 <span class="s0">* Performs a memberwise subtraction between two matrices.</span>
 <span class="s0">*/ 2 4 this 3 3893  5 other 1 3887  </span>
<span class="s0">1677 0 0 6 1571 3893 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3893  5 other 1 3887  </span>
<span class="s0">1678 0 0 6 1571 3893 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3893  6 scalar 1 3611  </span>
<span class="s0">1679 0 0 6 1572 3893 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3893  6 scalar 1 3611  </span>
<span class="s0">1680 0 0 4 1573 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3893  5 other 1 3887  </span>
<span class="s0">1681 0 0 4 1574 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3893  5 other 1 3887  </span>
<span class="s0">1682 0 0 4 1575 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3893  </span>
<span class="s0">1683 0 0 6 1576 3763 0 0 461 /**</span>
 <span class="s0">* Computes the inverse of the other matrix, and stores the result in this</span>
 <span class="s0">* matrix.  This is a fully general operation and makes no assumptions about</span>
 <span class="s0">* the type of transform represented by the matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* The other matrix must be a different object than this matrix.  However, if</span>
 <span class="s0">* you need to invert a matrix in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the matrix was successfully inverted, false if</span>
 <span class="s0">* the was a singularity.</span>
 <span class="s0">*/ 2 4 this 3 3893  5 other 1 3887  </span>
<span class="s0">1684 0 0 6 1577 3763 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices</span>
<span class="s0">// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3893  5 other 1 3887  </span>
<span class="s0">1685 0 0 6 1578 3763 0 0 119 /**</span>
 <span class="s0">* Inverts the current matrix.  Returns true if the inverse is successful,</span>
 <span class="s0">* false if the matrix was singular.</span>
 <span class="s0">*/ 1 4 this 3 3893  </span>
<span class="s0">1686 0 0 4 1579 3758 0 0 48 /**</span>
 <span class="s0">* Computes `(*this) += other * weight`.</span>
 <span class="s0">*/ 3 4 this 3 3893  5 other 1 3887  6 weight 1 3611  </span>
<span class="s0">1687 0 0 6 1580 3887 0 0 147 /**</span>
 <span class="s0">* Returns an identity matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* This function definition must appear first, since some inline functions</span>
 <span class="s0">* below take advantage of it.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1688 0 0 6 1581 3887 0 0 46 /**</span>
 <span class="s0">* Returns an matrix filled with ones.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1689 0 0 6 1582 3887 0 0 47 /**</span>
 <span class="s0">* Returns an matrix filled with zeros.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1690 0 0 4 1583 3758 0 0 74 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 2 4 this 3 3893  5 trans 1 3802  </span>
<span class="s0">1691 0 0 4 1584 3758 0 0 122 /**</span>
 <span class="s0">* Sets mat to a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/ 4 4 this 3 3893  5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  </span>
<span class="s0">1692 0 0 4 1585 3758 0 0 166 /**</span>
 <span class="s0">* Fills mat with a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* prenormalized.</span>
 <span class="s0">*/ 4 4 this 3 3893  5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  </span>
<span class="s0">1693 0 0 4 1586 3758 0 0 97 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale in each of the</span>
 <span class="s0">* three axes.</span>
 <span class="s0">*/ 2 4 this 3 3893  5 scale 1 3802  </span>
<span class="s0">1694 0 0 4 1587 3758 0 0 99 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated shear in each of the</span>
 <span class="s0">* three planes.</span>
 <span class="s0">*/ 3 4 this 3 3893  5 shear 1 3802  2 cs 5 3627  </span>
<span class="s0">1695 0 0 4 1588 3758 0 0 78 /**</span>
 <span class="s0">* Fills mat with a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 4 4 this 3 3893  5 scale 1 3802  5 shear 1 3802  2 cs 5 3627  </span>
<span class="s0">1696 0 0 7 1589 3893 3462 0 67 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 1 5 trans 1 3802  </span>
<span class="s0">1697 0 0 7 1589 3893 3462 0 67 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated translation.</span>
 <span class="s0">*/ 3 2 tx 1 3611  2 ty 1 3611  2 tz 1 3611  </span>
<span class="s0">1698 0 0 7 1590 3893 3462 0 118 /**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.</span>
 <span class="s0">*/ 3 5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  </span>
<span class="s0">1699 0 0 7 1591 3893 3462 0 159 /**</span>
 <span class="s0">* Returns a matrix that rotates by the given angle in degrees</span>
 <span class="s0">* counterclockwise about the indicated vector.  Assumes axis has been</span>
 <span class="s0">* prenormalized.</span>
 <span class="s0">*/ 3 5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  </span>
<span class="s0">1700 0 0 7 1592 3893 3462 0 90 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/ 1 5 scale 1 3802  </span>
<span class="s0">1701 0 0 7 1592 3893 3462 0 69 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated uniform scale.</span>
 <span class="s0">*/ 1 5 scale 1 3611  </span>
<span class="s0">1702 0 0 7 1592 3893 3462 0 90 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale in each of the three</span>
 <span class="s0">* axes.</span>
 <span class="s0">*/ 3 2 sx 1 3611  2 sy 1 3611  2 sz 1 3611  </span>
<span class="s0">1703 0 0 7 1593 3893 3462 0 92 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/ 2 5 shear 1 3802  2 cs 5 3627  </span>
<span class="s0">1704 0 0 7 1593 3893 3462 0 92 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated shear in each of the three</span>
 <span class="s0">* planes.</span>
 <span class="s0">*/ 4 4 shxy 1 3611  4 shxz 1 3611  4 shyz 1 3611  2 cs 5 3627  </span>
<span class="s0">1705 0 0 7 1594 3893 3462 0 71 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 3 5 scale 1 3802  5 shear 1 3802  2 cs 5 3627  </span>
<span class="s0">1706 0 0 7 1594 3893 3462 0 71 /**</span>
 <span class="s0">* Returns a matrix that applies the indicated scale and shear.</span>
 <span class="s0">*/ 7 2 sx 1 3611  2 sy 1 3611  2 sz 1 3611  4 shxy 1 3611  4 shxz 1 3611  4 shyz 1 3611  2 cs 5 3627  </span>
<span class="s0">1707 0 0 6 1595 3887 0 0 109 /**</span>
 <span class="s0">* Returns a matrix that transforms from the Y-up coordinate system to the</span>
 <span class="s0">* Z-up coordinate system.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1708 0 0 6 1596 3887 0 0 109 /**</span>
 <span class="s0">* Returns a matrix that transforms from the Y-up coordinate system to the</span>
 <span class="s0">* Z-up coordinate system.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1709 0 0 6 1597 3887 0 0 119 /**</span>
 <span class="s0">* Returns a matrix that transforms from the indicated coordinate system to</span>
 <span class="s0">* the indicated coordinate system.</span>
 <span class="s0">*/ 2 4 from 1 3627  2 to 1 3627  </span>
<span class="s0">1710 0 0 6 1598 3763 0 0 117 /**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3887  5 other 1 3887  </span>
<span class="s0">1711 0 0 6 1598 3763 0 0 199 /**</span>
 <span class="s0">* Returns true if two matrices are memberwise equal within a specified</span>
 <span class="s0">* tolerance.  This is faster than the equivalence operator as this doesn't</span>
 <span class="s0">* have to guarantee that it is transitive.</span>
 <span class="s0">*/ 3 4 this 3 3887  5 other 1 3887  9 threshold 1 3611  </span>
<span class="s0">1712 0 0 4 1599 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3887  3 out 1 3766  </span>
<span class="s0">1713 0 0 4 1600 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3887  3 out 1 3766  12 indent_level 5 3614  </span>
<span class="s0">1714 0 0 38 1601 3762 0 0 0 1 4 this 3 3887  </span>
<span class="s0">1715 0 0 4 1602 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 2 4 this 3 3887  7 hashgen 1 3764  </span>
<span class="s0">1716 0 0 4 1602 3758 0 0 59 /**</span>
 <span class="s0">* Adds the vector to the indicated hash generator.</span>
 <span class="s0">*/ 3 4 this 3 3887  7 hashgen 1 3764  5 scale 1 3611  </span>
<span class="s0">1717 0 0 4 1603 3758 0 0 332 /**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_float32() or add_float64(),</span>
 <span class="s0">* depending on the type of floats in the matrix, regardless of the setting of</span>
 <span class="s0">* Datagram::set_stdfloat_double().  This is appropriate when you want to</span>
 <span class="s0">* write a fixed-width value to the datagram, especially when you are not</span>
 <span class="s0">* writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3887  11 destination 1 3768  </span>
<span class="s0">1718 0 0 4 1604 3758 0 0 114 /**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_float32() or get_float64().</span>
 <span class="s0">* See write_datagram_fixed().</span>
 <span class="s0">*/ 2 4 this 3 3893  4 scan 1 3770  </span>
<span class="s0">1719 0 0 4 1605 3758 0 0 205 /**</span>
 <span class="s0">* Writes the matrix to the Datagram using add_stdfloat().  This is</span>
 <span class="s0">* appropriate when you want to write the matrix using the standard width</span>
 <span class="s0">* setting, especially when you are writing a bam file.</span>
 <span class="s0">*/ 2 4 this 3 3887  11 destination 1 3768  </span>
<span class="s0">1720 0 0 4 1606 3758 0 0 67 /**</span>
 <span class="s0">* Reads the matrix from the Datagram using get_stdfloat().</span>
 <span class="s0">*/ 2 4 this 3 3893  6 source 1 3770  </span>
<span class="s0">1721 0 0 7 1607 3773 0 0 0 0 </span>
<span class="s0">1722 0 0 15 1510 3896 3371 0 0 1 6 param0 0 3898  </span>
<span class="s0">1723 0 0 4 1507 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3896  1 i 1 3614  10 assign_val 1 3611  </span>
<span class="s0">1724 0 0 6 1507 3611 0 0 0 2 4 this 3 3898  1 i 1 3614  </span>
<span class="s0">1725 0 0 6 1508 3614 0 0 58 /**</span>
 <span class="s0">* Returns 4: the number of columns of a LMatrix4.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1726 0 0 6 1509 3832 0 0 0 1 4 this 3 3898  </span>
<span class="s0">1727 0 0 15 1516 3897 3376 0 0 1 6 param0 0 3900  </span>
<span class="s0">1728 0 0 6 1513 3611 0 0 0 2 4 this 3 3900  1 i 1 3614  </span>
<span class="s0">1729 0 0 6 1514 3614 0 0 58 /**</span>
 <span class="s0">* Returns 4: the number of columns of a LMatrix4.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1730 0 0 6 1515 3832 0 0 0 1 4 this 3 3900  </span>
<span class="s0">1731 0 0 7 1611 3902 3472 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1732 0 0 23 1611 3902 3472 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3887  </span>
<span class="s0">1733 0 0 15 1611 3902 3472 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3894  </span>
<span class="s0">1734 0 0 23 1611 3902 3472 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 16 3 e00 1 3611  3 e01 1 3611  3 e02 1 3611  3 e03 1 3611  3 e10 1 3611  3 e11 1 3611  3 e12 1 3611  3 e13 1 3611  3 e20 1 3611  3 e21 1 3611  3 e22 1 3611  3 e23 1 3611  3 e30 1 3611  3 e31 1 3611  3 e32 1 3611  3 e33 1 3611  </span>
<span class="s0">1735 0 0 6 1612 3902 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3902  4 copy 1 3887  </span>
<span class="s0">1736 0 0 6 1612 3902 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3902  4 copy 1 3894  </span>
<span class="s0">1737 0 0 4 1613 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 17 4 this 3 3902  3 e00 1 3611  3 e01 1 3611  3 e02 1 3611  3 e03 1 3611  3 e10 1 3611  3 e11 1 3611  3 e12 1 3611  3 e13 1 3611  3 e20 1 3611  3 e21 1 3611  3 e22 1 3611  3 e23 1 3611  3 e30 1 3611  3 e31 1 3611  3 e32 1 3611  3 e33 1 3611  </span>
<span class="s0">1738 0 0 4 1614 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3902  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1739 0 0 6 1614 3611 0 0 0 3 4 this 3 3894  3 row 1 3614  3 col 1 3614  </span>
<span class="s0">1740 0 0 4 1615 3758 0 0 162 /**</span>
 <span class="s0">* Returns the address of the first of the nine data elements in the matrix.</span>
 <span class="s0">* The remaining elements occupy the next eight positions in row-major order.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">1741 0 0 6 1616 3614 0 0 65 /**</span>
 <span class="s0">* Returns the number of elements in the matrix, sixteen.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">1742 0 0 6 1617 3763 0 0 0 2 4 this 3 3894  5 other 1 3894  </span>
<span class="s0">1743 0 0 6 1618 3763 0 0 0 2 4 this 3 3894  5 other 1 3894  </span>
<span class="s0">1744 0 0 7 1619 3773 0 0 0 0 </span>
<span class="s0">1745 0 0 7 1630 3903 3529 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1746 0 0 15 1630 3903 3529 0 0 1 6 param0 0 3904  </span>
<span class="s0">1747 0 0 23 1630 3903 3529 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3826  </span>
<span class="s0">1748 0 0 23 1630 3903 3529 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 1 r 1 3608  4 copy 1 3799  </span>
<span class="s0">1749 0 0 23 1630 3903 3529 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 r 1 3608  1 i 1 3608  1 j 1 3608  1 k 1 3608  </span>
<span class="s0">1750 0 0 7 1631 3903 3529 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 1 v 1 3808  </span>
<span class="s0">1751 0 0 7 1632 3903 3529 0 54 /**</span>
 <span class="s0">* Returns the complex conjugate of this quat.</span>
 <span class="s0">*/ 1 4 this 3 3904  </span>
<span class="s0">1752 0 0 7 1633 3798 2388 0 60 /**</span>
 <span class="s0">* Transforms a 3-d vector by the indicated rotation</span>
 <span class="s0">*/ 2 4 this 3 3904  1 v 1 3799  </span>
<span class="s0">1753 0 0 7 1633 3825 2783 0 60 /**</span>
 <span class="s0">* Transforms a 4-d vector by the indicated rotation</span>
 <span class="s0">*/ 2 4 this 3 3904  1 v 1 3826  </span>
<span class="s0">1754 0 0 7 1634 3903 3529 0 45 /**</span>
 <span class="s0">* actual multiply call (non virtual)</span>
 <span class="s0">*/ 2 4 this 3 3904  3 rhs 1 3904  </span>
<span class="s0">1755 0 0 7 1635 3903 3529 0 0 1 4 this 3 3904  </span>
<span class="s0">1756 0 0 7 1636 3903 3529 0 0 2 4 this 3 3904  5 other 1 3904  </span>
<span class="s0">1757 0 0 7 1637 3903 3529 0 0 2 4 this 3 3904  5 other 1 3904  </span>
<span class="s0">1758 0 0 6 1638 3608 0 0 127 /**</span>
 <span class="s0">* Returns the angle between the orientation represented by this quaternion</span>
 <span class="s0">* and the other one, expressed in radians.</span>
 <span class="s0">*/ 2 4 this 3 3904  5 other 1 3904  </span>
<span class="s0">1759 0 0 6 1639 3608 0 0 127 /**</span>
 <span class="s0">* Returns the angle between the orientation represented by this quaternion</span>
 <span class="s0">* and the other one, expressed in degrees.</span>
 <span class="s0">*/ 2 4 this 3 3904  5 other 1 3904  </span>
<span class="s0">1760 0 0 7 1640 3861 3172 0 0 2 4 this 3 3903  6 param0 0 3862  </span>
<span class="s0">1761 0 0 7 1640 3872 3270 0 0 2 4 this 3 3903  6 param0 0 3866  </span>
<span class="s0">1762 0 0 7 1640 3903 3529 0 0 2 4 this 3 3904  6 param0 0 3904  </span>
<span class="s0">1763 0 0 7 1640 3903 3529 0 0 2 4 this 3 3904  6 scalar 1 3608  </span>
<span class="s0">1764 0 0 7 1641 3903 3529 0 0 2 4 this 3 3904  6 scalar 1 3608  </span>
<span class="s0">1765 0 0 6 1642 3903 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3903  6 param0 0 3904  </span>
<span class="s0">1766 0 0 7 1643 3903 3529 0 97 /**</span>
 <span class="s0">* Returns a new quaternion that represents this quaternion raised to the</span>
 <span class="s0">* given power.</span>
 <span class="s0">*/ 2 4 this 3 3904  6 param0 0 3608  </span>
<span class="s0">1767 0 0 6 1644 3763 0 0 120 /**</span>
 <span class="s0">* Returns true if two quaternions are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3904  5 other 1 3904  </span>
<span class="s0">1768 0 0 6 1644 3763 0 0 96 /**</span>
 <span class="s0">* Returns true if two quaternions are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3904  5 other 1 3904  9 threshold 1 3608  </span>
<span class="s0">1769 0 0 6 1645 3763 0 0 127 /**</span>
 <span class="s0">* Returns true if two quaternions represent the same rotation within a</span>
 <span class="s0">* default tolerance based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3904  5 other 1 3904  </span>
<span class="s0">1770 0 0 6 1646 3763 0 0 103 /**</span>
 <span class="s0">* Returns true if two quaternions represent the same rotation within a</span>
 <span class="s0">* specified tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3904  5 other 1 3904  9 threshold 1 3608  </span>
<span class="s0">1771 0 0 4 1647 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3904  6 param0 0 3766  </span>
<span class="s0">1772 0 0 4 1648 3758 0 0 43 /**</span>
 <span class="s0">* Based on the quat lib from VRPN.</span>
 <span class="s0">*/ 2 4 this 3 3904  1 m 1 3861  </span>
<span class="s0">1773 0 0 4 1648 3758 0 0 43 /**</span>
 <span class="s0">* Based on the quat lib from VRPN.</span>
 <span class="s0">*/ 2 4 this 3 3904  1 m 1 3872  </span>
<span class="s0">1774 0 0 4 1649 3758 0 0 226 /**</span>
 <span class="s0">* Sets the quaternion according to the rotation represented by the matrix.</span>
 <span class="s0">* Originally we tried an algorithm presented by Do-While Jones, but that</span>
 <span class="s0">* turned out to be broken.  This is based on the quat lib from UNC.</span>
 <span class="s0">*/ 2 4 this 3 3903  1 m 1 3862  </span>
<span class="s0">1775 0 0 4 1649 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3903  1 m 1 3866  </span>
<span class="s0">1776 0 0 4 1650 3758 0 0 132 /**</span>
 <span class="s0">* Sets the quaternion as the unit quaternion that is equivalent to these</span>
 <span class="s0">* Euler angles.  (from Real-time Rendering, p.49)</span>
 <span class="s0">*/ 3 4 this 3 3903  3 hpr 1 3799  2 cs 5 3627  </span>
<span class="s0">1777 0 0 7 1651 3798 2388 0 73 /**</span>
 <span class="s0">* Extracts the equivalent Euler angles from the unit quaternion.</span>
 <span class="s0">*/ 2 4 this 3 3904  2 cs 5 3627  </span>
<span class="s0">1778 0 0 7 1652 3807 2577 0 180 /**</span>
 <span class="s0">* This, along with get_angle(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the axis; it</span>
 <span class="s0">* is not normalized.</span>
 <span class="s0">*/ 1 4 this 3 3904  </span>
<span class="s0">1779 0 0 7 1653 3807 2577 0 169 /**</span>
 <span class="s0">* This, along with get_angle(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the</span>
 <span class="s0">* normalized axis.</span>
 <span class="s0">*/ 1 4 this 3 3904  </span>
<span class="s0">1780 0 0 6 1654 3608 0 0 343 /**</span>
 <span class="s0">* This, along with get_axis(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the angle, in</span>
 <span class="s0">* radians counterclockwise about the axis.</span>
 <span class="s0">*</span>
 <span class="s0">* It is necessary to ensure the quaternion has been normalized (for instance,</span>
 <span class="s0">* with a call to normalize()) before calling this method.</span>
 <span class="s0">*/ 1 4 this 3 3904  </span>
<span class="s0">1781 0 0 6 1655 3608 0 0 343 /**</span>
 <span class="s0">* This, along with get_axis(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the angle, in</span>
 <span class="s0">* degrees counterclockwise about the axis.</span>
 <span class="s0">*</span>
 <span class="s0">* It is necessary to ensure the quaternion has been normalized (for instance,</span>
 <span class="s0">* with a call to normalize()) before calling this method.</span>
 <span class="s0">*/ 1 4 this 3 3904  </span>
<span class="s0">1782 0 0 4 1656 3758 0 0 86 /**</span>
 <span class="s0">* angle_rad is the angle about the axis in radians.  axis must be normalized.</span>
 <span class="s0">*/ 3 4 this 3 3903  9 angle_rad 1 3608  4 axis 1 3808  </span>
<span class="s0">1783 0 0 4 1657 3758 0 0 86 /**</span>
 <span class="s0">* angle_deg is the angle about the axis in degrees.  axis must be normalized.</span>
 <span class="s0">*/ 3 4 this 3 3903  9 angle_deg 1 3608  4 axis 1 3808  </span>
<span class="s0">1784 0 0 7 1658 3807 2577 0 96 /**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as an up</span>
 <span class="s0">* vector.</span>
 <span class="s0">*/ 2 4 this 3 3904  2 cs 5 3627  </span>
<span class="s0">1785 0 0 7 1659 3807 2577 0 98 /**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as a</span>
 <span class="s0">* right vector.</span>
 <span class="s0">*/ 2 4 this 3 3904  2 cs 5 3627  </span>
<span class="s0">1786 0 0 7 1660 3807 2577 0 100 /**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as a</span>
 <span class="s0">* forward vector.</span>
 <span class="s0">*/ 2 4 this 3 3904  2 cs 5 3627  </span>
<span class="s0">1787 0 0 6 1661 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3904  </span>
<span class="s0">1788 0 0 6 1662 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3904  </span>
<span class="s0">1789 0 0 6 1663 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3904  </span>
<span class="s0">1790 0 0 6 1664 3608 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3904  </span>
<span class="s0">1791 0 0 4 1665 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3903  1 r 1 3608  </span>
<span class="s0">1792 0 0 4 1666 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3903  1 i 1 3608  </span>
<span class="s0">1793 0 0 4 1667 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3903  1 j 1 3608  </span>
<span class="s0">1794 0 0 4 1668 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3903  1 k 1 3608  </span>
<span class="s0">1795 0 0 6 1669 3763 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3903  </span>
<span class="s0">1796 0 0 6 1670 3763 0 0 466 /**</span>
 <span class="s0">* Computes the conjugate of the other quat, and stores the result in this</span>
 <span class="s0">* quat.  This is a fully general operation and makes no assumptions about the</span>
 <span class="s0">* type of transform represented by the quat.</span>
 <span class="s0">*</span>
 <span class="s0">* The other quat must be a different object than this quat.  However, if you</span>
 <span class="s0">* need to get a conjugate of a quat in place, see conjugate_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the quat was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/ 2 4 this 3 3903  5 other 1 3904  </span>
<span class="s0">1797 0 0 6 1671 3763 0 0 129 /**</span>
 <span class="s0">* Sets this to be the conjugate of the current quat.  Returns true if the</span>
 <span class="s0">* successful, false if the quat was singular.</span>
 <span class="s0">*/ 1 4 this 3 3903  </span>
<span class="s0">1798 0 0 6 1672 3763 0 0 448 /**</span>
 <span class="s0">* Computes the inverse of the other quat, and stores the result in this quat.</span>
 <span class="s0">* This is a fully general operation and makes no assumptions about the type</span>
 <span class="s0">* of transform represented by the quat.</span>
 <span class="s0">*</span>
 <span class="s0">* The other quat must be a different object than this quat.  However, if you</span>
 <span class="s0">* need to invert a quat in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the quat was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/ 2 4 this 3 3903  5 other 1 3904  </span>
<span class="s0">1799 0 0 6 1673 3763 0 0 115 /**</span>
 <span class="s0">* Inverts the current quat.  Returns true if the inverse is successful, false</span>
 <span class="s0">* if the quat was singular.</span>
 <span class="s0">*/ 1 4 this 3 3903  </span>
<span class="s0">1800 0 0 6 1674 3763 0 0 98 /**</span>
 <span class="s0">* Returns true if this quaternion represents the identity transformation: no</span>
 <span class="s0">* rotation.</span>
 <span class="s0">*/ 1 4 this 3 3904  </span>
<span class="s0">1801 0 0 6 1675 3763 0 0 110 /**</span>
 <span class="s0">* Returns true if this quaternion represents the identity transformation</span>
 <span class="s0">* within a given tolerance.</span>
 <span class="s0">*/ 2 4 this 3 3904  9 tolerance 1 3608  </span>
<span class="s0">1802 0 0 6 1676 3904 0 0 42 /**</span>
 <span class="s0">* Returns an identity quaternion.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1803 0 0 7 1677 3773 0 0 0 0 </span>
<span class="s0">1804 0 0 7 1680 3906 3578 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1805 0 0 15 1680 3906 3578 0 0 1 6 param0 0 3907  </span>
<span class="s0">1806 0 0 23 1680 3906 3578 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3832  </span>
<span class="s0">1807 0 0 23 1680 3906 3578 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 1 r 1 3611  4 copy 1 3802  </span>
<span class="s0">1808 0 0 23 1680 3906 3578 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 r 1 3611  1 i 1 3611  1 j 1 3611  1 k 1 3611  </span>
<span class="s0">1809 0 0 7 1681 3906 3578 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 1 v 1 3811  </span>
<span class="s0">1810 0 0 7 1682 3906 3578 0 54 /**</span>
 <span class="s0">* Returns the complex conjugate of this quat.</span>
 <span class="s0">*/ 1 4 this 3 3907  </span>
<span class="s0">1811 0 0 7 1683 3801 2466 0 60 /**</span>
 <span class="s0">* Transforms a 3-d vector by the indicated rotation</span>
 <span class="s0">*/ 2 4 this 3 3907  1 v 1 3802  </span>
<span class="s0">1812 0 0 7 1683 3831 2873 0 60 /**</span>
 <span class="s0">* Transforms a 4-d vector by the indicated rotation</span>
 <span class="s0">*/ 2 4 this 3 3907  1 v 1 3832  </span>
<span class="s0">1813 0 0 7 1684 3906 3578 0 45 /**</span>
 <span class="s0">* actual multiply call (non virtual)</span>
 <span class="s0">*/ 2 4 this 3 3907  3 rhs 1 3907  </span>
<span class="s0">1814 0 0 7 1685 3906 3578 0 0 1 4 this 3 3907  </span>
<span class="s0">1815 0 0 7 1686 3906 3578 0 0 2 4 this 3 3907  5 other 1 3907  </span>
<span class="s0">1816 0 0 7 1687 3906 3578 0 0 2 4 this 3 3907  5 other 1 3907  </span>
<span class="s0">1817 0 0 6 1688 3611 0 0 127 /**</span>
 <span class="s0">* Returns the angle between the orientation represented by this quaternion</span>
 <span class="s0">* and the other one, expressed in radians.</span>
 <span class="s0">*/ 2 4 this 3 3907  5 other 1 3907  </span>
<span class="s0">1818 0 0 6 1689 3611 0 0 127 /**</span>
 <span class="s0">* Returns the angle between the orientation represented by this quaternion</span>
 <span class="s0">* and the other one, expressed in degrees.</span>
 <span class="s0">*/ 2 4 this 3 3907  5 other 1 3907  </span>
<span class="s0">1819 0 0 7 1690 3882 3366 0 0 2 4 this 3 3906  6 param0 0 3883  </span>
<span class="s0">1820 0 0 7 1690 3893 3462 0 0 2 4 this 3 3906  6 param0 0 3887  </span>
<span class="s0">1821 0 0 7 1690 3906 3578 0 0 2 4 this 3 3907  6 param0 0 3907  </span>
<span class="s0">1822 0 0 7 1690 3906 3578 0 0 2 4 this 3 3907  6 scalar 1 3611  </span>
<span class="s0">1823 0 0 7 1691 3906 3578 0 0 2 4 this 3 3907  6 scalar 1 3611  </span>
<span class="s0">1824 0 0 6 1692 3906 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3906  6 param0 0 3907  </span>
<span class="s0">1825 0 0 7 1693 3906 3578 0 97 /**</span>
 <span class="s0">* Returns a new quaternion that represents this quaternion raised to the</span>
 <span class="s0">* given power.</span>
 <span class="s0">*/ 2 4 this 3 3907  6 param0 0 3611  </span>
<span class="s0">1826 0 0 6 1694 3763 0 0 120 /**</span>
 <span class="s0">* Returns true if two quaternions are memberwise equal within a default</span>
 <span class="s0">* tolerance based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3907  5 other 1 3907  </span>
<span class="s0">1827 0 0 6 1694 3763 0 0 96 /**</span>
 <span class="s0">* Returns true if two quaternions are memberwise equal within a specified</span>
 <span class="s0">* tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3907  5 other 1 3907  9 threshold 1 3611  </span>
<span class="s0">1828 0 0 6 1695 3763 0 0 127 /**</span>
 <span class="s0">* Returns true if two quaternions represent the same rotation within a</span>
 <span class="s0">* default tolerance based on the numeric type.</span>
 <span class="s0">*/ 2 4 this 3 3907  5 other 1 3907  </span>
<span class="s0">1829 0 0 6 1696 3763 0 0 103 /**</span>
 <span class="s0">* Returns true if two quaternions represent the same rotation within a</span>
 <span class="s0">* specified tolerance.</span>
 <span class="s0">*/ 3 4 this 3 3907  5 other 1 3907  9 threshold 1 3611  </span>
<span class="s0">1830 0 0 4 1697 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3907  6 param0 0 3766  </span>
<span class="s0">1831 0 0 4 1698 3758 0 0 43 /**</span>
 <span class="s0">* Based on the quat lib from VRPN.</span>
 <span class="s0">*/ 2 4 this 3 3907  1 m 1 3882  </span>
<span class="s0">1832 0 0 4 1698 3758 0 0 43 /**</span>
 <span class="s0">* Based on the quat lib from VRPN.</span>
 <span class="s0">*/ 2 4 this 3 3907  1 m 1 3893  </span>
<span class="s0">1833 0 0 4 1699 3758 0 0 226 /**</span>
 <span class="s0">* Sets the quaternion according to the rotation represented by the matrix.</span>
 <span class="s0">* Originally we tried an algorithm presented by Do-While Jones, but that</span>
 <span class="s0">* turned out to be broken.  This is based on the quat lib from UNC.</span>
 <span class="s0">*/ 2 4 this 3 3906  1 m 1 3883  </span>
<span class="s0">1834 0 0 4 1699 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3906  1 m 1 3887  </span>
<span class="s0">1835 0 0 4 1700 3758 0 0 132 /**</span>
 <span class="s0">* Sets the quaternion as the unit quaternion that is equivalent to these</span>
 <span class="s0">* Euler angles.  (from Real-time Rendering, p.49)</span>
 <span class="s0">*/ 3 4 this 3 3906  3 hpr 1 3802  2 cs 5 3627  </span>
<span class="s0">1836 0 0 7 1701 3801 2466 0 73 /**</span>
 <span class="s0">* Extracts the equivalent Euler angles from the unit quaternion.</span>
 <span class="s0">*/ 2 4 this 3 3907  2 cs 5 3627  </span>
<span class="s0">1837 0 0 7 1702 3810 2611 0 180 /**</span>
 <span class="s0">* This, along with get_angle(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the axis; it</span>
 <span class="s0">* is not normalized.</span>
 <span class="s0">*/ 1 4 this 3 3907  </span>
<span class="s0">1838 0 0 7 1703 3810 2611 0 169 /**</span>
 <span class="s0">* This, along with get_angle(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the</span>
 <span class="s0">* normalized axis.</span>
 <span class="s0">*/ 1 4 this 3 3907  </span>
<span class="s0">1839 0 0 6 1704 3611 0 0 343 /**</span>
 <span class="s0">* This, along with get_axis(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the angle, in</span>
 <span class="s0">* radians counterclockwise about the axis.</span>
 <span class="s0">*</span>
 <span class="s0">* It is necessary to ensure the quaternion has been normalized (for instance,</span>
 <span class="s0">* with a call to normalize()) before calling this method.</span>
 <span class="s0">*/ 1 4 this 3 3907  </span>
<span class="s0">1840 0 0 6 1705 3611 0 0 343 /**</span>
 <span class="s0">* This, along with get_axis(), returns the rotation represented by the</span>
 <span class="s0">* quaternion as an angle about an arbitrary axis.  This returns the angle, in</span>
 <span class="s0">* degrees counterclockwise about the axis.</span>
 <span class="s0">*</span>
 <span class="s0">* It is necessary to ensure the quaternion has been normalized (for instance,</span>
 <span class="s0">* with a call to normalize()) before calling this method.</span>
 <span class="s0">*/ 1 4 this 3 3907  </span>
<span class="s0">1841 0 0 4 1706 3758 0 0 86 /**</span>
 <span class="s0">* angle_rad is the angle about the axis in radians.  axis must be normalized.</span>
 <span class="s0">*/ 3 4 this 3 3906  9 angle_rad 1 3611  4 axis 1 3811  </span>
<span class="s0">1842 0 0 4 1707 3758 0 0 86 /**</span>
 <span class="s0">* angle_deg is the angle about the axis in degrees.  axis must be normalized.</span>
 <span class="s0">*/ 3 4 this 3 3906  9 angle_deg 1 3611  4 axis 1 3811  </span>
<span class="s0">1843 0 0 7 1708 3810 2611 0 96 /**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as an up</span>
 <span class="s0">* vector.</span>
 <span class="s0">*/ 2 4 this 3 3907  2 cs 5 3627  </span>
<span class="s0">1844 0 0 7 1709 3810 2611 0 98 /**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as a</span>
 <span class="s0">* right vector.</span>
 <span class="s0">*/ 2 4 this 3 3907  2 cs 5 3627  </span>
<span class="s0">1845 0 0 7 1710 3810 2611 0 100 /**</span>
 <span class="s0">* Returns the orientation represented by this quaternion, expressed as a</span>
 <span class="s0">* forward vector.</span>
 <span class="s0">*/ 2 4 this 3 3907  2 cs 5 3627  </span>
<span class="s0">1846 0 0 6 1711 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3907  </span>
<span class="s0">1847 0 0 6 1712 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3907  </span>
<span class="s0">1848 0 0 6 1713 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3907  </span>
<span class="s0">1849 0 0 6 1714 3611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3907  </span>
<span class="s0">1850 0 0 4 1715 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3906  1 r 1 3611  </span>
<span class="s0">1851 0 0 4 1716 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3906  1 i 1 3611  </span>
<span class="s0">1852 0 0 4 1717 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3906  1 j 1 3611  </span>
<span class="s0">1853 0 0 4 1718 3758 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3906  1 k 1 3611  </span>
<span class="s0">1854 0 0 6 1719 3763 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3906  </span>
<span class="s0">1855 0 0 6 1720 3763 0 0 466 /**</span>
 <span class="s0">* Computes the conjugate of the other quat, and stores the result in this</span>
 <span class="s0">* quat.  This is a fully general operation and makes no assumptions about the</span>
 <span class="s0">* type of transform represented by the quat.</span>
 <span class="s0">*</span>
 <span class="s0">* The other quat must be a different object than this quat.  However, if you</span>
 <span class="s0">* need to get a conjugate of a quat in place, see conjugate_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the quat was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/ 2 4 this 3 3906  5 other 1 3907  </span>
<span class="s0">1856 0 0 6 1721 3763 0 0 129 /**</span>
 <span class="s0">* Sets this to be the conjugate of the current quat.  Returns true if the</span>
 <span class="s0">* successful, false if the quat was singular.</span>
 <span class="s0">*/ 1 4 this 3 3906  </span>
<span class="s0">1857 0 0 6 1722 3763 0 0 448 /**</span>
 <span class="s0">* Computes the inverse of the other quat, and stores the result in this quat.</span>
 <span class="s0">* This is a fully general operation and makes no assumptions about the type</span>
 <span class="s0">* of transform represented by the quat.</span>
 <span class="s0">*</span>
 <span class="s0">* The other quat must be a different object than this quat.  However, if you</span>
 <span class="s0">* need to invert a quat in place, see invert_in_place.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the quat was successfully inverted, false if</span>
 <span class="s0">* there was a singularity.</span>
 <span class="s0">*/ 2 4 this 3 3906  5 other 1 3907  </span>
<span class="s0">1858 0 0 6 1723 3763 0 0 115 /**</span>
 <span class="s0">* Inverts the current quat.  Returns true if the inverse is successful, false</span>
 <span class="s0">* if the quat was singular.</span>
 <span class="s0">*/ 1 4 this 3 3906  </span>
<span class="s0">1859 0 0 6 1724 3763 0 0 98 /**</span>
 <span class="s0">* Returns true if this quaternion represents the identity transformation: no</span>
 <span class="s0">* rotation.</span>
 <span class="s0">*/ 1 4 this 3 3907  </span>
<span class="s0">1860 0 0 6 1725 3763 0 0 110 /**</span>
 <span class="s0">* Returns true if this quaternion represents the identity transformation</span>
 <span class="s0">* within a given tolerance.</span>
 <span class="s0">*/ 2 4 this 3 3907  9 tolerance 1 3611  </span>
<span class="s0">1861 0 0 6 1726 3907 0 0 42 /**</span>
 <span class="s0">* Returns an identity quaternion.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1862 0 0 7 1727 3773 0 0 0 0 </span>
<span class="s0">1863 0 0 7 1730 3909 3583 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1864 0 0 23 1730 3909 3583 0 19 /**</span>
 <span class="s0">* lmatrix3</span>
 <span class="s0">*/ 1 1 m 1 3862  </span>
<span class="s0">1865 0 0 23 1730 3909 3583 0 19 /**</span>
 <span class="s0">* lmatrix4</span>
 <span class="s0">*/ 1 1 m 1 3866  </span>
<span class="s0">1866 0 0 23 1730 3909 3583 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 1 c 1 3904  </span>
<span class="s0">1867 0 0 15 1730 3909 3583 0 0 1 6 param0 0 3910  </span>
<span class="s0">1868 0 0 23 1730 3909 3583 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3826  </span>
<span class="s0">1869 0 0 23 1730 3909 3583 0 36 /**</span>
 <span class="s0">* axis + angle (in degrees)</span>
 <span class="s0">*/ 2 4 axis 1 3808  5 angle 1 3608  </span>
<span class="s0">1870 0 0 23 1730 3909 3583 0 57 /**</span>
 <span class="s0">* Sets the rotation from the given Euler angles.</span>
 <span class="s0">*/ 3 1 h 1 3608  1 p 1 3608  1 r 1 3608  </span>
<span class="s0">1871 0 0 23 1730 3909 3583 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 r 1 3608  1 i 1 3608  1 j 1 3608  1 k 1 3608  </span>
<span class="s0">1872 0 0 7 1731 3903 3529 0 0 2 4 this 3 3910  5 other 1 3904  </span>
<span class="s0">1873 0 0 7 1731 3909 3583 0 0 2 4 this 3 3910  5 other 1 3910  </span>
<span class="s0">1874 0 0 7 1731 3909 3583 0 0 2 4 this 3 3910  6 scalar 1 3608  </span>
<span class="s0">1875 0 0 7 1732 3909 3583 0 0 2 4 this 3 3910  6 scalar 1 3608  </span>
<span class="s0">1876 0 0 7 1733 3773 0 0 0 0 </span>
<span class="s0">1877 0 0 7 1736 3912 3588 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1878 0 0 23 1736 3912 3588 0 19 /**</span>
 <span class="s0">* lmatrix3</span>
 <span class="s0">*/ 1 1 m 1 3883  </span>
<span class="s0">1879 0 0 23 1736 3912 3588 0 19 /**</span>
 <span class="s0">* lmatrix4</span>
 <span class="s0">*/ 1 1 m 1 3887  </span>
<span class="s0">1880 0 0 23 1736 3912 3588 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 1 c 1 3907  </span>
<span class="s0">1881 0 0 15 1736 3912 3588 0 0 1 6 param0 0 3913  </span>
<span class="s0">1882 0 0 23 1736 3912 3588 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3832  </span>
<span class="s0">1883 0 0 23 1736 3912 3588 0 36 /**</span>
 <span class="s0">* axis + angle (in degrees)</span>
 <span class="s0">*/ 2 4 axis 1 3811  5 angle 1 3611  </span>
<span class="s0">1884 0 0 23 1736 3912 3588 0 57 /**</span>
 <span class="s0">* Sets the rotation from the given Euler angles.</span>
 <span class="s0">*/ 3 1 h 1 3611  1 p 1 3611  1 r 1 3611  </span>
<span class="s0">1885 0 0 23 1736 3912 3588 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 r 1 3611  1 i 1 3611  1 j 1 3611  1 k 1 3611  </span>
<span class="s0">1886 0 0 7 1737 3906 3578 0 0 2 4 this 3 3913  5 other 1 3907  </span>
<span class="s0">1887 0 0 7 1737 3912 3588 0 0 2 4 this 3 3913  5 other 1 3913  </span>
<span class="s0">1888 0 0 7 1737 3912 3588 0 0 2 4 this 3 3913  6 scalar 1 3611  </span>
<span class="s0">1889 0 0 7 1738 3912 3588 0 0 2 4 this 3 3913  6 scalar 1 3611  </span>
<span class="s0">1890 0 0 7 1739 3773 0 0 0 0 </span>
<span class="s0">1891 0 0 7 1742 3915 3592 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1892 0 0 23 1742 3915 3592 0 18 /**</span>
 <span class="s0">* matrix3</span>
 <span class="s0">*/ 1 1 m 1 3862  </span>
<span class="s0">1893 0 0 23 1742 3915 3592 0 18 /**</span>
 <span class="s0">* matrix4</span>
 <span class="s0">*/ 1 1 m 1 3866  </span>
<span class="s0">1894 0 0 15 1742 3915 3592 0 0 1 6 param0 0 3916  </span>
<span class="s0">1895 0 0 23 1742 3915 3592 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 1 c 1 3904  </span>
<span class="s0">1896 0 0 23 1742 3915 3592 0 25 /**</span>
 <span class="s0">* vector + twist</span>
 <span class="s0">*/ 2 8 point_at 1 3808  5 twist 1 3608  </span>
<span class="s0">1897 0 0 23 1742 3915 3592 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 r 1 3608  1 i 1 3608  1 j 1 3608  1 k 1 3608  </span>
<span class="s0">1898 0 0 7 1743 3915 3592 0 0 2 4 this 3 3916  5 other 1 3904  </span>
<span class="s0">1899 0 0 7 1743 3915 3592 0 0 2 4 this 3 3916  5 other 1 3910  </span>
<span class="s0">1900 0 0 7 1744 3773 0 0 0 0 </span>
<span class="s0">1901 0 0 7 1747 3918 3596 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1902 0 0 23 1747 3918 3596 0 18 /**</span>
 <span class="s0">* matrix3</span>
 <span class="s0">*/ 1 1 m 1 3883  </span>
<span class="s0">1903 0 0 23 1747 3918 3596 0 18 /**</span>
 <span class="s0">* matrix4</span>
 <span class="s0">*/ 1 1 m 1 3887  </span>
<span class="s0">1904 0 0 15 1747 3918 3596 0 0 1 6 param0 0 3919  </span>
<span class="s0">1905 0 0 23 1747 3918 3596 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 1 c 1 3907  </span>
<span class="s0">1906 0 0 23 1747 3918 3596 0 25 /**</span>
 <span class="s0">* vector + twist</span>
 <span class="s0">*/ 2 8 point_at 1 3811  5 twist 1 3611  </span>
<span class="s0">1907 0 0 23 1747 3918 3596 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 r 1 3611  1 i 1 3611  1 j 1 3611  1 k 1 3611  </span>
<span class="s0">1908 0 0 7 1748 3918 3596 0 0 2 4 this 3 3919  5 other 1 3907  </span>
<span class="s0">1909 0 0 7 1748 3918 3596 0 0 2 4 this 3 3919  5 other 1 3913  </span>
<span class="s0">1910 0 0 7 1749 3773 0 0 0 0 </span>
<span class="s0">1911 0 0 15 1823 3923 3604 0 0 1 6 param0 0 3921  </span>
<span class="s0">1912 0 0 23 1823 3923 3604 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 3762  </span>
<span class="s0">1913 0 0 23 1823 3923 3604 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 name 1 3762  13 default_value 1 3924  11 description 5 3762  5 flags 5 3614  </span>
<span class="s0">1914 0 0 23 1823 3923 3604 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 name 1 3762  13 default_value 1 3762  11 description 5 3762  5 flags 5 3614  </span>
<span class="s0">1915 0 0 6 1824 3923 0 0 0 2 4 this 3 3923  5 value 1 3924  </span>
<span class="s0">1916 0 0 6 1826 3926 0 0 0 2 4 this 3 3921  1 n 1 3614  </span>
<span class="s0">1917 0 0 4 1827 3758 0 0 48 /**</span>
 <span class="s0">* Reassigns the variable's local value.</span>
 <span class="s0">*/ 2 4 this 3 3923  5 value 1 3924  </span>
<span class="s0">1918 0 0 6 1828 3924 0 0 40 /**</span>
 <span class="s0">* Returns the variable's value.</span>
 <span class="s0">*/ 1 4 this 3 3921  </span>
<span class="s0">1919 0 0 7 1829 3927 0 0 48 /**</span>
 <span class="s0">* Returns the variable's default value.</span>
 <span class="s0">*/ 1 4 this 3 3921  </span>
<span class="s0">1920 0 0 6 1825 3924 0 0 0 1 4 this 3 3921  </span>
<span class="s0">1921 0 0 6 4 3611 0 0 0 1 1 f 1 3611  </span>
<span class="s0">1922 0 0 6 4 3608 0 0 0 1 1 f 1 3608  </span>
<span class="s0">1923 0 0 6 5 3611 0 0 0 1 1 f 1 3611  </span>
<span class="s0">1924 0 0 6 5 3608 0 0 0 1 1 f 1 3608  </span>
<span class="s0">1925 0 0 6 577 3627 0 0 0 0 </span>
<span class="s0">1926 0 0 6 578 3627 0 0 0 1 3 str 1 3762  </span>
<span class="s0">1927 0 0 6 579 3762 0 0 0 1 2 cs 1 3627  </span>
<span class="s0">1928 0 0 6 580 3763 0 0 0 1 2 cs 5 3627  </span>
<span class="s0">1929 0 0 7 1289 3882 3366 0 0 1 1 a 1 3883  </span>
<span class="s0">1930 0 0 7 1289 3861 3172 0 0 1 1 a 1 3862  </span>
<span class="s0">1931 0 0 7 1289 3893 3462 0 0 1 1 a 1 3887  </span>
<span class="s0">1932 0 0 7 1289 3872 3270 0 0 1 1 a 1 3866  </span>
<span class="s0">1933 0 0 7 1290 3882 3366 0 0 1 1 a 1 3883  </span>
<span class="s0">1934 0 0 7 1290 3861 3172 0 0 1 1 a 1 3862  </span>
<span class="s0">1935 0 0 7 1290 3893 3462 0 0 1 1 a 1 3887  </span>
<span class="s0">1936 0 0 7 1290 3872 3270 0 0 1 1 a 1 3866  </span>
<span class="s0">1937 0 0 7 1290 3906 3578 0 0 1 1 a 1 3907  </span>
<span class="s0">1938 0 0 7 1290 3903 3529 0 0 1 1 a 1 3904  </span>
<span class="s0">1939 0 0 7 1621 3882 3366 0 0 2 1 m 1 3883  1 q 1 3907  </span>
<span class="s0">1940 0 0 7 1621 3861 3172 0 0 2 1 m 1 3862  1 q 1 3904  </span>
<span class="s0">1941 0 0 7 1621 3893 3462 0 0 2 1 m 1 3887  1 q 1 3907  </span>
<span class="s0">1942 0 0 7 1621 3872 3270 0 0 2 1 m 1 3866  1 q 1 3904  </span>
<span class="s0">1943 0 0 7 1621 3792 2296 0 0 2 1 v 1 3793  1 m 1 3883  </span>
<span class="s0">1944 0 0 7 1621 3789 2280 0 0 2 1 v 1 3790  1 m 1 3862  </span>
<span class="s0">1945 0 0 7 1621 3819 2683 0 0 2 1 v 1 3820  1 m 1 3883  </span>
<span class="s0">1946 0 0 7 1621 3819 2683 0 0 2 1 v 1 3820  1 m 1 3887  </span>
<span class="s0">1947 0 0 7 1621 3816 2660 0 0 2 1 v 1 3817  1 m 1 3862  </span>
<span class="s0">1948 0 0 7 1621 3816 2660 0 0 2 1 v 1 3817  1 m 1 3866  </span>
<span class="s0">1949 0 0 7 1621 3855 3068 0 0 2 1 v 1 3856  1 m 1 3887  </span>
<span class="s0">1950 0 0 7 1621 3852 3048 0 0 2 1 v 1 3853  1 m 1 3866  </span>
<span class="s0">1951 0 0 7 1621 3801 2466 0 0 2 1 v 1 3802  1 m 1 3883  </span>
<span class="s0">1952 0 0 7 1621 3798 2388 0 0 2 1 v 1 3799  1 m 1 3862  </span>
<span class="s0">1953 0 0 7 1621 3831 2873 0 0 2 1 v 1 3832  1 m 1 3887  </span>
<span class="s0">1954 0 0 7 1621 3825 2783 0 0 2 1 v 1 3826  1 m 1 3866  </span>
<span class="s0">1955 0 0 7 1621 3783 2250 0 0 2 1 v 1 3784  1 m 1 3883  </span>
<span class="s0">1956 0 0 7 1621 3780 2232 0 0 2 1 v 1 3781  1 m 1 3862  </span>
<span class="s0">1957 0 0 7 1621 3810 2611 0 0 2 1 v 1 3811  1 m 1 3883  </span>
<span class="s0">1958 0 0 7 1621 3810 2611 0 0 2 1 v 1 3811  1 m 1 3887  </span>
<span class="s0">1959 0 0 7 1621 3807 2577 0 0 2 1 v 1 3808  1 m 1 3862  </span>
<span class="s0">1960 0 0 7 1621 3807 2577 0 0 2 1 v 1 3808  1 m 1 3866  </span>
<span class="s0">1961 0 0 7 1621 3846 3010 0 0 2 1 v 1 3847  1 m 1 3887  </span>
<span class="s0">1962 0 0 7 1621 3843 2990 0 0 2 1 v 1 3844  1 m 1 3866  </span>
<span class="s0">1963 0 0 4 1622 3758 0 0 0 2 1 v 1 3792  1 m 1 3883  </span>
<span class="s0">1964 0 0 4 1622 3758 0 0 0 2 1 v 1 3789  1 m 1 3862  </span>
<span class="s0">1965 0 0 4 1622 3758 0 0 0 2 1 v 1 3819  1 m 1 3883  </span>
<span class="s0">1966 0 0 4 1622 3758 0 0 0 2 1 v 1 3819  1 m 1 3887  </span>
<span class="s0">1967 0 0 4 1622 3758 0 0 0 2 1 v 1 3816  1 m 1 3862  </span>
<span class="s0">1968 0 0 4 1622 3758 0 0 0 2 1 v 1 3816  1 m 1 3866  </span>
<span class="s0">1969 0 0 4 1622 3758 0 0 0 2 1 v 1 3801  1 m 1 3883  </span>
<span class="s0">1970 0 0 4 1622 3758 0 0 0 2 1 v 1 3798  1 m 1 3862  </span>
<span class="s0">1971 0 0 4 1622 3758 0 0 0 2 1 v 1 3831  1 m 1 3887  </span>
<span class="s0">1972 0 0 4 1622 3758 0 0 0 2 1 v 1 3825  1 m 1 3866  </span>
<span class="s0">1973 0 0 4 1622 3758 0 0 0 2 1 v 1 3783  1 m 1 3883  </span>
<span class="s0">1974 0 0 4 1622 3758 0 0 0 2 1 v 1 3780  1 m 1 3862  </span>
<span class="s0">1975 0 0 4 1622 3758 0 0 0 2 1 v 1 3810  1 m 1 3883  </span>
<span class="s0">1976 0 0 4 1622 3758 0 0 0 2 1 v 1 3810  1 m 1 3887  </span>
<span class="s0">1977 0 0 4 1622 3758 0 0 0 2 1 v 1 3807  1 m 1 3862  </span>
<span class="s0">1978 0 0 4 1622 3758 0 0 0 2 1 v 1 3807  1 m 1 3866  </span>
<span class="s0">1979 0 0 4 1623 3758 0 0 0 2 4 dest 1 3768  5 value 1 3883  </span>
<span class="s0">1980 0 0 4 1623 3758 0 0 0 2 4 dest 1 3768  5 value 1 3862  </span>
<span class="s0">1981 0 0 4 1623 3758 0 0 0 2 4 dest 1 3768  5 value 1 3887  </span>
<span class="s0">1982 0 0 4 1623 3758 0 0 0 2 4 dest 1 3768  5 value 1 3866  </span>
<span class="s0">1983 0 0 4 1624 3758 0 0 0 2 6 result 1 3882  6 source 1 3770  </span>
<span class="s0">1984 0 0 4 1624 3758 0 0 0 2 6 result 1 3861  6 source 1 3770  </span>
<span class="s0">1985 0 0 4 1624 3758 0 0 0 2 6 result 1 3893  6 source 1 3770  </span>
<span class="s0">1986 0 0 4 1624 3758 0 0 0 2 6 result 1 3872  6 source 1 3770  </span>
<span class="s0">1987 0 0 4 1625 3758 0 0 0 4 3 mat 1 3882  5 scale 1 3802  3 hpr 1 3802  2 cs 5 3627  </span>
<span class="s0">1988 0 0 4 1625 3758 0 0 0 5 3 mat 1 3882  5 scale 1 3802  5 shear 1 3802  3 hpr 1 3802  2 cs 5 3627  </span>
<span class="s0">1989 0 0 4 1625 3758 0 0 0 4 3 mat 1 3861  5 scale 1 3799  3 hpr 1 3799  2 cs 5 3627  </span>
<span class="s0">1990 0 0 4 1625 3758 0 0 0 5 3 mat 1 3861  5 scale 1 3799  5 shear 1 3799  3 hpr 1 3799  2 cs 5 3627  </span>
<span class="s0">1991 0 0 4 1625 3758 0 0 0 5 3 mat 1 3893  5 scale 1 3802  3 hpr 1 3802  9 translate 1 3802  2 cs 5 3627  </span>
<span class="s0">1992 0 0 4 1625 3758 0 0 0 6 3 mat 1 3893  5 scale 1 3802  5 shear 1 3802  3 hpr 1 3802  9 translate 1 3802  2 cs 5 3627  </span>
<span class="s0">1993 0 0 4 1625 3758 0 0 0 3 3 mat 1 3893  10 components 1 3928  2 cs 5 3627  </span>
<span class="s0">1994 0 0 4 1625 3758 0 0 0 5 3 mat 1 3872  5 scale 1 3799  3 hpr 1 3799  9 translate 1 3799  2 cs 5 3627  </span>
<span class="s0">1995 0 0 4 1625 3758 0 0 0 6 3 mat 1 3872  5 scale 1 3799  5 shear 1 3799  3 hpr 1 3799  9 translate 1 3799  2 cs 5 3627  </span>
<span class="s0">1996 0 0 4 1625 3758 0 0 0 3 3 mat 1 3872  10 components 1 3930  2 cs 5 3627  </span>
<span class="s0">1997 0 0 6 1626 3763 0 0 0 4 3 mat 1 3883  5 scale 1 3801  3 hpr 1 3801  2 cs 5 3627  </span>
<span class="s0">1998 0 0 6 1626 3763 0 0 0 5 3 mat 1 3883  5 scale 1 3801  5 shear 1 3801  3 hpr 1 3801  2 cs 5 3627  </span>
<span class="s0">1999 0 0 6 1626 3763 0 0 0 4 3 mat 1 3862  5 scale 1 3798  3 hpr 1 3798  2 cs 5 3627  </span>
<span class="s0">2000 0 0 6 1626 3763 0 0 0 5 3 mat 1 3862  5 scale 1 3798  5 shear 1 3798  3 hpr 1 3798  2 cs 5 3627  </span>
<span class="s0">2001 0 0 6 1626 3763 0 0 0 5 3 mat 1 3887  5 scale 1 3801  3 hpr 1 3801  9 translate 1 3801  2 cs 5 3627  </span>
<span class="s0">2002 0 0 6 1626 3763 0 0 0 6 3 mat 1 3887  5 scale 1 3801  5 shear 1 3801  3 hpr 1 3801  9 translate 1 3801  2 cs 5 3627  </span>
<span class="s0">2003 0 0 6 1626 3763 0 0 0 3 3 mat 1 3887  10 components 1 3932  2 CS 5 3627  </span>
<span class="s0">2004 0 0 6 1626 3763 0 0 0 5 3 mat 1 3866  5 scale 1 3798  3 hpr 1 3798  9 translate 1 3798  2 cs 5 3627  </span>
<span class="s0">2005 0 0 6 1626 3763 0 0 0 6 3 mat 1 3866  5 scale 1 3798  5 shear 1 3798  3 hpr 1 3798  9 translate 1 3798  2 cs 5 3627  </span>
<span class="s0">2006 0 0 6 1626 3763 0 0 0 3 3 mat 1 3866  10 components 1 3933  2 CS 5 3627  </span>
<span class="s0">2007 0 0 6 1627 3763 0 0 0 5 3 mat 1 3883  5 scale 1 3801  5 shear 1 3801  3 hpr 1 3801  2 cs 5 3627  </span>
<span class="s0">2008 0 0 6 1627 3763 0 0 0 5 3 mat 1 3862  5 scale 1 3798  5 shear 1 3798  3 hpr 1 3798  2 cs 5 3627  </span>
<span class="s0">2009 0 0 7 1628 3801 2466 0 0 1 7 old_hpr 1 3802  </span>
<span class="s0">2010 0 0 7 1628 3798 2388 0 0 1 7 old_hpr 1 3799  </span>
<span class="s0">329</span>
<span class="s0">3605 11 MathNumbers 0 141313 11 MathNumbers 11 MathNumbers 0 0 0 1 2011 2012 0 0 0 0 0 0 0 0</span>

<span class="s0">3606 10 LVecBase2f 0 141313 10 LVecBase2f 10 LVecBase2f 0 0 0 1 2015 2082 2 3934 3935 66 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 0 0 0 0 1 3607 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3607 0 0 794624 12 LVecBase2f:: 0 3606 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2f::num_components 0</span>
<span class="s0">2 6 is_int 18 LVecBase2f::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3608 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3609 10 LVecBase2d 0 141313 10 LVecBase2d 10 LVecBase2d 0 0 0 1 2083 2150 2 3936 3937 66 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 0 0 0 0 1 3610 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3610 0 0 794624 12 LVecBase2d:: 0 3609 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2d::num_components 0</span>
<span class="s0">2 6 is_int 18 LVecBase2d::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3611 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3612 10 LVecBase2i 0 141313 10 LVecBase2i 10 LVecBase2i 0 0 0 1 2151 2214 2 3938 3939 62 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 0 0 0 0 1 3613 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3613 0 0 794624 12 LVecBase2i:: 0 3612 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2i::num_components 0</span>
<span class="s0">2 6 is_int 18 LVecBase2i::is_int 0</span>
<span class="s0">1 0 0</span>

<span class="s0">3614 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3615 9 LVector2f 0 141313 9 LVector2f 9 LVector2f 0 0 0 1 2215 2232 0 16 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 0 0 1 0 3606 0 0 0 0 49</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component vector offset.</span>
 <span class="s0">*/</span>

<span class="s0">3616 9 LVector2d 0 141313 9 LVector2d 9 LVector2d 0 0 0 1 2233 2250 0 16 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 0 0 1 0 3609 0 0 0 0 49</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component vector offset.</span>
 <span class="s0">*/</span>

<span class="s0">3617 9 LVector2i 0 141313 9 LVector2i 9 LVector2i 0 0 0 1 2251 2264 0 12 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 0 0 1 0 3612 0 0 0 0 49</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component vector offset.</span>
 <span class="s0">*/</span>

<span class="s0">3618 8 LPoint2f 0 141313 8 LPoint2f 8 LPoint2f 0 0 0 1 2265 2280 0 14 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 0 0 1 0 3606 0 0 0 0 50</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">3619 8 LPoint2d 0 141313 8 LPoint2d 8 LPoint2d 0 0 0 1 2281 2296 0 14 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 0 0 1 0 3609 0 0 0 0 50</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">3620 8 LPoint2i 0 141313 8 LPoint2i 8 LPoint2i 0 0 0 1 2297 2310 0 12 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 0 0 1 0 3612 0 0 0 0 50</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">3621 10 LVecBase3f 0 141313 10 LVecBase3f 10 LVecBase3f 0 0 0 1 2311 2388 6 3940 3941 3942 3943 3944 3945 76 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 0 0 0 0 1 3622 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3622 0 0 794624 12 LVecBase3f:: 0 3621 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3f::num_components 0</span>
<span class="s0">3 6 is_int 18 LVecBase3f::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3623 10 LVecBase3d 0 141313 10 LVecBase3d 10 LVecBase3d 0 0 0 1 2389 2466 6 3946 3947 3948 3949 3950 3951 76 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 0 0 0 0 1 3624 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3624 0 0 794624 12 LVecBase3d:: 0 3623 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3d::num_components 0</span>
<span class="s0">3 6 is_int 18 LVecBase3d::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3625 10 LVecBase3i 0 141313 10 LVecBase3i 10 LVecBase3i 0 0 0 1 2467 2539 6 3952 3953 3954 3955 3956 3957 71 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 0 0 0 0 1 3626 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3626 0 0 794624 12 LVecBase3i:: 0 3625 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3i::num_components 0</span>
<span class="s0">3 6 is_int 18 LVecBase3i::is_int 0</span>
<span class="s0">1 0 0</span>

<span class="s0">3627 16 CoordinateSystem 0 532481 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210</span>
<span class="s0">// The CS_default entry does not refer to a particular coordinate system,</span>
<span class="s0">// but rather to the value stored in default_coordinate_system, which in</span>
<span class="s0">// turn is loaded from the config variable &quot;coordinate-system&quot;.</span>
<span class="s0">0 12 CS_zup_right 12 CS_zup_right 21</span>
<span class="s0">// Z-Up, Right-handed</span>
<span class="s0">1 12 CS_yup_right 12 CS_yup_right 21</span>
<span class="s0">// Y-Up, Right-handed</span>
<span class="s0">2 11 CS_zup_left 11 CS_zup_left 20</span>
<span class="s0">// Z-Up, Left-handed</span>
<span class="s0">3 11 CS_yup_left 11 CS_yup_left 20</span>
<span class="s0">// Y-Up, Left-handed</span>
<span class="s0">4 10 CS_invalid 10 CS_invalid 156</span>
<span class="s0">// CS_invalid is not a coordinate system at all.  It can be used in user-</span>
<span class="s0">// input processing code to indicate a contradictory coordinate system</span>
<span class="s0">// request.</span>
<span class="s0">5 0 0</span>

<span class="s0">3628 9 LVector3f 0 141313 9 LVector3f 9 LVector3f 0 0 0 1 2544 2577 3 3958 3959 3960 32 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 0 0 1 0 3621 0 0 0 0 338</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component vector distance (as opposed to a three-component</span>
 <span class="s0">* point, which represents a particular point in space).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3629 9 LVector3d 0 141313 9 LVector3d 9 LVector3d 0 0 0 1 2578 2611 3 3961 3962 3963 32 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 0 0 1 0 3623 0 0 0 0 338</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component vector distance (as opposed to a three-component</span>
 <span class="s0">* point, which represents a particular point in space).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3630 9 LVector3i 0 141313 9 LVector3i 9 LVector3i 0 0 0 1 2612 2637 3 3964 3965 3966 24 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 0 0 1 0 3625 0 0 0 0 338</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component vector distance (as opposed to a three-component</span>
 <span class="s0">* point, which represents a particular point in space).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3631 8 LPoint3f 0 141313 8 LPoint3f 8 LPoint3f 0 0 0 1 2638 2660 3 3967 3968 3969 21 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 0 0 1 0 3621 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3632 8 LPoint3d 0 141313 8 LPoint3d 8 LPoint3d 0 0 0 1 2661 2683 3 3970 3971 3972 21 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 0 0 1 0 3623 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3633 8 LPoint3i 0 141313 8 LPoint3i 8 LPoint3i 0 0 0 1 2684 2704 3 3973 3974 3975 19 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 0 0 1 0 3625 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3634 10 LVecBase4f 0 141313 10 LVecBase4f 10 LVecBase4f 0 0 0 1 2705 2783 5 3976 3977 3978 3979 3980 77 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 0 0 0 0 1 3635 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3635 0 0 794624 12 LVecBase4f:: 0 3634 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4f::num_components 0</span>
<span class="s0">4 6 is_int 18 LVecBase4f::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3636 19 UnalignedLVecBase4f 0 141313 19 UnalignedLVecBase4f 19 UnalignedLVecBase4f 0 0 0 1 2784 2794 0 9 2785 2786 2787 2788 2789 2790 2791 2792 2793 0 0 0 0 1 3637 391</span>
<span class="s0">/**</span>
 <span class="s0">* This is an &quot;unaligned&quot; LVecBase4.  It has no functionality other than to</span>
 <span class="s0">* store numbers, and it will pack them in as tightly as possible, avoiding</span>
 <span class="s0">* any SSE2 alignment requirements shared by the primary LVecBase4 class.</span>
 <span class="s0">*</span>
 <span class="s0">* Use it only when you need to pack numbers tightly without respect to</span>
 <span class="s0">* alignment, and then copy it to a proper LVecBase4 to get actual use from</span>
 <span class="s0">* it.</span>
 <span class="s0">*/</span>

<span class="s0">3637 0 0 794624 21 UnalignedLVecBase4f:: 0 3636 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4f::num_components 0</span>
<span class="s0">4 6 is_int 27 UnalignedLVecBase4f::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3638 10 LVecBase4d 0 141313 10 LVecBase4d 10 LVecBase4d 0 0 0 1 2795 2873 5 3981 3982 3983 3984 3985 77 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 0 0 0 0 1 3639 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3639 0 0 794624 12 LVecBase4d:: 0 3638 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4d::num_components 0</span>
<span class="s0">4 6 is_int 18 LVecBase4d::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3640 19 UnalignedLVecBase4d 0 141313 19 UnalignedLVecBase4d 19 UnalignedLVecBase4d 0 0 0 1 2874 2884 0 9 2875 2876 2877 2878 2879 2880 2881 2882 2883 0 0 0 0 1 3641 391</span>
<span class="s0">/**</span>
 <span class="s0">* This is an &quot;unaligned&quot; LVecBase4.  It has no functionality other than to</span>
 <span class="s0">* store numbers, and it will pack them in as tightly as possible, avoiding</span>
 <span class="s0">* any SSE2 alignment requirements shared by the primary LVecBase4 class.</span>
 <span class="s0">*</span>
 <span class="s0">* Use it only when you need to pack numbers tightly without respect to</span>
 <span class="s0">* alignment, and then copy it to a proper LVecBase4 to get actual use from</span>
 <span class="s0">* it.</span>
 <span class="s0">*/</span>

<span class="s0">3641 0 0 794624 21 UnalignedLVecBase4d:: 0 3640 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4d::num_components 0</span>
<span class="s0">4 6 is_int 27 UnalignedLVecBase4d::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3642 10 LVecBase4i 0 141313 10 LVecBase4i 10 LVecBase4i 0 0 0 1 2885 2959 5 3986 3987 3988 3989 3990 73 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 0 0 0 0 1 3643 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3643 0 0 794624 12 LVecBase4i:: 0 3642 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4i::num_components 0</span>
<span class="s0">4 6 is_int 18 LVecBase4i::is_int 0</span>
<span class="s0">1 0 0</span>

<span class="s0">3644 19 UnalignedLVecBase4i 0 141313 19 UnalignedLVecBase4i 19 UnalignedLVecBase4i 0 0 0 1 2960 2970 0 9 2961 2962 2963 2964 2965 2966 2967 2968 2969 0 0 0 0 1 3645 391</span>
<span class="s0">/**</span>
 <span class="s0">* This is an &quot;unaligned&quot; LVecBase4.  It has no functionality other than to</span>
 <span class="s0">* store numbers, and it will pack them in as tightly as possible, avoiding</span>
 <span class="s0">* any SSE2 alignment requirements shared by the primary LVecBase4 class.</span>
 <span class="s0">*</span>
 <span class="s0">* Use it only when you need to pack numbers tightly without respect to</span>
 <span class="s0">* alignment, and then copy it to a proper LVecBase4 to get actual use from</span>
 <span class="s0">* it.</span>
 <span class="s0">*/</span>

<span class="s0">3645 0 0 794624 21 UnalignedLVecBase4i:: 0 3644 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4i::num_components 0</span>
<span class="s0">4 6 is_int 27 UnalignedLVecBase4i::is_int 0</span>
<span class="s0">1 0 0</span>

<span class="s0">3646 9 LVector4f 0 141313 9 LVector4f 9 LVector4f 0 0 0 1 2971 2990 2 3991 3992 18 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 0 0 1 0 3634 0 0 0 0 52</span>
<span class="s0">/**</span>
 <span class="s0">* This is a four-component vector distance.</span>
 <span class="s0">*/</span>

<span class="s0">3647 9 LVector4d 0 141313 9 LVector4d 9 LVector4d 0 0 0 1 2991 3010 2 3993 3994 18 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 0 0 1 0 3638 0 0 0 0 52</span>
<span class="s0">/**</span>
 <span class="s0">* This is a four-component vector distance.</span>
 <span class="s0">*/</span>

<span class="s0">3648 9 LVector4i 0 141313 9 LVector4i 9 LVector4i 0 0 0 1 3011 3028 2 3995 3996 16 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 0 0 1 0 3642 0 0 0 0 52</span>
<span class="s0">/**</span>
 <span class="s0">* This is a four-component vector distance.</span>
 <span class="s0">*/</span>

<span class="s0">3649 8 LPoint4f 0 141313 8 LPoint4f 8 LPoint4f 0 0 0 1 3029 3048 2 3997 3998 18 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 0 0 1 0 3634 0 0 0 0 51</span>
<span class="s0">/**</span>
 <span class="s0">* This is a four-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">3650 8 LPoint4d 0 141313 8 LPoint4d 8 LPoint4d 0 0 0 1 3049 3068 2 3999 4000 18 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 0 0 1 0 3638 0 0 0 0 51</span>
<span class="s0">/**</span>
 <span class="s0">* This is a four-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">3651 8 LPoint4i 0 141313 8 LPoint4i 8 LPoint4i 0 0 0 1 3069 3086 2 4001 4002 16 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 0 0 1 0 3642 0 0 0 0 51</span>
<span class="s0">/**</span>
 <span class="s0">* This is a four-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">3652 9 LMatrix3f 0 141313 9 LMatrix3f 9 LMatrix3f 0 0 0 1 3097 3172 2 4003 4004 74 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 4 4011 4012 4013 4014 0 0 0 3 3653 3654 3655 231</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 3-by-3 transform matrix.  It typically will represent either a</span>
 <span class="s0">* rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix</span>
 <span class="s0">* (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.</span>
 <span class="s0">*/</span>

<span class="s0">3653 0 0 794624 11 LMatrix3f:: 0 3652 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3f::num_components 0</span>
<span class="s0">9 6 is_int 17 LMatrix3f::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3654 3 Row 0 403457 14 LMatrix3f::Row 14 LMatrix3f::Row 3652 0 0 1 3090 3091 0 2 3087 3088 0 1 3089 0 0 0 66</span>
<span class="s0">// These helper classes are used to support two-level operator [].</span>

<span class="s0">3655 4 CRow 0 403457 15 LMatrix3f::CRow 15 LMatrix3f::CRow 3652 0 0 1 3095 3096 0 2 3092 3093 0 1 3094 0 0 0 0</span>

<span class="s0">3656 9 LMatrix4f 0 141313 9 LMatrix4f 9 LMatrix4f 0 0 0 1 3185 3270 2 4005 4006 84 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3 4015 4016 4017 0 0 0 3 3657 3658 3659 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">3657 0 0 794624 11 LMatrix4f:: 0 3656 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4f::num_components 0</span>
<span class="s0">16 6 is_int 17 LMatrix4f::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3658 3 Row 0 403457 14 LMatrix4f::Row 14 LMatrix4f::Row 3656 0 0 1 3178 3179 0 2 3175 3176 0 1 3177 0 0 0 66</span>
<span class="s0">// These helper classes are used to support two-level operator [].</span>

<span class="s0">3659 4 CRow 0 403457 15 LMatrix4f::CRow 15 LMatrix4f::CRow 3656 0 0 1 3183 3184 0 2 3180 3181 0 1 3182 0 0 0 0</span>

<span class="s0">3660 18 UnalignedLMatrix4f 0 141313 18 UnalignedLMatrix4f 18 UnalignedLMatrix4f 0 0 0 1 3271 3280 0 8 3272 3273 3274 3275 3276 3277 3278 3279 0 0 0 0 1 3661 385</span>
<span class="s0">/**</span>
 <span class="s0">* This is an &quot;unaligned&quot; LMatrix4.  It has no functionality other than to</span>
 <span class="s0">* store numbers, and it will pack them in as tightly as possible, avoiding</span>
 <span class="s0">* any SSE2 alignment requirements shared by the primary LMatrix4 class.</span>
 <span class="s0">*</span>
 <span class="s0">* Use it only when you need to pack numbers tightly without respect to</span>
 <span class="s0">* alignment, and then copy it to a proper LMatrix4 to get actual use from it.</span>
 <span class="s0">*/</span>

<span class="s0">3661 0 0 794624 20 UnalignedLMatrix4f:: 0 3660 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4f::num_components 0</span>
<span class="s0">16 0 0</span>

<span class="s0">3662 9 LMatrix3d 0 141313 9 LMatrix3d 9 LMatrix3d 0 0 0 1 3291 3366 2 4007 4008 74 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 4 4018 4019 4020 4021 0 0 0 3 3663 3664 3665 231</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 3-by-3 transform matrix.  It typically will represent either a</span>
 <span class="s0">* rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix</span>
 <span class="s0">* (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.</span>
 <span class="s0">*/</span>

<span class="s0">3663 0 0 794624 11 LMatrix3d:: 0 3662 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3d::num_components 0</span>
<span class="s0">9 6 is_int 17 LMatrix3d::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3664 3 Row 0 403457 14 LMatrix3d::Row 14 LMatrix3d::Row 3662 0 0 1 3284 3285 0 2 3281 3282 0 1 3283 0 0 0 66</span>
<span class="s0">// These helper classes are used to support two-level operator [].</span>

<span class="s0">3665 4 CRow 0 403457 15 LMatrix3d::CRow 15 LMatrix3d::CRow 3662 0 0 1 3289 3290 0 2 3286 3287 0 1 3288 0 0 0 0</span>

<span class="s0">3666 9 LMatrix4d 0 141313 9 LMatrix4d 9 LMatrix4d 0 0 0 1 3377 3462 2 4009 4010 84 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3 4022 4023 4024 0 0 0 3 3667 3668 3669 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">3667 0 0 794624 11 LMatrix4d:: 0 3666 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4d::num_components 0</span>
<span class="s0">16 6 is_int 17 LMatrix4d::is_int 0</span>
<span class="s0">0 0 0</span>

<span class="s0">3668 3 Row 0 403457 14 LMatrix4d::Row 14 LMatrix4d::Row 3666 0 0 1 3370 3371 0 2 3367 3368 0 1 3369 0 0 0 66</span>
<span class="s0">// These helper classes are used to support two-level operator [].</span>

<span class="s0">3669 4 CRow 0 403457 15 LMatrix4d::CRow 15 LMatrix4d::CRow 3666 0 0 1 3375 3376 0 2 3372 3373 0 1 3374 0 0 0 0</span>

<span class="s0">3670 18 UnalignedLMatrix4d 0 141313 18 UnalignedLMatrix4d 18 UnalignedLMatrix4d 0 0 0 1 3463 3472 0 8 3464 3465 3466 3467 3468 3469 3470 3471 0 0 0 0 1 3671 385</span>
<span class="s0">/**</span>
 <span class="s0">* This is an &quot;unaligned&quot; LMatrix4.  It has no functionality other than to</span>
 <span class="s0">* store numbers, and it will pack them in as tightly as possible, avoiding</span>
 <span class="s0">* any SSE2 alignment requirements shared by the primary LMatrix4 class.</span>
 <span class="s0">*</span>
 <span class="s0">* Use it only when you need to pack numbers tightly without respect to</span>
 <span class="s0">* alignment, and then copy it to a proper LMatrix4 to get actual use from it.</span>
 <span class="s0">*/</span>

<span class="s0">3671 0 0 794624 20 UnalignedLMatrix4d:: 0 3670 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4d::num_components 0</span>
<span class="s0">16 0 0</span>

<span class="s0">3672 12 LQuaternionf 0 141313 12 LQuaternionf 12 LQuaternionf 0 0 0 1 3481 3529 0 47 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 0 0 1 0 3634 0 0 0 0 44</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base quaternion class</span>
 <span class="s0">*/</span>

<span class="s0">3673 12 LQuaterniond 0 141313 12 LQuaterniond 12 LQuaterniond 0 0 0 1 3530 3578 0 47 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3574 3575 3576 3577 0 0 1 0 3638 0 0 0 0 44</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base quaternion class</span>
 <span class="s0">*/</span>

<span class="s0">3674 10 LRotationf 0 141313 10 LRotationf 10 LRotationf 0 0 0 1 3579 3583 0 3 3580 3581 3582 0 0 1 0 3672 0 0 0 0 61</span>
<span class="s0">/**</span>
 <span class="s0">* This is a unit quaternion representing a rotation.</span>
 <span class="s0">*/</span>

<span class="s0">3675 10 LRotationd 0 141313 10 LRotationd 10 LRotationd 0 0 0 1 3584 3588 0 3 3585 3586 3587 0 0 1 0 3673 0 0 0 0 61</span>
<span class="s0">/**</span>
 <span class="s0">* This is a unit quaternion representing a rotation.</span>
 <span class="s0">*/</span>

<span class="s0">3676 13 LOrientationf 0 141313 13 LOrientationf 13 LOrientationf 0 0 0 1 3589 3592 0 2 3590 3591 0 0 1 0 3672 0 0 0 0 65</span>
<span class="s0">/**</span>
 <span class="s0">* This is a unit quaternion representing an orientation.</span>
 <span class="s0">*/</span>

<span class="s0">3677 13 LOrientationd 0 141313 13 LOrientationd 13 LOrientationd 0 0 0 1 3593 3596 0 2 3594 3595 0 0 1 0 3673 0 0 0 0 65</span>
<span class="s0">/**</span>
 <span class="s0">* This is a unit quaternion representing an orientation.</span>
 <span class="s0">*/</span>

<span class="s0">3678 8 LVertexf 0 2105345 8 LVertexf 8 LVertexf 0 0 3631 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3679 8 LNormalf 0 2105345 8 LNormalf 8 LNormalf 0 0 3628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3680 10 LTexCoordf 0 2105345 10 LTexCoordf 10 LTexCoordf 0 0 3618 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3681 11 LTexCoord3f 0 2105345 11 LTexCoord3f 11 LTexCoord3f 0 0 3631 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3682 7 LColorf 0 2105345 7 LColorf 7 LColorf 0 0 3634 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3683 10 LRGBColorf 0 2105345 10 LRGBColorf 10 LRGBColorf 0 0 3621 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3684 8 LVertexd 0 2105345 8 LVertexd 8 LVertexd 0 0 3632 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3685 8 LNormald 0 2105345 8 LNormald 8 LNormald 0 0 3629 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3686 10 LTexCoordd 0 2105345 10 LTexCoordd 10 LTexCoordd 0 0 3619 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3687 11 LTexCoord3d 0 2105345 11 LTexCoord3d 11 LTexCoord3d 0 0 3632 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3688 7 LColord 0 2105345 7 LColord 7 LColord 0 0 3638 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3689 10 LRGBColord 0 2105345 10 LRGBColord 10 LRGBColord 0 0 3623 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3690 5 Mat4F 0 2105345 5 Mat4F 5 Mat4F 0 0 3656 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3691 5 Mat3F 0 2105345 5 Mat3F 5 Mat3F 0 0 3652 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3692 7 VBase4F 0 2105345 7 VBase4F 7 VBase4F 0 0 3634 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3693 5 Vec4F 0 2105345 5 Vec4F 5 Vec4F 0 0 3646 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3694 7 Point4F 0 2105345 7 Point4F 7 Point4F 0 0 3649 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3695 7 VBase3F 0 2105345 7 VBase3F 7 VBase3F 0 0 3621 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3696 5 Vec3F 0 2105345 5 Vec3F 5 Vec3F 0 0 3628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3697 7 Point3F 0 2105345 7 Point3F 7 Point3F 0 0 3631 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3698 7 VBase2F 0 2105345 7 VBase2F 7 VBase2F 0 0 3606 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3699 5 Vec2F 0 2105345 5 Vec2F 5 Vec2F 0 0 3615 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3700 7 Point2F 0 2105345 7 Point2F 7 Point2F 0 0 3618 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3701 5 QuatF 0 2105345 5 QuatF 5 QuatF 0 0 3672 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3702 5 Mat4D 0 2105345 5 Mat4D 5 Mat4D 0 0 3666 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3703 5 Mat3D 0 2105345 5 Mat3D 5 Mat3D 0 0 3662 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3704 7 VBase4D 0 2105345 7 VBase4D 7 VBase4D 0 0 3638 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3705 5 Vec4D 0 2105345 5 Vec4D 5 Vec4D 0 0 3647 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3706 7 Point4D 0 2105345 7 Point4D 7 Point4D 0 0 3650 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3707 7 VBase3D 0 2105345 7 VBase3D 7 VBase3D 0 0 3623 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3708 5 Vec3D 0 2105345 5 Vec3D 5 Vec3D 0 0 3629 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3709 7 Point3D 0 2105345 7 Point3D 7 Point3D 0 0 3632 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3710 7 VBase2D 0 2105345 7 VBase2D 7 VBase2D 0 0 3609 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3711 5 Vec2D 0 2105345 5 Vec2D 5 Vec2D 0 0 3616 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3712 7 Point2D 0 2105345 7 Point2D 7 Point2D 0 0 3619 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3713 5 QuatD 0 2105345 5 QuatD 5 QuatD 0 0 3673 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3714 9 LVecBase2 0 2105345 9 LVecBase2 9 LVecBase2 0 0 3606 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3715 7 LPoint2 0 2105345 7 LPoint2 7 LPoint2 0 0 3618 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3716 8 LVector2 0 2105345 8 LVector2 8 LVector2 0 0 3615 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3717 9 LVecBase3 0 2105345 9 LVecBase3 9 LVecBase3 0 0 3621 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3718 7 LPoint3 0 2105345 7 LPoint3 7 LPoint3 0 0 3631 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3719 8 LVector3 0 2105345 8 LVector3 8 LVector3 0 0 3628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3720 9 LVecBase4 0 2105345 9 LVecBase4 9 LVecBase4 0 0 3634 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3721 7 LPoint4 0 2105345 7 LPoint4 7 LPoint4 0 0 3649 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3722 8 LVector4 0 2105345 8 LVector4 8 LVector4 0 0 3646 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3723 11 LQuaternion 0 2105345 11 LQuaternion 11 LQuaternion 0 0 3672 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3724 9 LRotation 0 2105345 9 LRotation 9 LRotation 0 0 3674 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3725 12 LOrientation 0 2105345 12 LOrientation 12 LOrientation 0 0 3676 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3726 8 LMatrix3 0 2105345 8 LMatrix3 8 LMatrix3 0 0 3652 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3727 8 LMatrix4 0 2105345 8 LMatrix4 8 LMatrix4 0 0 3656 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3728 7 LVertex 0 2105345 7 LVertex 7 LVertex 0 0 3678 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3729 7 LNormal 0 2105345 7 LNormal 7 LNormal 0 0 3679 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3730 9 LTexCoord 0 2105345 9 LTexCoord 9 LTexCoord 0 0 3680 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3731 10 LTexCoord3 0 2105345 10 LTexCoord3 10 LTexCoord3 0 0 3681 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3732 6 LColor 0 2105345 6 LColor 6 LColor 0 0 3682 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3733 9 LRGBColor 0 2105345 9 LRGBColor 9 LRGBColor 0 0 3683 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3734 18 UnalignedLVecBase4 0 2105345 18 UnalignedLVecBase4 18 UnalignedLVecBase4 0 0 3636 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3735 17 UnalignedLMatrix4 0 2105345 17 UnalignedLMatrix4 17 UnalignedLMatrix4 0 0 3660 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3736 4 Mat4 0 2105345 4 Mat4 4 Mat4 0 0 3656 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3737 4 Mat3 0 2105345 4 Mat3 4 Mat3 0 0 3652 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3738 6 VBase4 0 2105345 6 VBase4 6 VBase4 0 0 3634 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3739 4 Vec4 0 2105345 4 Vec4 4 Vec4 0 0 3646 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3740 6 Point4 0 2105345 6 Point4 6 Point4 0 0 3649 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3741 6 VBase3 0 2105345 6 VBase3 6 VBase3 0 0 3621 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3742 4 Vec3 0 2105345 4 Vec3 4 Vec3 0 0 3628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3743 6 Point3 0 2105345 6 Point3 6 Point3 0 0 3631 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3744 6 VBase2 0 2105345 6 VBase2 6 VBase2 0 0 3606 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3745 4 Vec2 0 2105345 4 Vec2 4 Vec2 0 0 3615 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3746 6 Point2 0 2105345 6 Point2 6 Point2 0 0 3618 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3747 4 Quat 0 2105345 4 Quat 4 Quat 0 0 3672 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3748 19 ConfigVariableColor 0 141313 19 ConfigVariableColor 19 ConfigVariableColor 0 0 0 1 3597 3604 0 5 3598 3600 3601 3602 3603 0 1 3599 1 0 3749 0 0 0 0 538</span>
<span class="s0">/**</span>
 <span class="s0">* This is a convenience class to specialize ConfigVariable as a set of</span>
 <span class="s0">* floating-point types representing a color value.</span>
 <span class="s0">*</span>
 <span class="s0">* It interprets the color differently depending on how many words were</span>
 <span class="s0">* specified: if only one, it is interpreted as a shade of gray with alpha 1.</span>
 <span class="s0">* If two values were specified, a grayscale and alpha pair.  If three, a set</span>
 <span class="s0">* of R, G, B values with alpha 1, and if four, a complete RGBA color.</span>
 <span class="s0">*</span>
 <span class="s0">* This isn't defined in dtool because it relies on the LColor class, which is</span>
 <span class="s0">* defined in linmath.</span>
 <span class="s0">*/</span>

<span class="s0">3749 14 ConfigVariable 0 2048 14 ConfigVariable 14 ConfigVariable 0 0 0 0 0 0 0 0 0 0 0 0 415</span>
<span class="s0">/**</span>
 <span class="s0">* This is a generic, untyped ConfigVariable.  It is also the base class for</span>
 <span class="s0">* the typed ConfigVariables, and contains all of the code common to</span>
 <span class="s0">* ConfigVariables of all types (except ConfigVariableList, which is a bit of</span>
 <span class="s0">* a special case).</span>
 <span class="s0">*</span>
 <span class="s0">* Mostly, this class serves as a thin wrapper around ConfigVariableCore</span>
 <span class="s0">* and/or ConfigDeclaration, more or less duplicating the interface presented</span>
 <span class="s0">* there.</span>
 <span class="s0">*/</span>

<span class="s0">3750 13 MathNumbers * 0 8576 13 MathNumbers * 13 MathNumbers * 0 0 3605 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3751 19 MathNumbers const * 0 8576 19 MathNumbers const * 19 MathNumbers const * 0 0 3752 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3752 17 MathNumbers const 0 8832 17 MathNumbers const 17 MathNumbers const 0 0 3605 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3753 12 LVecBase2f * 0 8576 12 LVecBase2f * 12 LVecBase2f * 0 0 3606 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3754 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3755 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3755 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3606 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3756 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3757 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3757 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3758 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3759 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3760 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3760 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3761 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3761 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3762 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3763 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3764 23 ChecksumHashGenerator * 0 8576 23 ChecksumHashGenerator * 23 ChecksumHashGenerator * 0 0 3765 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3765 21 ChecksumHashGenerator 0 2048 21 ChecksumHashGenerator 21 ChecksumHashGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* This is a specific kind of HashGenerator that simply adds up all of the</span>
 <span class="s0">* ints.  Nothing fancy, and pretty quick.</span>
 <span class="s0">*/</span>

<span class="s0">3766 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 3767 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3767 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3768 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 3769 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3769 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565</span>
<span class="s0">/**</span>
 <span class="s0">* An ordered list of data elements, formatted in memory for transmission over</span>
 <span class="s0">* a socket or writing to a data file.</span>
 <span class="s0">*</span>
 <span class="s0">* Data elements should be added one at a time, in order, to the Datagram.</span>
 <span class="s0">* The nature and contents of the data elements are totally up to the user.</span>
 <span class="s0">* When a Datagram has been transmitted and received, its data elements may be</span>
 <span class="s0">* extracted using a DatagramIterator; it is up to the caller to know the</span>
 <span class="s0">* correct type of each data element in order.</span>
 <span class="s0">*</span>
 <span class="s0">* A Datagram is itself headerless; it is simply a collection of data</span>
 <span class="s0">* elements.</span>
 <span class="s0">*/</span>

<span class="s0">3770 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 3771 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3771 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 365</span>
<span class="s0">/**</span>
 <span class="s0">* A class to retrieve the individual data elements previously stored in a</span>
 <span class="s0">* Datagram.  Elements may be retrieved one at a time; it is up to the caller</span>
 <span class="s0">* to know the correct type and order of each element.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that it is the responsibility of the caller to ensure that the datagram</span>
 <span class="s0">* object is not destructed while this DatagramIterator is in use.</span>
 <span class="s0">*/</span>

<span class="s0">3772 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">3773 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3772 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3774 12 LVecBase2d * 0 8576 12 LVecBase2d * 12 LVecBase2d * 0 0 3609 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3775 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3776 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3776 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3609 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3777 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 3612 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3778 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3779 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3779 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3612 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3780 11 LVector2f * 0 8576 11 LVector2f * 11 LVector2f * 0 0 3615 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3781 17 LVector2f const * 0 8576 17 LVector2f const * 17 LVector2f const * 0 0 3782 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3782 15 LVector2f const 0 8832 15 LVector2f const 15 LVector2f const 0 0 3615 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3783 11 LVector2d * 0 8576 11 LVector2d * 11 LVector2d * 0 0 3616 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3784 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 3785 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3785 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 3616 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3786 11 LVector2i * 0 8576 11 LVector2i * 11 LVector2i * 0 0 3617 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3787 17 LVector2i const * 0 8576 17 LVector2i const * 17 LVector2i const * 0 0 3788 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3788 15 LVector2i const 0 8832 15 LVector2i const 15 LVector2i const 0 0 3617 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3789 10 LPoint2f * 0 8576 10 LPoint2f * 10 LPoint2f * 0 0 3618 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3790 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 3791 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3791 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 3618 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3792 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 3619 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3793 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 3794 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3794 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 3619 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3795 10 LPoint2i * 0 8576 10 LPoint2i * 10 LPoint2i * 0 0 3620 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3796 16 LPoint2i const * 0 8576 16 LPoint2i const * 16 LPoint2i const * 0 0 3797 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3797 14 LPoint2i const 0 8832 14 LPoint2i const 14 LPoint2i const 0 0 3620 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3798 12 LVecBase3f * 0 8576 12 LVecBase3f * 12 LVecBase3f * 0 0 3621 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3799 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3800 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3800 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3621 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3801 12 LVecBase3d * 0 8576 12 LVecBase3d * 12 LVecBase3d * 0 0 3623 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3802 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3803 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3803 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3623 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3804 12 LVecBase3i * 0 8576 12 LVecBase3i * 12 LVecBase3i * 0 0 3625 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3805 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3806 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3806 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3625 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3807 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3808 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 3809 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3809 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 3628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3810 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3629 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3811 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 3812 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3812 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 3629 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3813 11 LVector3i * 0 8576 11 LVector3i * 11 LVector3i * 0 0 3630 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3814 17 LVector3i const * 0 8576 17 LVector3i const * 17 LVector3i const * 0 0 3815 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3815 15 LVector3i const 0 8832 15 LVector3i const 15 LVector3i const 0 0 3630 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3816 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3631 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3817 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 3818 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3818 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 3631 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3819 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3632 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3820 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 3821 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3821 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 3632 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3822 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 3633 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3823 16 LPoint3i const * 0 8576 16 LPoint3i const * 16 LPoint3i const * 0 0 3824 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3824 14 LPoint3i const 0 8832 14 LPoint3i const 14 LPoint3i const 0 0 3633 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3825 12 LVecBase4f * 0 8576 12 LVecBase4f * 12 LVecBase4f * 0 0 3634 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3826 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3827 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3827 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3634 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3828 27 UnalignedLVecBase4f const * 0 8576 27 UnalignedLVecBase4f const * 27 UnalignedLVecBase4f const * 0 0 3829 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3829 25 UnalignedLVecBase4f const 0 8832 25 UnalignedLVecBase4f const 25 UnalignedLVecBase4f const 0 0 3636 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3830 21 UnalignedLVecBase4f * 0 8576 21 UnalignedLVecBase4f * 21 UnalignedLVecBase4f * 0 0 3636 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3831 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 3638 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3832 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3833 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3833 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3638 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3834 27 UnalignedLVecBase4d const * 0 8576 27 UnalignedLVecBase4d const * 27 UnalignedLVecBase4d const * 0 0 3835 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3835 25 UnalignedLVecBase4d const 0 8832 25 UnalignedLVecBase4d const 25 UnalignedLVecBase4d const 0 0 3640 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3836 21 UnalignedLVecBase4d * 0 8576 21 UnalignedLVecBase4d * 21 UnalignedLVecBase4d * 0 0 3640 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3837 12 LVecBase4i * 0 8576 12 LVecBase4i * 12 LVecBase4i * 0 0 3642 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3838 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3839 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3839 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3642 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3840 27 UnalignedLVecBase4i const * 0 8576 27 UnalignedLVecBase4i const * 27 UnalignedLVecBase4i const * 0 0 3841 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3841 25 UnalignedLVecBase4i const 0 8832 25 UnalignedLVecBase4i const 25 UnalignedLVecBase4i const 0 0 3644 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3842 21 UnalignedLVecBase4i * 0 8576 21 UnalignedLVecBase4i * 21 UnalignedLVecBase4i * 0 0 3644 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3843 11 LVector4f * 0 8576 11 LVector4f * 11 LVector4f * 0 0 3646 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3844 17 LVector4f const * 0 8576 17 LVector4f const * 17 LVector4f const * 0 0 3845 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3845 15 LVector4f const 0 8832 15 LVector4f const 15 LVector4f const 0 0 3646 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3846 11 LVector4d * 0 8576 11 LVector4d * 11 LVector4d * 0 0 3647 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3847 17 LVector4d const * 0 8576 17 LVector4d const * 17 LVector4d const * 0 0 3848 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3848 15 LVector4d const 0 8832 15 LVector4d const 15 LVector4d const 0 0 3647 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3849 11 LVector4i * 0 8576 11 LVector4i * 11 LVector4i * 0 0 3648 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3850 17 LVector4i const * 0 8576 17 LVector4i const * 17 LVector4i const * 0 0 3851 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3851 15 LVector4i const 0 8832 15 LVector4i const 15 LVector4i const 0 0 3648 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3852 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3649 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3853 16 LPoint4f const * 0 8576 16 LPoint4f const * 16 LPoint4f const * 0 0 3854 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3854 14 LPoint4f const 0 8832 14 LPoint4f const 14 LPoint4f const 0 0 3649 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3855 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3650 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3856 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 3857 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3857 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 3650 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3858 10 LPoint4i * 0 8576 10 LPoint4i * 10 LPoint4i * 0 0 3651 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3859 16 LPoint4i const * 0 8576 16 LPoint4i const * 16 LPoint4i const * 0 0 3860 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3860 14 LPoint4i const 0 8832 14 LPoint4i const 14 LPoint4i const 0 0 3651 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3861 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3652 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3862 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3863 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3863 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3652 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3864 5 Row * 0 8576 16 LMatrix3f::Row * 16 LMatrix3f::Row * 0 0 3654 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3865 6 CRow * 0 8576 17 LMatrix3f::CRow * 17 LMatrix3f::CRow * 0 0 3655 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3866 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3867 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3867 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3656 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3868 11 Row const * 0 8576 22 LMatrix3f::Row const * 22 LMatrix3f::Row const * 0 0 3869 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3869 9 Row const 0 8832 20 LMatrix3f::Row const 20 LMatrix3f::Row const 0 0 3654 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3870 12 CRow const * 0 8576 23 LMatrix3f::CRow const * 23 LMatrix3f::CRow const * 0 0 3871 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3871 10 CRow const 0 8832 21 LMatrix3f::CRow const 21 LMatrix3f::CRow const 0 0 3655 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3872 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3656 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3873 26 UnalignedLMatrix4f const * 0 8576 26 UnalignedLMatrix4f const * 26 UnalignedLMatrix4f const * 0 0 3874 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3874 24 UnalignedLMatrix4f const 0 8832 24 UnalignedLMatrix4f const 24 UnalignedLMatrix4f const 0 0 3660 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3875 5 Row * 0 8576 16 LMatrix4f::Row * 16 LMatrix4f::Row * 0 0 3658 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3876 6 CRow * 0 8576 17 LMatrix4f::CRow * 17 LMatrix4f::CRow * 0 0 3659 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3877 11 Row const * 0 8576 22 LMatrix4f::Row const * 22 LMatrix4f::Row const * 0 0 3878 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3878 9 Row const 0 8832 20 LMatrix4f::Row const 20 LMatrix4f::Row const 0 0 3658 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3879 12 CRow const * 0 8576 23 LMatrix4f::CRow const * 23 LMatrix4f::CRow const * 0 0 3880 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3880 10 CRow const 0 8832 21 LMatrix4f::CRow const 21 LMatrix4f::CRow const 0 0 3659 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3881 20 UnalignedLMatrix4f * 0 8576 20 UnalignedLMatrix4f * 20 UnalignedLMatrix4f * 0 0 3660 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3882 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3662 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3883 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3884 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3884 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3662 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3885 5 Row * 0 8576 16 LMatrix3d::Row * 16 LMatrix3d::Row * 0 0 3664 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3886 6 CRow * 0 8576 17 LMatrix3d::CRow * 17 LMatrix3d::CRow * 0 0 3665 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3887 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 3888 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3888 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3666 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3889 11 Row const * 0 8576 22 LMatrix3d::Row const * 22 LMatrix3d::Row const * 0 0 3890 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3890 9 Row const 0 8832 20 LMatrix3d::Row const 20 LMatrix3d::Row const 0 0 3664 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3891 12 CRow const * 0 8576 23 LMatrix3d::CRow const * 23 LMatrix3d::CRow const * 0 0 3892 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3892 10 CRow const 0 8832 21 LMatrix3d::CRow const 21 LMatrix3d::CRow const 0 0 3665 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3893 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3666 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3894 26 UnalignedLMatrix4d const * 0 8576 26 UnalignedLMatrix4d const * 26 UnalignedLMatrix4d const * 0 0 3895 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3895 24 UnalignedLMatrix4d const 0 8832 24 UnalignedLMatrix4d const 24 UnalignedLMatrix4d const 0 0 3670 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3896 5 Row * 0 8576 16 LMatrix4d::Row * 16 LMatrix4d::Row * 0 0 3668 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3897 6 CRow * 0 8576 17 LMatrix4d::CRow * 17 LMatrix4d::CRow * 0 0 3669 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3898 11 Row const * 0 8576 22 LMatrix4d::Row const * 22 LMatrix4d::Row const * 0 0 3899 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3899 9 Row const 0 8832 20 LMatrix4d::Row const 20 LMatrix4d::Row const 0 0 3668 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3900 12 CRow const * 0 8576 23 LMatrix4d::CRow const * 23 LMatrix4d::CRow const * 0 0 3901 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3901 10 CRow const 0 8832 21 LMatrix4d::CRow const 21 LMatrix4d::CRow const 0 0 3669 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3902 20 UnalignedLMatrix4d * 0 8576 20 UnalignedLMatrix4d * 20 UnalignedLMatrix4d * 0 0 3670 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3903 14 LQuaternionf * 0 8576 14 LQuaternionf * 14 LQuaternionf * 0 0 3672 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3904 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 3905 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3905 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 3672 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3906 14 LQuaterniond * 0 8576 14 LQuaterniond * 14 LQuaterniond * 0 0 3673 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3907 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 3908 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3908 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 3673 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3909 12 LRotationf * 0 8576 12 LRotationf * 12 LRotationf * 0 0 3674 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3910 18 LRotationf const * 0 8576 18 LRotationf const * 18 LRotationf const * 0 0 3911 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3911 16 LRotationf const 0 8832 16 LRotationf const 16 LRotationf const 0 0 3674 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3912 12 LRotationd * 0 8576 12 LRotationd * 12 LRotationd * 0 0 3675 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3913 18 LRotationd const * 0 8576 18 LRotationd const * 18 LRotationd const * 0 0 3914 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3914 16 LRotationd const 0 8832 16 LRotationd const 16 LRotationd const 0 0 3675 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3915 15 LOrientationf * 0 8576 15 LOrientationf * 15 LOrientationf * 0 0 3676 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3916 21 LOrientationf const * 0 8576 21 LOrientationf const * 21 LOrientationf const * 0 0 3917 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3917 19 LOrientationf const 0 8832 19 LOrientationf const 19 LOrientationf const 0 0 3676 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3918 15 LOrientationd * 0 8576 15 LOrientationd * 15 LOrientationd * 0 0 3677 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3919 21 LOrientationd const * 0 8576 21 LOrientationd const * 21 LOrientationd const * 0 0 3920 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3920 19 LOrientationd const 0 8832 19 LOrientationd const 19 LOrientationd const 0 0 3677 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3921 27 ConfigVariableColor const * 0 8576 27 ConfigVariableColor const * 27 ConfigVariableColor const * 0 0 3922 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3922 25 ConfigVariableColor const 0 8832 25 ConfigVariableColor const 25 ConfigVariableColor const 0 0 3748 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3923 21 ConfigVariableColor * 0 8576 21 ConfigVariableColor * 21 ConfigVariableColor * 0 0 3748 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3924 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3925 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3925 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3732 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3926 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3608 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3927 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3732 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3928 38 double const [::num_matrix_components] 0 4202496 38 double const [::num_matrix_components] 38 double const [::num_matrix_components] 0 0 3929 12 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3929 12 double const 0 8832 12 double const 12 double const 0 0 3611 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3930 37 float const [::num_matrix_components] 0 4202496 37 float const [::num_matrix_components] 37 float const [::num_matrix_components] 0 0 3931 12 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3931 11 float const 0 8832 11 float const 11 float const 0 0 3608 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3932 32 double [::num_matrix_components] 0 4202496 32 double [::num_matrix_components] 32 double [::num_matrix_components] 0 0 3611 12 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3933 31 float [::num_matrix_components] 0 4202496 31 float [::num_matrix_components] 31 float [::num_matrix_components] 0 0 3608 12 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">77</span>
<span class="s0">3934 1 x 0 6 3608 2031 2033 0 0 0 0 0 0 13 LVecBase2f::x 0</span>

<span class="s0">3935 1 y 0 6 3608 2032 2034 0 0 0 0 0 0 13 LVecBase2f::y 0</span>

<span class="s0">3936 1 x 0 6 3611 2099 2101 0 0 0 0 0 0 13 LVecBase2d::x 0</span>

<span class="s0">3937 1 y 0 6 3611 2100 2102 0 0 0 0 0 0 13 LVecBase2d::y 0</span>

<span class="s0">3938 1 x 0 6 3614 2167 2169 0 0 0 0 0 0 13 LVecBase2i::x 0</span>

<span class="s0">3939 1 y 0 6 3614 2168 2170 0 0 0 0 0 0 13 LVecBase2i::y 0</span>

<span class="s0">3940 1 x 0 6 3608 2327 2331 0 0 0 0 0 0 13 LVecBase3f::x 0</span>

<span class="s0">3941 1 y 0 6 3608 2328 2332 0 0 0 0 0 0 13 LVecBase3f::y 0</span>

<span class="s0">3942 1 z 0 6 3608 2329 2333 0 0 0 0 0 0 13 LVecBase3f::z 0</span>

<span class="s0">3943 2 xy 0 2 3606 2334 0 0 0 0 0 0 0 14 LVecBase3f::xy 0</span>

<span class="s0">3944 2 xz 0 2 3606 2335 0 0 0 0 0 0 0 14 LVecBase3f::xz 0</span>

<span class="s0">3945 2 yz 0 2 3606 2336 0 0 0 0 0 0 0 14 LVecBase3f::yz 0</span>

<span class="s0">3946 1 x 0 6 3611 2405 2409 0 0 0 0 0 0 13 LVecBase3d::x 0</span>

<span class="s0">3947 1 y 0 6 3611 2406 2410 0 0 0 0 0 0 13 LVecBase3d::y 0</span>

<span class="s0">3948 1 z 0 6 3611 2407 2411 0 0 0 0 0 0 13 LVecBase3d::z 0</span>

<span class="s0">3949 2 xy 0 2 3609 2412 0 0 0 0 0 0 0 14 LVecBase3d::xy 0</span>

<span class="s0">3950 2 xz 0 2 3609 2413 0 0 0 0 0 0 0 14 LVecBase3d::xz 0</span>

<span class="s0">3951 2 yz 0 2 3609 2414 0 0 0 0 0 0 0 14 LVecBase3d::yz 0</span>

<span class="s0">3952 1 x 0 6 3614 2483 2487 0 0 0 0 0 0 13 LVecBase3i::x 0</span>

<span class="s0">3953 1 y 0 6 3614 2484 2488 0 0 0 0 0 0 13 LVecBase3i::y 0</span>

<span class="s0">3954 1 z 0 6 3614 2485 2489 0 0 0 0 0 0 13 LVecBase3i::z 0</span>

<span class="s0">3955 2 xy 0 2 3612 2490 0 0 0 0 0 0 0 14 LVecBase3i::xy 0</span>

<span class="s0">3956 2 xz 0 2 3612 2491 0 0 0 0 0 0 0 14 LVecBase3i::xz 0</span>

<span class="s0">3957 2 yz 0 2 3612 2492 0 0 0 0 0 0 0 14 LVecBase3i::yz 0</span>

<span class="s0">3958 2 xy 0 2 3615 2551 0 0 0 0 0 0 0 13 LVector3f::xy 0</span>

<span class="s0">3959 2 xz 0 2 3615 2552 0 0 0 0 0 0 0 13 LVector3f::xz 0</span>

<span class="s0">3960 2 yz 0 2 3615 2553 0 0 0 0 0 0 0 13 LVector3f::yz 0</span>

<span class="s0">3961 2 xy 0 2 3616 2585 0 0 0 0 0 0 0 13 LVector3d::xy 0</span>

<span class="s0">3962 2 xz 0 2 3616 2586 0 0 0 0 0 0 0 13 LVector3d::xz 0</span>

<span class="s0">3963 2 yz 0 2 3616 2587 0 0 0 0 0 0 0 13 LVector3d::yz 0</span>

<span class="s0">3964 2 xy 0 2 3617 2619 0 0 0 0 0 0 0 13 LVector3i::xy 0</span>

<span class="s0">3965 2 xz 0 2 3617 2620 0 0 0 0 0 0 0 13 LVector3i::xz 0</span>

<span class="s0">3966 2 yz 0 2 3617 2621 0 0 0 0 0 0 0 13 LVector3i::yz 0</span>

<span class="s0">3967 2 xy 0 2 3618 2645 0 0 0 0 0 0 0 12 LPoint3f::xy 0</span>

<span class="s0">3968 2 xz 0 2 3618 2646 0 0 0 0 0 0 0 12 LPoint3f::xz 0</span>

<span class="s0">3969 2 yz 0 2 3618 2647 0 0 0 0 0 0 0 12 LPoint3f::yz 0</span>

<span class="s0">3970 2 xy 0 2 3619 2668 0 0 0 0 0 0 0 12 LPoint3d::xy 0</span>

<span class="s0">3971 2 xz 0 2 3619 2669 0 0 0 0 0 0 0 12 LPoint3d::xz 0</span>

<span class="s0">3972 2 yz 0 2 3619 2670 0 0 0 0 0 0 0 12 LPoint3d::yz 0</span>

<span class="s0">3973 2 xy 0 2 3620 2691 0 0 0 0 0 0 0 12 LPoint3i::xy 0</span>

<span class="s0">3974 2 xz 0 2 3620 2692 0 0 0 0 0 0 0 12 LPoint3i::xz 0</span>

<span class="s0">3975 2 yz 0 2 3620 2693 0 0 0 0 0 0 0 12 LPoint3i::yz 0</span>

<span class="s0">3976 1 x 0 6 3608 2723 2729 0 0 0 0 0 0 13 LVecBase4f::x 0</span>

<span class="s0">3977 1 y 0 6 3608 2724 2730 0 0 0 0 0 0 13 LVecBase4f::y 0</span>

<span class="s0">3978 1 z 0 6 3608 2725 2731 0 0 0 0 0 0 13 LVecBase4f::z 0</span>

<span class="s0">3979 3 xyz 0 2 3621 2727 0 0 0 0 0 0 0 15 LVecBase4f::xyz 0</span>

<span class="s0">3980 2 xy 0 2 3606 2728 0 0 0 0 0 0 0 14 LVecBase4f::xy 0</span>

<span class="s0">3981 1 x 0 6 3611 2813 2819 0 0 0 0 0 0 13 LVecBase4d::x 0</span>

<span class="s0">3982 1 y 0 6 3611 2814 2820 0 0 0 0 0 0 13 LVecBase4d::y 0</span>

<span class="s0">3983 1 z 0 6 3611 2815 2821 0 0 0 0 0 0 13 LVecBase4d::z 0</span>

<span class="s0">3984 3 xyz 0 2 3623 2817 0 0 0 0 0 0 0 15 LVecBase4d::xyz 0</span>

<span class="s0">3985 2 xy 0 2 3609 2818 0 0 0 0 0 0 0 14 LVecBase4d::xy 0</span>

<span class="s0">3986 1 x 0 6 3614 2903 2909 0 0 0 0 0 0 13 LVecBase4i::x 0</span>

<span class="s0">3987 1 y 0 6 3614 2904 2910 0 0 0 0 0 0 13 LVecBase4i::y 0</span>

<span class="s0">3988 1 z 0 6 3614 2905 2911 0 0 0 0 0 0 13 LVecBase4i::z 0</span>

<span class="s0">3989 3 xyz 0 2 3625 2907 0 0 0 0 0 0 0 15 LVecBase4i::xyz 0</span>

<span class="s0">3990 2 xy 0 2 3612 2908 0 0 0 0 0 0 0 14 LVecBase4i::xy 0</span>

<span class="s0">3991 3 xyz 0 2 3628 2979 0 0 0 0 0 0 0 14 LVector4f::xyz 0</span>

<span class="s0">3992 2 xy 0 2 3615 2980 0 0 0 0 0 0 0 13 LVector4f::xy 0</span>

<span class="s0">3993 3 xyz 0 2 3629 2999 0 0 0 0 0 0 0 14 LVector4d::xyz 0</span>

<span class="s0">3994 2 xy 0 2 3616 3000 0 0 0 0 0 0 0 13 LVector4d::xy 0</span>

<span class="s0">3995 3 xyz 0 2 3630 3019 0 0 0 0 0 0 0 14 LVector4i::xyz 0</span>

<span class="s0">3996 2 xy 0 2 3617 3020 0 0 0 0 0 0 0 13 LVector4i::xy 0</span>

<span class="s0">3997 3 xyz 0 2 3631 3037 0 0 0 0 0 0 0 13 LPoint4f::xyz 0</span>

<span class="s0">3998 2 xy 0 2 3618 3038 0 0 0 0 0 0 0 12 LPoint4f::xy 0</span>

<span class="s0">3999 3 xyz 0 2 3632 3057 0 0 0 0 0 0 0 13 LPoint4d::xyz 0</span>

<span class="s0">4000 2 xy 0 2 3619 3058 0 0 0 0 0 0 0 12 LPoint4d::xy 0</span>

<span class="s0">4001 3 xyz 0 2 3633 3077 0 0 0 0 0 0 0 13 LPoint4i::xyz 0</span>

<span class="s0">4002 2 xy 0 2 3620 3078 0 0 0 0 0 0 0 12 LPoint4i::xy 0</span>

<span class="s0">4003 4 rows 0 70 3621 3109 3107 0 0 0 3106 0 0 15 LMatrix3f::rows 0</span>

<span class="s0">4004 4 cols 0 70 3621 3110 3108 0 0 0 3106 0 0 15 LMatrix3f::cols 0</span>

<span class="s0">4005 4 rows 0 70 3634 3199 3197 0 0 0 3196 0 0 15 LMatrix4f::rows 0</span>

<span class="s0">4006 4 cols 0 70 3634 3200 3198 0 0 0 3196 0 0 15 LMatrix4f::cols 0</span>

<span class="s0">4007 4 rows 0 70 3623 3303 3301 0 0 0 3300 0 0 15 LMatrix3d::rows 0</span>

<span class="s0">4008 4 cols 0 70 3623 3304 3302 0 0 0 3300 0 0 15 LMatrix3d::cols 0</span>

<span class="s0">4009 4 rows 0 70 3638 3391 3389 0 0 0 3388 0 0 15 LMatrix4d::rows 0</span>

<span class="s0">4010 4 cols 0 70 3638 3392 3390 0 0 0 3388 0 0 15 LMatrix4d::cols 0</span>

<span class="s0">14</span>
<span class="s0">4011 8 get_rows 0 3106 3109 19 LMatrix3f::get_rows 0</span>

<span class="s0">4012 8 get_cols 0 3106 3110 19 LMatrix3f::get_cols 0</span>

<span class="s0">4013 9 get_col2s 0 3106 3112 20 LMatrix3f::get_col2s 0</span>

<span class="s0">4014 9 get_row2s 0 3106 3111 20 LMatrix3f::get_row2s 0</span>

<span class="s0">4015 8 get_rows 0 3196 3199 19 LMatrix4f::get_rows 0</span>

<span class="s0">4016 8 get_cols 0 3196 3200 19 LMatrix4f::get_cols 0</span>

<span class="s0">4017 9 get_row3s 0 3196 3201 20 LMatrix4f::get_row3s 0</span>

<span class="s0">4018 8 get_rows 0 3300 3303 19 LMatrix3d::get_rows 0</span>

<span class="s0">4019 8 get_cols 0 3300 3304 19 LMatrix3d::get_cols 0</span>

<span class="s0">4020 9 get_col2s 0 3300 3306 20 LMatrix3d::get_col2s 0</span>

<span class="s0">4021 9 get_row2s 0 3300 3305 20 LMatrix3d::get_row2s 0</span>

<span class="s0">4022 8 get_rows 0 3388 3391 19 LMatrix4d::get_rows 0</span>

<span class="s0">4023 8 get_cols 0 3388 3392 19 LMatrix4d::get_cols 0</span>

<span class="s0">4024 9 get_row3s 0 3388 3393 20 LMatrix4d::get_row3s 0</span>

</pre>
</body>
</html>