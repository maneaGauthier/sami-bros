<html>
<head>
<title>_converter.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_converter.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">base64</span>
<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">struct</span>
<span class="s0">import </span><span class="s1">urllib</span>
<span class="s0">import </span><span class="s1">pprint </span><span class="s2"># pylint: disable=unused-import</span>

<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">dataclass</span>

<span class="s0">from </span><span class="s1">panda3d</span><span class="s3">.</span><span class="s1">core </span><span class="s0">import </span><span class="s3">* </span><span class="s2"># pylint: disable=wildcard-import</span>
<span class="s0">import </span><span class="s1">panda3d</span><span class="s3">.</span><span class="s1">core </span><span class="s0">as </span><span class="s1">p3d</span>
<span class="s0">try</span><span class="s3">:</span>
    <span class="s0">from </span><span class="s1">panda3d </span><span class="s0">import </span><span class="s1">bullet</span>
    <span class="s1">HAVE_BULLET </span><span class="s3">= </span><span class="s0">True</span>
<span class="s0">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s1">HAVE_BULLET </span><span class="s3">= </span><span class="s0">False</span>
<span class="s0">from </span><span class="s1">direct</span><span class="s3">.</span><span class="s1">stdpy</span><span class="s3">.</span><span class="s1">file </span><span class="s0">import </span><span class="s1">open </span><span class="s2"># pylint: disable=redefined-builtin</span>

<span class="s0">if </span><span class="s1">LVector3 </span><span class="s0">is </span><span class="s1">LVector3f</span><span class="s3">:</span>
    <span class="s1">CPTA_stdfloat </span><span class="s3">= </span><span class="s1">CPTA_float</span>
    <span class="s1">PTA_stdfloat </span><span class="s3">= </span><span class="s1">PTA_float</span>
<span class="s0">else</span><span class="s3">:</span>
    <span class="s1">CPTA_stdfloat </span><span class="s3">= </span><span class="s1">CPTA_double</span>
    <span class="s1">PTA_stdfloat </span><span class="s3">= </span><span class="s1">PTA_double</span>


<span class="s3">@</span><span class="s1">dataclass</span>
<span class="s0">class </span><span class="s1">GltfSettings</span><span class="s3">:</span>
    <span class="s1">collision_shapes</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s4">'builtin'</span>
    <span class="s1">skip_axis_conversion</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s0">False</span>
    <span class="s1">no_srgb</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s0">False</span>
    <span class="s1">legacy_materials</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s0">False</span>
    <span class="s1">skip_animations</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s0">False</span>
    <span class="s1">flatten_nodes</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s0">False</span>


<span class="s0">def </span><span class="s1">get_extras</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">):</span>
    <span class="s1">extras </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'extras'</span><span class="s3">, {})</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">extras</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
        <span class="s2"># weird, but legal; fail silently for now</span>
        <span class="s0">return </span><span class="s3">{}</span>
    <span class="s0">return </span><span class="s1">extras</span>

<span class="s3">@</span><span class="s1">dataclass</span>
<span class="s0">class </span><span class="s1">CharInfo</span><span class="s3">:</span>
    <span class="s1">character</span><span class="s3">: </span><span class="s1">p3d</span><span class="s3">.</span><span class="s1">Character</span>
    <span class="s1">nodepath</span><span class="s3">: </span><span class="s1">p3d</span><span class="s3">.</span><span class="s1">NodePath</span>
    <span class="s1">jvtmap</span><span class="s3">: </span><span class="s4">'dict[int, p3d.JointVertexTransform]'</span>
    <span class="s1">cvsmap</span><span class="s3">: </span><span class="s4">'dict[tuple[int, str], p3d.CharacterVertexSlider]'</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">character </span><span class="s3">= </span><span class="s1">p3d</span><span class="s3">.</span><span class="s1">Character</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">nodepath </span><span class="s3">= </span><span class="s1">p3d</span><span class="s3">.</span><span class="s1">NodePath</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">character</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">jvtmap </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">cvsmap </span><span class="s3">= {}</span>


<span class="s0">class </span><span class="s1">Converter</span><span class="s3">():</span>
    <span class="s1">_COMPONENT_TYPE_MAP </span><span class="s3">= {</span>
        <span class="s5">5120</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">NT_int8</span><span class="s3">,</span>
        <span class="s5">5121</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">NT_uint8</span><span class="s3">,</span>
        <span class="s5">5122</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">NT_int16</span><span class="s3">,</span>
        <span class="s5">5123</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">NT_uint16</span><span class="s3">,</span>
        <span class="s5">5124</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">NT_int32</span><span class="s3">,</span>
        <span class="s5">5125</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">NT_uint32</span><span class="s3">,</span>
        <span class="s5">5126</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">NT_float32</span><span class="s3">,</span>
    <span class="s3">}</span>
    <span class="s1">_COMPONENT_SIZE_MAP </span><span class="s3">= {</span>
        <span class="s5">5120</span><span class="s3">: </span><span class="s5">1</span><span class="s3">,</span>
        <span class="s5">5121</span><span class="s3">: </span><span class="s5">1</span><span class="s3">,</span>
        <span class="s5">5122</span><span class="s3">: </span><span class="s5">2</span><span class="s3">,</span>
        <span class="s5">5123</span><span class="s3">: </span><span class="s5">2</span><span class="s3">,</span>
        <span class="s5">5124</span><span class="s3">: </span><span class="s5">4</span><span class="s3">,</span>
        <span class="s5">5125</span><span class="s3">: </span><span class="s5">4</span><span class="s3">,</span>
        <span class="s5">5126</span><span class="s3">: </span><span class="s5">4</span><span class="s3">,</span>
    <span class="s3">}</span>
    <span class="s1">_COMPONENT_NUM_MAP </span><span class="s3">= {</span>
        <span class="s4">'MAT4'</span><span class="s3">: </span><span class="s5">16</span><span class="s3">,</span>
        <span class="s4">'VEC4'</span><span class="s3">: </span><span class="s5">4</span><span class="s3">,</span>
        <span class="s4">'VEC3'</span><span class="s3">: </span><span class="s5">3</span><span class="s3">,</span>
        <span class="s4">'VEC2'</span><span class="s3">: </span><span class="s5">2</span><span class="s3">,</span>
        <span class="s4">'SCALAR'</span><span class="s3">: </span><span class="s5">1</span><span class="s3">,</span>
    <span class="s3">}</span>
    <span class="s1">_ATTRIB_CONTENT_MAP </span><span class="s3">= {</span>
        <span class="s4">'vertex'</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_point</span><span class="s3">,</span>
        <span class="s4">'normal'</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_normal</span><span class="s3">,</span>
        <span class="s4">'tangent'</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_other</span><span class="s3">,</span>
        <span class="s4">'texcoord'</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_texcoord</span><span class="s3">,</span>
        <span class="s4">'color'</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_color</span><span class="s3">,</span>
        <span class="s4">'transform_weight'</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_other</span><span class="s3">,</span>
        <span class="s4">'transform_index'</span><span class="s3">: </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_index</span><span class="s3">,</span>
    <span class="s3">}</span>
    <span class="s1">_ATTRIB_NAME_MAP </span><span class="s3">= {</span>
        <span class="s4">'position'</span><span class="s3">: </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_vertex</span><span class="s3">().</span><span class="s1">get_name</span><span class="s3">(),</span>
        <span class="s4">'weights'</span><span class="s3">: </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_transform_weight</span><span class="s3">().</span><span class="s1">get_name</span><span class="s3">(),</span>
        <span class="s4">'joints'</span><span class="s3">: </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_transform_index</span><span class="s3">().</span><span class="s1">get_name</span><span class="s3">(),</span>
    <span class="s3">}</span>
    <span class="s1">_PRIMITIVE_MODE_MAP </span><span class="s3">= {</span>
        <span class="s5">0</span><span class="s3">: </span><span class="s1">GeomPoints</span><span class="s3">,</span>
        <span class="s5">1</span><span class="s3">: </span><span class="s1">GeomLines</span><span class="s3">,</span>
        <span class="s5">3</span><span class="s3">: </span><span class="s1">GeomLinestrips</span><span class="s3">,</span>
        <span class="s5">4</span><span class="s3">: </span><span class="s1">GeomTriangles</span><span class="s3">,</span>
        <span class="s5">5</span><span class="s3">: </span><span class="s1">GeomTristrips</span><span class="s3">,</span>
        <span class="s5">6</span><span class="s3">: </span><span class="s1">GeomTrifans</span><span class="s3">,</span>
    <span class="s3">}</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">filepath</span><span class="s3">,</span>
            <span class="s1">settings</span><span class="s3">=</span><span class="s0">None</span>
    <span class="s3">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">filepath</span><span class="s3">, </span><span class="s1">Filename</span><span class="s3">):</span>
            <span class="s1">filepath </span><span class="s3">= </span><span class="s1">Filename</span><span class="s3">.</span><span class="s1">from_os_specific</span><span class="s3">(</span><span class="s1">filepath</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">settings </span><span class="s0">is None</span><span class="s3">:</span>
            <span class="s1">settings </span><span class="s3">= </span><span class="s1">GltfSettings</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">filepath </span><span class="s3">= </span><span class="s1">filepath</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">filedir </span><span class="s3">= </span><span class="s1">Filename</span><span class="s3">(</span><span class="s1">filepath</span><span class="s3">.</span><span class="s1">get_dirname</span><span class="s3">())</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">settings </span><span class="s3">= </span><span class="s1">settings</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">cameras </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">buffers </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lights </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">textures </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">mat_states </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">mat_mesh_map </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">meshes </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">scenes </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">skeletons </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">joint_parents </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">characters </span><span class="s3">= {}</span>

        <span class="s2"># Coordinate system transform matrix</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">csxform </span><span class="s3">= </span><span class="s1">LMatrix4</span><span class="s3">.</span><span class="s1">convert_mat</span><span class="s3">(</span><span class="s1">CS_yup_right</span><span class="s3">, </span><span class="s1">CS_default</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">csxform_inv </span><span class="s3">= </span><span class="s1">LMatrix4</span><span class="s3">.</span><span class="s1">convert_mat</span><span class="s3">(</span><span class="s1">CS_default</span><span class="s3">, </span><span class="s1">CS_yup_right</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">compose_cs </span><span class="s3">= </span><span class="s1">CS_yup_right</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_joint_nodes </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>

        <span class="s2"># Scene props</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">active_scene </span><span class="s3">= </span><span class="s1">NodePath</span><span class="s3">(</span><span class="s1">ModelRoot</span><span class="s3">(</span><span class="s4">'default'</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">background_color </span><span class="s3">= (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">active_camera </span><span class="s3">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">):</span>
        <span class="s2">#pprint.pprint(gltf_data)</span>

        <span class="s1">skip_axis_conversion </span><span class="s3">= (</span>
            <span class="s4">'extensionsUsed' </span><span class="s0">in </span><span class="s1">gltf_data </span><span class="s0">and </span><span class="s4">'BP_zup' </span><span class="s0">in </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'extensionsUsed'</span><span class="s3">] </span><span class="s0">or</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">skip_axis_conversion</span>
        <span class="s3">)</span>

        <span class="s0">if </span><span class="s1">skip_axis_conversion</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">csxform </span><span class="s3">= </span><span class="s1">LMatrix4</span><span class="s3">.</span><span class="s1">ident_mat</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">csxform_inv </span><span class="s3">= </span><span class="s1">LMatrix4</span><span class="s3">.</span><span class="s1">ident_mat</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">compose_cs </span><span class="s3">= </span><span class="s1">CS_zup_right</span>

        <span class="s2"># Convert data</span>
        <span class="s0">for </span><span class="s1">buffid</span><span class="s3">, </span><span class="s1">gltf_buffer </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'buffers'</span><span class="s3">, [])):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">load_buffer</span><span class="s3">(</span><span class="s1">buffid</span><span class="s3">, </span><span class="s1">gltf_buffer</span><span class="s3">)</span>

        <span class="s0">for </span><span class="s1">camid</span><span class="s3">, </span><span class="s1">gltf_cam </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'cameras'</span><span class="s3">, [])):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">load_camera</span><span class="s3">(</span><span class="s1">camid</span><span class="s3">, </span><span class="s1">gltf_cam</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s4">'extensions' </span><span class="s0">in </span><span class="s1">gltf_data </span><span class="s0">and </span><span class="s4">'KHR_lights' </span><span class="s0">in </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">]:</span>
            <span class="s1">lights </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">][</span><span class="s4">'KHR_lights'</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'lights'</span><span class="s3">, [])</span>
            <span class="s0">for </span><span class="s1">lightid</span><span class="s3">, </span><span class="s1">gltf_light </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">lights</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">load_light</span><span class="s3">(</span><span class="s1">lightid</span><span class="s3">, </span><span class="s1">gltf_light</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s4">'extensions' </span><span class="s0">in </span><span class="s1">gltf_data </span><span class="s0">and </span><span class="s4">'KHR_lights_punctual' </span><span class="s0">in </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">]:</span>
            <span class="s1">lights </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">][</span><span class="s4">'KHR_lights_punctual'</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'lights'</span><span class="s3">, [])</span>
            <span class="s0">for </span><span class="s1">lightid</span><span class="s3">, </span><span class="s1">gltf_light </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">lights</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">load_light</span><span class="s3">(</span><span class="s1">lightid</span><span class="s3">, </span><span class="s1">gltf_light</span><span class="s3">, </span><span class="s1">punctual</span><span class="s3">=</span><span class="s0">True</span><span class="s3">)</span>

        <span class="s0">for </span><span class="s1">texid</span><span class="s3">, </span><span class="s1">gltf_tex </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'textures'</span><span class="s3">, [])):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">load_texture</span><span class="s3">(</span><span class="s1">texid</span><span class="s3">, </span><span class="s1">gltf_tex</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">load_fallback_texture</span><span class="s3">()</span>

        <span class="s0">for </span><span class="s1">matid</span><span class="s3">, </span><span class="s1">gltf_mat </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'materials'</span><span class="s3">, [])):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">load_material</span><span class="s3">(</span><span class="s1">matid</span><span class="s3">, </span><span class="s1">gltf_mat</span><span class="s3">)</span>

        <span class="s0">for </span><span class="s1">skinid</span><span class="s3">, </span><span class="s1">gltf_skin </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'skins'</span><span class="s3">, [])):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">load_skin</span><span class="s3">(</span><span class="s1">skinid</span><span class="s3">, </span><span class="s1">gltf_skin</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">)</span>

        <span class="s0">for </span><span class="s1">meshid</span><span class="s3">, </span><span class="s1">gltf_mesh </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'meshes'</span><span class="s3">, [])):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">load_mesh</span><span class="s3">(</span><span class="s1">meshid</span><span class="s3">, </span><span class="s1">gltf_mesh</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">)</span>

        <span class="s0">def </span><span class="s1">get_node_transform</span><span class="s3">(</span><span class="s1">gltf_node</span><span class="s3">):</span>
            <span class="s0">if </span><span class="s4">'matrix' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">:</span>
                <span class="s1">gltf_mat </span><span class="s3">= </span><span class="s1">LMatrix4</span><span class="s3">(*</span><span class="s1">gltf_node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'matrix'</span><span class="s3">))</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">gltf_mat </span><span class="s3">= </span><span class="s1">LMatrix4</span><span class="s3">(</span><span class="s1">LMatrix4</span><span class="s3">.</span><span class="s1">ident_mat</span><span class="s3">())</span>
                <span class="s0">if </span><span class="s4">'scale' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">:</span>
                    <span class="s1">gltf_mat</span><span class="s3">.</span><span class="s1">set_scale_mat</span><span class="s3">(</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'scale'</span><span class="s3">]))</span>

                <span class="s0">if </span><span class="s4">'rotation' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">:</span>
                    <span class="s1">rot_mat </span><span class="s3">= </span><span class="s1">LMatrix4</span><span class="s3">()</span>
                    <span class="s1">rot </span><span class="s3">= </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'rotation'</span><span class="s3">]</span>
                    <span class="s1">quat </span><span class="s3">= </span><span class="s1">LQuaternion</span><span class="s3">(</span><span class="s1">rot</span><span class="s3">[</span><span class="s5">3</span><span class="s3">], </span><span class="s1">rot</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">rot</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">rot</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>
                    <span class="s1">quat</span><span class="s3">.</span><span class="s1">extract_to_matrix</span><span class="s3">(</span><span class="s1">rot_mat</span><span class="s3">)</span>
                    <span class="s1">gltf_mat </span><span class="s3">*= </span><span class="s1">rot_mat</span>

                <span class="s0">if </span><span class="s4">'translation' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">:</span>
                    <span class="s1">gltf_mat </span><span class="s3">*= </span><span class="s1">LMatrix4</span><span class="s3">.</span><span class="s1">translate_mat</span><span class="s3">(*</span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'translation'</span><span class="s3">])</span>

            <span class="s0">return </span><span class="s1">TransformState</span><span class="s3">.</span><span class="s1">make_mat</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">csxform_inv </span><span class="s3">* </span><span class="s1">gltf_mat </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">csxform</span><span class="s3">)</span>

        <span class="s0">def </span><span class="s1">build_characters</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">):</span>
            <span class="s0">try</span><span class="s3">:</span>
                <span class="s1">gltf_node </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">][</span><span class="s1">nodeid</span><span class="s3">]</span>
            <span class="s0">except </span><span class="s1">IndexError</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Could not find node with index: {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">))</span>
                <span class="s0">return</span>
            <span class="s1">node_name </span><span class="s3">= </span><span class="s1">gltf_node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'node'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">))</span>

            <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">skeletons</span><span class="s3">:</span>
                <span class="s1">skinid </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">skeletons</span><span class="s3">[</span><span class="s1">nodeid</span><span class="s3">]</span>
                <span class="s1">charinfo </span><span class="s3">= </span><span class="s1">CharInfo</span><span class="s3">(</span><span class="s1">node_name</span><span class="s3">)</span>
                <span class="s1">charinfo</span><span class="s3">.</span><span class="s1">character</span><span class="s3">.</span><span class="s1">set_transform</span><span class="s3">(</span><span class="s1">get_node_transform</span><span class="s3">(</span><span class="s1">gltf_node</span><span class="s3">))</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">build_character</span><span class="s3">(</span><span class="s1">charinfo</span><span class="s3">, </span><span class="s1">nodeid</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">, </span><span class="s1">recurse</span><span class="s3">=</span><span class="s0">True</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">characters</span><span class="s3">[</span><span class="s1">skinid</span><span class="s3">] = </span><span class="s1">charinfo</span>

            <span class="s0">for </span><span class="s1">child_nodeid </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'children'</span><span class="s3">, []):</span>
                <span class="s1">build_characters</span><span class="s3">(</span><span class="s1">child_nodeid</span><span class="s3">)</span>

        <span class="s2"># Build scenegraphs</span>
        <span class="s0">def </span><span class="s1">add_node</span><span class="s3">(</span><span class="s1">root</span><span class="s3">, </span><span class="s1">gltf_scene</span><span class="s3">, </span><span class="s1">nodeid</span><span class="s3">):</span>
            <span class="s0">try</span><span class="s3">:</span>
                <span class="s1">gltf_node </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">][</span><span class="s1">nodeid</span><span class="s3">]</span>
            <span class="s0">except </span><span class="s1">IndexError</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Could not find node with index: {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">))</span>
                <span class="s0">return</span>

            <span class="s1">skinid </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">skeletons</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">, </span><span class="s0">None</span><span class="s3">)</span>
            <span class="s1">charinfo </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">characters</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">skinid</span><span class="s3">, </span><span class="s0">None</span><span class="s3">)</span>
            <span class="s1">scene_extras </span><span class="s3">= </span><span class="s1">get_extras</span><span class="s3">(</span><span class="s1">gltf_scene</span><span class="s3">)</span>
            <span class="s1">node_name </span><span class="s3">= </span><span class="s1">gltf_node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'node'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">))</span>
            <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_joint_nodes </span><span class="s0">and not </span><span class="s1">nodeid </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">skeletons</span><span class="s3">:</span>
                <span class="s2"># Handle non-joint children of joints, but don't add joints themselves</span>
                <span class="s0">for </span><span class="s1">child_nodeid </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'children'</span><span class="s3">, []):</span>
                    <span class="s1">add_node</span><span class="s3">(</span><span class="s1">root</span><span class="s3">, </span><span class="s1">gltf_scene</span><span class="s3">, </span><span class="s1">child_nodeid</span><span class="s3">)</span>
                <span class="s0">return</span>

            <span class="s0">if </span><span class="s1">charinfo</span><span class="s3">:</span>
                <span class="s2"># This node is the root of an animated character.</span>
                <span class="s1">panda_node </span><span class="s3">= </span><span class="s1">charinfo</span><span class="s3">.</span><span class="s1">character</span>
                <span class="s1">np </span><span class="s3">= </span><span class="s1">charinfo</span><span class="s3">.</span><span class="s1">nodepath</span>
                <span class="s1">np</span><span class="s3">.</span><span class="s1">reparent_to</span><span class="s3">(</span><span class="s1">root</span><span class="s3">)</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">panda_node </span><span class="s3">= </span><span class="s1">PandaNode</span><span class="s3">(</span><span class="s1">node_name</span><span class="s3">)</span>
                <span class="s1">panda_node</span><span class="s3">.</span><span class="s1">set_transform</span><span class="s3">(</span><span class="s1">get_node_transform</span><span class="s3">(</span><span class="s1">gltf_node</span><span class="s3">))</span>
                <span class="s1">np </span><span class="s3">= </span><span class="s1">root</span><span class="s3">.</span><span class="s1">attach_new_node</span><span class="s3">(</span><span class="s1">panda_node</span><span class="s3">)</span>

            <span class="s0">if </span><span class="s4">'hidden_nodes' </span><span class="s0">in </span><span class="s1">scene_extras</span><span class="s3">:</span>
                <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">in </span><span class="s1">scene_extras</span><span class="s3">[</span><span class="s4">'hidden_nodes'</span><span class="s3">]:</span>
                    <span class="s1">panda_node </span><span class="s3">= </span><span class="s1">panda_node</span><span class="s3">.</span><span class="s1">make_copy</span><span class="s3">()</span>

            <span class="s0">if </span><span class="s4">'mesh' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">:</span>
                <span class="s1">meshid </span><span class="s3">= </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'mesh'</span><span class="s3">]</span>
                <span class="s1">gltf_mesh </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'meshes'</span><span class="s3">][</span><span class="s1">meshid</span><span class="s3">]</span>
                <span class="s1">mesh </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">meshes</span><span class="s3">[</span><span class="s1">meshid</span><span class="s3">]</span>

                <span class="s1">charinfo </span><span class="s3">= </span><span class="s0">None</span>
                <span class="s0">if </span><span class="s4">&quot;skin&quot; </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">:</span>
                    <span class="s1">skinid </span><span class="s3">= </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">&quot;skin&quot;</span><span class="s3">]</span>
                    <span class="s1">charinfo </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">characters</span><span class="s3">[</span><span class="s1">skinid</span><span class="s3">]</span>

                <span class="s2"># Does this mesh have weights, but are we not under a character?</span>
                <span class="s2"># If so, create a character just for this mesh.</span>
                <span class="s0">if </span><span class="s1">gltf_mesh</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'weights'</span><span class="s3">) </span><span class="s0">and not </span><span class="s1">charinfo</span><span class="s3">:</span>
                    <span class="s1">mesh_name </span><span class="s3">= </span><span class="s1">gltf_mesh</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'mesh'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">meshid</span><span class="s3">))</span>
                    <span class="s1">charinfo </span><span class="s3">= </span><span class="s1">CharInfo</span><span class="s3">(</span><span class="s1">mesh_name</span><span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">build_character</span><span class="s3">(</span><span class="s1">charinfo</span><span class="s3">, </span><span class="s1">nodeid</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">, </span><span class="s1">recurse</span><span class="s3">=</span><span class="s0">False</span><span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">combine_mesh_morphs</span><span class="s3">(</span><span class="s1">mesh</span><span class="s3">, </span><span class="s1">meshid</span><span class="s3">, </span><span class="s1">charinfo</span><span class="s3">)</span>
                    <span class="s1">charinfo</span><span class="s3">.</span><span class="s1">nodepath</span><span class="s3">.</span><span class="s1">reparent_to</span><span class="s3">(</span><span class="s1">np</span><span class="s3">)</span>
                    <span class="s1">charinfo</span><span class="s3">.</span><span class="s1">nodepath</span><span class="s3">.</span><span class="s1">attach_new_node</span><span class="s3">(</span><span class="s1">mesh</span><span class="s3">)</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">np</span><span class="s3">.</span><span class="s1">attach_new_node</span><span class="s3">(</span><span class="s1">mesh</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s1">charinfo</span><span class="s3">:</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">combine_mesh_skin</span><span class="s3">(</span><span class="s1">mesh</span><span class="s3">, </span><span class="s1">charinfo</span><span class="s3">)</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">combine_mesh_morphs</span><span class="s3">(</span><span class="s1">mesh</span><span class="s3">, </span><span class="s1">meshid</span><span class="s3">, </span><span class="s1">charinfo</span><span class="s3">)</span>

            <span class="s0">if </span><span class="s4">'camera' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">:</span>
                <span class="s1">camid </span><span class="s3">= </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'camera'</span><span class="s3">]</span>
                <span class="s1">cam </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cameras</span><span class="s3">[</span><span class="s1">camid</span><span class="s3">]</span>
                <span class="s1">np</span><span class="s3">.</span><span class="s1">attach_new_node</span><span class="s3">(</span><span class="s1">cam</span><span class="s3">)</span>
            <span class="s0">if </span><span class="s4">'extensions' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">:</span>
                <span class="s1">light_ext </span><span class="s3">= </span><span class="s0">None</span>
                <span class="s1">has_light_ext </span><span class="s3">= </span><span class="s0">False</span>
                <span class="s0">if </span><span class="s4">'KHR_lights_punctual' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">]:</span>
                    <span class="s1">light_ext </span><span class="s3">= </span><span class="s4">'KHR_lights_punctual'</span>
                    <span class="s1">has_light_ext </span><span class="s3">= </span><span class="s0">True</span>
                <span class="s0">elif </span><span class="s4">'KHR_lights' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">]:</span>
                    <span class="s1">light_ext </span><span class="s3">= </span><span class="s4">'KHR_lights'</span>
                    <span class="s1">has_light_ext </span><span class="s3">= </span><span class="s0">True</span>
                <span class="s0">if </span><span class="s1">has_light_ext</span><span class="s3">:</span>
                    <span class="s1">lightid </span><span class="s3">= </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">][</span><span class="s1">light_ext</span><span class="s3">][</span><span class="s4">'light'</span><span class="s3">]</span>
                    <span class="s1">light </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lights</span><span class="s3">[</span><span class="s1">lightid</span><span class="s3">]</span>
                    <span class="s1">lnp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">attach_new_node</span><span class="s3">(</span><span class="s1">light</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compose_cs </span><span class="s3">== </span><span class="s1">CS_zup_right</span><span class="s3">:</span>
                        <span class="s1">lnp</span><span class="s3">.</span><span class="s1">set_p</span><span class="s3">(</span><span class="s1">lnp</span><span class="s3">.</span><span class="s1">get_p</span><span class="s3">() - </span><span class="s5">90</span><span class="s3">)</span>
                    <span class="s1">lnp</span><span class="s3">.</span><span class="s1">set_r</span><span class="s3">(</span><span class="s1">lnp</span><span class="s3">.</span><span class="s1">get_r</span><span class="s3">() - </span><span class="s5">90</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">light</span><span class="s3">, </span><span class="s1">Light</span><span class="s3">):</span>
                        <span class="s1">root</span><span class="s3">.</span><span class="s1">set_light</span><span class="s3">(</span><span class="s1">lnp</span><span class="s3">)</span>

                <span class="s1">has_physics </span><span class="s3">= (</span>
                    <span class="s4">'BLENDER_physics' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">] </span><span class="s0">or</span>
                    <span class="s4">'PANDA3D_physics_collision_shapes' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">]</span>
                <span class="s3">)</span>
                <span class="s0">if </span><span class="s1">has_physics</span><span class="s3">:</span>
                    <span class="s1">gltf_collisions </span><span class="s3">= </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span>
                        <span class="s4">'PANDA3D_physics_collision_shapes'</span><span class="s3">,</span>
                        <span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">][</span><span class="s4">'BLENDER_physics'</span><span class="s3">]</span>
                    <span class="s3">)</span>
                    <span class="s1">gltf_rigidbody </span><span class="s3">= </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'BLENDER_physics'</span><span class="s3">, </span><span class="s0">None</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s4">'PANDA3D_physics_collision_shapes' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">]:</span>
                        <span class="s1">collision_shape </span><span class="s3">= </span><span class="s1">gltf_collisions</span><span class="s3">[</span><span class="s4">'shapes'</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]</span>
                        <span class="s1">shape_type </span><span class="s3">= </span><span class="s1">collision_shape</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]</span>
                    <span class="s0">else</span><span class="s3">:</span>
                        <span class="s1">collision_shape </span><span class="s3">= </span><span class="s1">gltf_collisions</span><span class="s3">[</span><span class="s4">'collisionShapes'</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]</span>
                        <span class="s1">shape_type </span><span class="s3">= </span><span class="s1">collision_shape</span><span class="s3">[</span><span class="s4">'shapeType'</span><span class="s3">]</span>
                    <span class="s1">bounding_box </span><span class="s3">= [</span>
                        <span class="s1">max</span><span class="s3">(</span><span class="s5">0.00001</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
                        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">collision_shape</span><span class="s3">[</span><span class="s4">'boundingBox'</span><span class="s3">]</span>
                    <span class="s3">]</span>
                    <span class="s1">radius </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">bounding_box</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">bounding_box</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) / </span><span class="s5">2.0</span>
                    <span class="s1">height </span><span class="s3">= </span><span class="s1">bounding_box</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]</span>
                    <span class="s1">geomnode </span><span class="s3">= </span><span class="s0">None</span>
                    <span class="s1">intangible </span><span class="s3">= </span><span class="s1">gltf_collisions</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'intangible'</span><span class="s3">, </span><span class="s0">False</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s4">'mesh' </span><span class="s0">in </span><span class="s1">collision_shape</span><span class="s3">:</span>
                        <span class="s0">try</span><span class="s3">:</span>
                            <span class="s1">geomnode </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">meshes</span><span class="s3">[</span><span class="s1">collision_shape</span><span class="s3">[</span><span class="s4">'mesh'</span><span class="s3">]]</span>
                        <span class="s0">except </span><span class="s1">KeyError</span><span class="s3">:</span>
                            <span class="s1">print</span><span class="s3">(</span>
                                <span class="s4">&quot;Could not find physics mesh ({}) for object ({})&quot;</span>
                                <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">collision_shape</span><span class="s3">[</span><span class="s4">'mesh'</span><span class="s3">], </span><span class="s1">nodeid</span><span class="s3">)</span>
                            <span class="s3">)</span>
                    <span class="s0">if </span><span class="s4">'extensions' </span><span class="s0">in </span><span class="s1">gltf_data </span><span class="s0">and </span><span class="s4">'BP_physics_engine' </span><span class="s0">in </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">]:</span>
                        <span class="s1">use_bullet </span><span class="s3">= (</span>
                            <span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'extensions'</span><span class="s3">][</span><span class="s4">'BP_physics_engine'</span><span class="s3">][</span><span class="s4">'engine'</span><span class="s3">] == </span><span class="s4">'bullet'</span>
                        <span class="s3">)</span>
                    <span class="s0">else</span><span class="s3">:</span>
                        <span class="s1">use_bullet </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">collision_shapes </span><span class="s3">== </span><span class="s4">'bullet'</span>
                    <span class="s0">if </span><span class="s1">use_bullet </span><span class="s0">and not </span><span class="s1">HAVE_BULLET</span><span class="s3">:</span>
                        <span class="s1">print</span><span class="s3">(</span>
                            <span class="s4">'Warning: attempted to export for Bullet, which is unavailable, falling back to builtin'</span>
                        <span class="s3">)</span>
                        <span class="s1">use_bullet </span><span class="s3">= </span><span class="s0">False</span>

                    <span class="s0">if </span><span class="s1">use_bullet</span><span class="s3">:</span>
                        <span class="s1">phynode </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">load_physics_bullet</span><span class="s3">(</span>
                            <span class="s1">node_name</span><span class="s3">,</span>
                            <span class="s1">geomnode</span><span class="s3">,</span>
                            <span class="s1">shape_type</span><span class="s3">,</span>
                            <span class="s1">bounding_box</span><span class="s3">,</span>
                            <span class="s1">radius</span><span class="s3">,</span>
                            <span class="s1">height</span><span class="s3">,</span>
                            <span class="s1">intangible</span><span class="s3">,</span>
                            <span class="s1">gltf_rigidbody</span>
                        <span class="s3">)</span>
                    <span class="s0">else</span><span class="s3">:</span>
                        <span class="s1">phynode </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">load_physics_builtin</span><span class="s3">(</span>
                            <span class="s1">node_name</span><span class="s3">,</span>
                            <span class="s1">geomnode</span><span class="s3">,</span>
                            <span class="s1">shape_type</span><span class="s3">,</span>
                            <span class="s1">bounding_box</span><span class="s3">,</span>
                            <span class="s1">radius</span><span class="s3">,</span>
                            <span class="s1">height</span><span class="s3">,</span>
                            <span class="s1">intangible</span>
                        <span class="s3">)</span>
                    <span class="s0">if </span><span class="s1">phynode </span><span class="s0">is not None</span><span class="s3">:</span>
                        <span class="s1">phynp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">attach_new_node</span><span class="s3">(</span><span class="s1">phynode</span><span class="s3">)</span>
                        <span class="s0">for </span><span class="s1">geomnode </span><span class="s0">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">find_all_matches</span><span class="s3">(</span><span class="s4">'+GeomNode'</span><span class="s3">):</span>
                            <span class="s1">geomnode</span><span class="s3">.</span><span class="s1">reparent_to</span><span class="s3">(</span><span class="s1">phynp</span><span class="s3">)</span>

            <span class="s0">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">get_extras</span><span class="s3">(</span><span class="s1">gltf_node</span><span class="s3">).</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s1">np</span><span class="s3">.</span><span class="s1">set_tag</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))</span>

            <span class="s0">for </span><span class="s1">child_nodeid </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'children'</span><span class="s3">, []):</span>
                <span class="s1">add_node</span><span class="s3">(</span><span class="s1">np</span><span class="s3">, </span><span class="s1">gltf_scene</span><span class="s3">, </span><span class="s1">child_nodeid</span><span class="s3">)</span>

            <span class="s2"># Handle visibility after children are loaded</span>
            <span class="s0">def </span><span class="s1">visible_recursive</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">visible</span><span class="s3">):</span>
                <span class="s0">if </span><span class="s1">visible</span><span class="s3">:</span>
                    <span class="s1">node</span><span class="s3">.</span><span class="s1">show</span><span class="s3">()</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">node</span><span class="s3">.</span><span class="s1">hide</span><span class="s3">()</span>
                <span class="s0">for </span><span class="s1">child </span><span class="s0">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">get_children</span><span class="s3">():</span>
                    <span class="s1">visible_recursive</span><span class="s3">(</span><span class="s1">child</span><span class="s3">, </span><span class="s1">visible</span><span class="s3">)</span>

            <span class="s1">hidden_nodes </span><span class="s3">= </span><span class="s1">scene_extras</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'hidden_nodes'</span><span class="s3">, [])</span>
            <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">in </span><span class="s1">hidden_nodes</span><span class="s3">:</span>
                <span class="s2">#print('Hiding', np)</span>
                <span class="s1">visible_recursive</span><span class="s3">(</span><span class="s1">np</span><span class="s3">, </span><span class="s0">False</span><span class="s3">)</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s2">#print('Showing', np)</span>
                <span class="s1">visible_recursive</span><span class="s3">(</span><span class="s1">np</span><span class="s3">, </span><span class="s0">True</span><span class="s3">)</span>

            <span class="s2"># Check if we need to deal with negative scale values</span>
            <span class="s1">scale </span><span class="s3">= </span><span class="s1">panda_node</span><span class="s3">.</span><span class="s1">get_transform</span><span class="s3">().</span><span class="s1">get_scale</span><span class="s3">()</span>
            <span class="s1">negscale </span><span class="s3">= </span><span class="s1">scale</span><span class="s3">.</span><span class="s1">x </span><span class="s3">* </span><span class="s1">scale</span><span class="s3">.</span><span class="s1">y </span><span class="s3">* </span><span class="s1">scale</span><span class="s3">.</span><span class="s1">z </span><span class="s3">&lt; </span><span class="s5">0</span>
            <span class="s0">if </span><span class="s1">negscale</span><span class="s3">:</span>
                <span class="s0">for </span><span class="s1">geomnode </span><span class="s0">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">find_all_matches</span><span class="s3">(</span><span class="s4">'**/+GeomNode'</span><span class="s3">):</span>
                    <span class="s1">tmp </span><span class="s3">= </span><span class="s1">geomnode</span><span class="s3">.</span><span class="s1">get_parent</span><span class="s3">().</span><span class="s1">attach_new_node</span><span class="s3">(</span><span class="s1">PandaNode</span><span class="s3">(</span><span class="s4">'ReverseCulling'</span><span class="s3">))</span>
                    <span class="s1">tmp</span><span class="s3">.</span><span class="s1">set_attrib</span><span class="s3">(</span><span class="s1">CullFaceAttrib</span><span class="s3">.</span><span class="s1">make_reverse</span><span class="s3">())</span>
                    <span class="s1">geomnode</span><span class="s3">.</span><span class="s1">reparent_to</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">)</span>

            <span class="s2"># Handle parenting to joints</span>
            <span class="s1">joint </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">joint_parents</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">)</span>
            <span class="s0">if </span><span class="s1">joint</span><span class="s3">:</span>
                <span class="s1">xformnp </span><span class="s3">= </span><span class="s1">root</span><span class="s3">.</span><span class="s1">attach_new_node</span><span class="s3">(</span><span class="s1">PandaNode</span><span class="s3">(</span><span class="s4">'{}-parent'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">node_name</span><span class="s3">)))</span>
                <span class="s1">np</span><span class="s3">.</span><span class="s1">reparent_to</span><span class="s3">(</span><span class="s1">xformnp</span><span class="s3">)</span>
                <span class="s1">joint</span><span class="s3">.</span><span class="s1">add_net_transform</span><span class="s3">(</span><span class="s1">xformnp</span><span class="s3">.</span><span class="s1">node</span><span class="s3">())</span>

            <span class="s2"># if the NodePath children were moved under a Character and has no other children,</span>
            <span class="s2"># then we can safely delete the NodePath</span>
            <span class="s0">if </span><span class="s1">charinfo </span><span class="s0">and not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">children</span><span class="s3">:</span>
                <span class="s1">np</span><span class="s3">.</span><span class="s1">remove_node</span><span class="s3">()</span>

        <span class="s0">for </span><span class="s1">sceneid</span><span class="s3">, </span><span class="s1">gltf_scene </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'scenes'</span><span class="s3">, [])):</span>
            <span class="s1">scene_name </span><span class="s3">= </span><span class="s1">gltf_scene</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'scene'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">sceneid</span><span class="s3">))</span>
            <span class="s1">scene_root </span><span class="s3">= </span><span class="s1">NodePath</span><span class="s3">(</span><span class="s1">ModelRoot</span><span class="s3">(</span><span class="s1">scene_name</span><span class="s3">))</span>

            <span class="s1">node_list </span><span class="s3">= </span><span class="s1">gltf_scene</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">]</span>
            <span class="s1">hidden_nodes </span><span class="s3">= </span><span class="s1">get_extras</span><span class="s3">(</span><span class="s1">gltf_scene</span><span class="s3">).</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'hidden_nodes'</span><span class="s3">, [])</span>
            <span class="s1">node_list </span><span class="s3">+= </span><span class="s1">hidden_nodes</span>

            <span class="s2"># Run through and pre-build Characters</span>
            <span class="s0">for </span><span class="s1">nodeid </span><span class="s0">in </span><span class="s1">node_list</span><span class="s3">:</span>
                <span class="s1">build_characters</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">)</span>

            <span class="s2"># Now iterate again to build the scene graph</span>
            <span class="s0">for </span><span class="s1">nodeid </span><span class="s0">in </span><span class="s1">node_list</span><span class="s3">:</span>
                <span class="s1">add_node</span><span class="s3">(</span><span class="s1">scene_root</span><span class="s3">, </span><span class="s1">gltf_scene</span><span class="s3">, </span><span class="s1">nodeid</span><span class="s3">)</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">flatten_nodes</span><span class="s3">:</span>
                <span class="s1">scene_root</span><span class="s3">.</span><span class="s1">flatten_medium</span><span class="s3">()</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">scenes</span><span class="s3">[</span><span class="s1">sceneid</span><span class="s3">] = </span><span class="s1">scene_root</span>

        <span class="s2"># Set the active scene</span>
        <span class="s1">sceneid </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'scene'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">sceneid </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scenes</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">active_scene </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scenes</span><span class="s3">[</span><span class="s1">sceneid</span><span class="s3">]</span>
        <span class="s0">if </span><span class="s4">'scenes' </span><span class="s0">in </span><span class="s1">gltf_data</span><span class="s3">:</span>
            <span class="s1">gltf_scene </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'scenes'</span><span class="s3">][</span><span class="s1">sceneid</span><span class="s3">]</span>
            <span class="s1">scene_extras </span><span class="s3">= </span><span class="s1">get_extras</span><span class="s3">(</span><span class="s1">gltf_scene</span><span class="s3">)</span>
            <span class="s0">if </span><span class="s4">'background_color' </span><span class="s0">in </span><span class="s1">scene_extras</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">background_color </span><span class="s3">= </span><span class="s1">scene_extras</span><span class="s3">[</span><span class="s4">'background_color'</span><span class="s3">]</span>
            <span class="s0">if </span><span class="s4">'active_camera' </span><span class="s0">in </span><span class="s1">scene_extras</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">active_camera </span><span class="s3">= </span><span class="s1">scene_extras</span><span class="s3">[</span><span class="s4">'active_camera'</span><span class="s3">]</span>

    <span class="s0">def </span><span class="s1">load_matrix</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mat</span><span class="s3">):</span>
        <span class="s1">lmat </span><span class="s3">= </span><span class="s1">LMatrix4</span><span class="s3">()</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">4</span><span class="s3">):</span>
            <span class="s1">lmat</span><span class="s3">.</span><span class="s1">set_row</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">LVecBase4</span><span class="s3">(*</span><span class="s1">mat</span><span class="s3">[</span><span class="s1">i </span><span class="s3">* </span><span class="s5">4</span><span class="s3">: </span><span class="s1">i </span><span class="s3">* </span><span class="s5">4 </span><span class="s3">+ </span><span class="s5">4</span><span class="s3">]))</span>
        <span class="s0">return </span><span class="s1">lmat</span>

    <span class="s0">def </span><span class="s1">load_buffer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">buffid</span><span class="s3">, </span><span class="s1">gltf_buffer</span><span class="s3">):</span>
        <span class="s0">if </span><span class="s4">'uri' </span><span class="s0">not in </span><span class="s1">gltf_buffer</span><span class="s3">:</span>
            <span class="s0">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffers</span><span class="s3">[</span><span class="s1">buffid</span><span class="s3">]</span>
            <span class="s0">return</span>

        <span class="s1">uri </span><span class="s3">= </span><span class="s1">gltf_buffer</span><span class="s3">[</span><span class="s4">'uri'</span><span class="s3">]</span>
        <span class="s0">if </span><span class="s1">uri </span><span class="s3">== </span><span class="s4">'_glb_bin' </span><span class="s0">and </span><span class="s1">buffid </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">buff_data </span><span class="s3">= </span><span class="s1">gltf_buffer</span><span class="s3">[</span><span class="s4">'_glb_bin'</span><span class="s3">]</span>
        <span class="s0">elif </span><span class="s1">uri</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'data:application/octet-stream;base64'</span><span class="s3">) </span><span class="s0">or </span><span class="s1">\</span>
           <span class="s1">uri</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'data:application/gltf-buffer;base64'</span><span class="s3">):</span>
            <span class="s1">buff_data </span><span class="s3">= </span><span class="s1">gltf_buffer</span><span class="s3">[</span><span class="s4">'uri'</span><span class="s3">].</span><span class="s1">split</span><span class="s3">(</span><span class="s4">','</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">buff_data </span><span class="s3">= </span><span class="s1">base64</span><span class="s3">.</span><span class="s1">b64decode</span><span class="s3">(</span><span class="s1">buff_data</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">uri</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">'.bin'</span><span class="s3">):</span>
            <span class="s1">buff_fname </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">filedir</span><span class="s3">.</span><span class="s1">to_os_specific</span><span class="s3">(), </span><span class="s1">uri</span><span class="s3">)</span>
            <span class="s0">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">buff_fname</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s3">) </span><span class="s0">as </span><span class="s1">buff_file</span><span class="s3">:</span>
                <span class="s1">buff_data </span><span class="s3">= </span><span class="s1">buff_file</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s1">gltf_buffer</span><span class="s3">[</span><span class="s4">'byteLength'</span><span class="s3">])</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span>
                <span class="s4">&quot;Buffer {} has an unsupported uri ({}), using a zero filled buffer instead&quot;</span>
                <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">buffid</span><span class="s3">, </span><span class="s1">uri</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">buff_data </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">(</span><span class="s1">gltf_buffer</span><span class="s3">[</span><span class="s4">'byteLength'</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">buffers</span><span class="s3">[</span><span class="s1">buffid</span><span class="s3">] = </span><span class="s1">buff_data</span>

    <span class="s0">def </span><span class="s1">get_buffer_view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">, </span><span class="s1">view_id</span><span class="s3">):</span>
        <span class="s1">buffview </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'bufferViews'</span><span class="s3">][</span><span class="s1">view_id</span><span class="s3">]</span>
        <span class="s1">buff </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffers</span><span class="s3">[</span><span class="s1">buffview</span><span class="s3">[</span><span class="s4">'buffer'</span><span class="s3">]]</span>
        <span class="s1">start </span><span class="s3">= </span><span class="s1">buffview</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">buffview</span><span class="s3">[</span><span class="s4">'byteLength'</span><span class="s3">]</span>
        <span class="s0">if </span><span class="s4">'byteStride' </span><span class="s0">in </span><span class="s1">buffview</span><span class="s3">:</span>
            <span class="s0">return </span><span class="s1">memoryview</span><span class="s3">(</span><span class="s1">buff</span><span class="s3">)[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">:</span><span class="s1">buffview</span><span class="s3">[</span><span class="s4">'byteStride'</span><span class="s3">]]</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s0">return </span><span class="s1">memoryview</span><span class="s3">(</span><span class="s1">buff</span><span class="s3">)[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">]</span>

    <span class="s0">def </span><span class="s1">make_texture_srgb</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">texture</span><span class="s3">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">no_srgb</span><span class="s3">:</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">texture </span><span class="s0">is None</span><span class="s3">:</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">texture</span><span class="s3">.</span><span class="s1">get_num_components</span><span class="s3">() == </span><span class="s5">3</span><span class="s3">:</span>
            <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_format</span><span class="s3">(</span><span class="s1">Texture</span><span class="s3">.</span><span class="s1">F_srgb</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">texture</span><span class="s3">.</span><span class="s1">get_num_components</span><span class="s3">() == </span><span class="s5">4</span><span class="s3">:</span>
            <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_format</span><span class="s3">(</span><span class="s1">Texture</span><span class="s3">.</span><span class="s1">F_srgb_alpha</span><span class="s3">)</span>

    <span class="s0">def </span><span class="s1">load_fallback_texture</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">texture </span><span class="s3">= </span><span class="s1">Texture</span><span class="s3">(</span><span class="s4">'pbr-fallback'</span><span class="s3">)</span>
        <span class="s1">texture</span><span class="s3">.</span><span class="s1">setup_2d_texture</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">Texture</span><span class="s3">.</span><span class="s1">T_unsigned_byte</span><span class="s3">, </span><span class="s1">Texture</span><span class="s3">.</span><span class="s1">F_rgba</span><span class="s3">)</span>
        <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_clear_color</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>
        <span class="s1">texture</span><span class="s3">.</span><span class="s1">make_ram_image</span><span class="s3">()</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">[</span><span class="s4">'__pbr-fallback'</span><span class="s3">] = </span><span class="s1">texture</span>

        <span class="s1">texture </span><span class="s3">= </span><span class="s1">Texture</span><span class="s3">(</span><span class="s4">'emission-fallback'</span><span class="s3">)</span>
        <span class="s1">texture</span><span class="s3">.</span><span class="s1">setup_2d_texture</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">Texture</span><span class="s3">.</span><span class="s1">T_unsigned_byte</span><span class="s3">, </span><span class="s1">Texture</span><span class="s3">.</span><span class="s1">F_luminance</span><span class="s3">)</span>
        <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_clear_color</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">[</span><span class="s4">'__emission-fallback'</span><span class="s3">] = </span><span class="s1">texture</span>

        <span class="s1">texture </span><span class="s3">= </span><span class="s1">Texture</span><span class="s3">(</span><span class="s4">'normal-fallback'</span><span class="s3">)</span>
        <span class="s1">texture</span><span class="s3">.</span><span class="s1">setup_2d_texture</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">Texture</span><span class="s3">.</span><span class="s1">T_unsigned_byte</span><span class="s3">, </span><span class="s1">Texture</span><span class="s3">.</span><span class="s1">F_rgb</span><span class="s3">)</span>
        <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_clear_color</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>
        <span class="s1">texture</span><span class="s3">.</span><span class="s1">make_ram_image</span><span class="s3">()</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">[</span><span class="s4">'__normal-fallback'</span><span class="s3">] = </span><span class="s1">texture</span>

    <span class="s0">def </span><span class="s1">load_texture</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">texid</span><span class="s3">, </span><span class="s1">gltf_tex</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">):</span>
        <span class="s0">if </span><span class="s4">'source' </span><span class="s0">not in </span><span class="s1">gltf_tex</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Texture '{}' has no source, skipping&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">texid</span><span class="s3">))</span>
            <span class="s0">return</span>

        <span class="s0">def </span><span class="s1">load_embedded_image</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">ext</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
            <span class="s0">if not </span><span class="s1">name</span><span class="s3">:</span>
                <span class="s1">name </span><span class="s3">= </span><span class="s4">f'gltf-embedded-</span><span class="s0">{</span><span class="s1">texid</span><span class="s0">}</span><span class="s4">'</span>
            <span class="s1">img_type_registry </span><span class="s3">= </span><span class="s1">PNMFileTypeRegistry</span><span class="s3">.</span><span class="s1">get_global_ptr</span><span class="s3">()</span>
            <span class="s1">img_type </span><span class="s3">= </span><span class="s1">img_type_registry</span><span class="s3">.</span><span class="s1">get_type_from_extension</span><span class="s3">(</span><span class="s1">ext</span><span class="s3">)</span>

            <span class="s1">img </span><span class="s3">= </span><span class="s1">PNMImage</span><span class="s3">()</span>
            <span class="s1">img</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s1">StringStream</span><span class="s3">(</span><span class="s1">data</span><span class="s3">), </span><span class="s1">type</span><span class="s3">=</span><span class="s1">img_type</span><span class="s3">)</span>

            <span class="s1">texture </span><span class="s3">= </span><span class="s1">Texture</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">texture</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">img</span><span class="s3">)</span>

            <span class="s0">return </span><span class="s1">texture</span>

        <span class="s1">source </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'images'</span><span class="s3">][</span><span class="s1">gltf_tex</span><span class="s3">[</span><span class="s4">'source'</span><span class="s3">]]</span>
        <span class="s0">if </span><span class="s4">'uri' </span><span class="s0">in </span><span class="s1">source</span><span class="s3">:</span>
            <span class="s1">uri </span><span class="s3">= </span><span class="s1">source</span><span class="s3">[</span><span class="s4">'uri'</span><span class="s3">]</span>
            <span class="s0">if </span><span class="s1">uri</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'data:'</span><span class="s3">):</span>
                <span class="s1">info</span><span class="s3">, </span><span class="s1">b64data </span><span class="s3">= </span><span class="s1">uri</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">','</span><span class="s3">)</span>

                <span class="s0">if not </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'data:image/'</span><span class="s3">) </span><span class="s0">and </span><span class="s1">info</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">';base64'</span><span class="s3">)):</span>
                    <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span>
                        <span class="s4">f'Unknown data URI: </span><span class="s0">{</span><span class="s1">info</span><span class="s0">}</span><span class="s4">'</span>
                    <span class="s3">)</span>

                <span class="s1">name </span><span class="s3">= </span><span class="s1">source</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">''</span><span class="s3">)</span>
                <span class="s1">ext </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">'data:image/'</span><span class="s3">, </span><span class="s4">''</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">';base64'</span><span class="s3">, </span><span class="s4">''</span><span class="s3">)</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">base64</span><span class="s3">.</span><span class="s1">b64decode</span><span class="s3">(</span><span class="s1">b64data</span><span class="s3">)</span>

                <span class="s1">texture </span><span class="s3">= </span><span class="s1">load_embedded_image</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">ext</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">uri </span><span class="s3">= </span><span class="s1">urllib</span><span class="s3">.</span><span class="s1">parse</span><span class="s3">.</span><span class="s1">unquote</span><span class="s3">(</span><span class="s1">uri</span><span class="s3">)</span>
                <span class="s1">uri </span><span class="s3">= </span><span class="s1">Filename</span><span class="s3">.</span><span class="s1">from_os_specific</span><span class="s3">(</span><span class="s1">uri</span><span class="s3">)</span>
                <span class="s1">fulluri </span><span class="s3">= </span><span class="s1">Filename</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">filedir</span><span class="s3">, </span><span class="s1">uri</span><span class="s3">)</span>
                <span class="s1">texture </span><span class="s3">= </span><span class="s1">TexturePool</span><span class="s3">.</span><span class="s1">load_texture</span><span class="s3">(</span><span class="s1">fulluri</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s0">False</span><span class="s3">, </span><span class="s1">LoaderOptions</span><span class="s3">())</span>
                <span class="s0">if not </span><span class="s1">texture</span><span class="s3">:</span>
                    <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">f'failed to load texture: </span><span class="s0">{</span><span class="s1">fulluri</span><span class="s0">}</span><span class="s4">'</span><span class="s3">)</span>
                <span class="s1">texture</span><span class="s3">.</span><span class="s1">filename </span><span class="s3">= </span><span class="s1">uri</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">name </span><span class="s3">= </span><span class="s1">source</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">''</span><span class="s3">)</span>
            <span class="s1">ext </span><span class="s3">= </span><span class="s1">source</span><span class="s3">[</span><span class="s4">'mimeType'</span><span class="s3">].</span><span class="s1">split</span><span class="s3">(</span><span class="s4">'/'</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_buffer_view</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">, </span><span class="s1">source</span><span class="s3">[</span><span class="s4">'bufferView'</span><span class="s3">])</span>
            <span class="s1">texture </span><span class="s3">= </span><span class="s1">load_embedded_image</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">ext</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s4">'sampler' </span><span class="s0">in </span><span class="s1">gltf_tex</span><span class="s3">:</span>
            <span class="s1">gltf_sampler </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'samplers'</span><span class="s3">][</span><span class="s1">gltf_tex</span><span class="s3">[</span><span class="s4">'sampler'</span><span class="s3">]]</span>
            <span class="s0">if </span><span class="s4">'magFilter' </span><span class="s0">in </span><span class="s1">gltf_sampler</span><span class="s3">:</span>
                <span class="s0">if </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'magFilter'</span><span class="s3">] == </span><span class="s5">9728</span><span class="s3">:</span>
                    <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_magfilter</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">FT_nearest</span><span class="s3">)</span>
                <span class="s0">elif </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'magFilter'</span><span class="s3">] == </span><span class="s5">9729</span><span class="s3">:</span>
                    <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_magfilter</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">FT_linear</span><span class="s3">)</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">print</span><span class="s3">(</span>
                        <span class="s4">&quot;Sampler {} has unsupported magFilter type {}&quot;</span>
                        <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">gltf_tex</span><span class="s3">[</span><span class="s4">'sampler'</span><span class="s3">], </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'magFilter'</span><span class="s3">])</span>
                    <span class="s3">)</span>
            <span class="s0">if </span><span class="s4">'minFilter' </span><span class="s0">in </span><span class="s1">gltf_sampler</span><span class="s3">:</span>
                <span class="s0">if </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'minFilter'</span><span class="s3">] == </span><span class="s5">9728</span><span class="s3">:</span>
                    <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_minfilter</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">FT_nearest</span><span class="s3">)</span>
                <span class="s0">elif </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'minFilter'</span><span class="s3">] == </span><span class="s5">9729</span><span class="s3">:</span>
                    <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_minfilter</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">FT_linear</span><span class="s3">)</span>
                <span class="s0">elif </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'minFilter'</span><span class="s3">] == </span><span class="s5">9984</span><span class="s3">:</span>
                    <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_minfilter</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">FT_nearest_mipmap_nearest</span><span class="s3">)</span>
                <span class="s0">elif </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'minFilter'</span><span class="s3">] == </span><span class="s5">9985</span><span class="s3">:</span>
                    <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_minfilter</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">FT_linear_mipmap_nearest</span><span class="s3">)</span>
                <span class="s0">elif </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'minFilter'</span><span class="s3">] == </span><span class="s5">9986</span><span class="s3">:</span>
                    <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_minfilter</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">FT_nearest_mipmap_linear</span><span class="s3">)</span>
                <span class="s0">elif </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'minFilter'</span><span class="s3">] == </span><span class="s5">9987</span><span class="s3">:</span>
                    <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_minfilter</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">FT_linear_mipmap_linear</span><span class="s3">)</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">print</span><span class="s3">(</span>
                        <span class="s4">&quot;Sampler {} has unsupported minFilter type {}&quot;</span>
                        <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">gltf_tex</span><span class="s3">[</span><span class="s4">'sampler'</span><span class="s3">], </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'minFilter'</span><span class="s3">])</span>
                    <span class="s3">)</span>

            <span class="s1">wraps </span><span class="s3">= </span><span class="s1">gltf_sampler</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'wrapS'</span><span class="s3">, </span><span class="s5">10497</span><span class="s3">)</span>
            <span class="s0">if </span><span class="s1">wraps </span><span class="s3">== </span><span class="s5">33071</span><span class="s3">:</span>
                <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_wrap_u</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">WM_clamp</span><span class="s3">)</span>
            <span class="s0">elif </span><span class="s1">wraps </span><span class="s3">== </span><span class="s5">33648</span><span class="s3">:</span>
                <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_wrap_u</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">WM_mirror</span><span class="s3">)</span>
            <span class="s0">elif </span><span class="s1">wraps </span><span class="s3">== </span><span class="s5">10497</span><span class="s3">:</span>
                <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_wrap_u</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">WM_repeat</span><span class="s3">)</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span>
                    <span class="s4">&quot;Sampler {} has unsupported wrapS type {}&quot;</span>
                    <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">gltf_tex</span><span class="s3">[</span><span class="s4">'sampler'</span><span class="s3">], </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'wrapS'</span><span class="s3">])</span>
                <span class="s3">)</span>

            <span class="s1">wrapt </span><span class="s3">= </span><span class="s1">gltf_sampler</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'wrapT'</span><span class="s3">, </span><span class="s5">10497</span><span class="s3">)</span>
            <span class="s0">if </span><span class="s1">wrapt </span><span class="s3">== </span><span class="s5">33071</span><span class="s3">:</span>
                <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_wrap_v</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">WM_clamp</span><span class="s3">)</span>
            <span class="s0">elif </span><span class="s1">wrapt </span><span class="s3">== </span><span class="s5">33648</span><span class="s3">:</span>
                <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_wrap_v</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">WM_mirror</span><span class="s3">)</span>
            <span class="s0">elif </span><span class="s1">wrapt </span><span class="s3">== </span><span class="s5">10497</span><span class="s3">:</span>
                <span class="s1">texture</span><span class="s3">.</span><span class="s1">set_wrap_v</span><span class="s3">(</span><span class="s1">SamplerState</span><span class="s3">.</span><span class="s1">WM_repeat</span><span class="s3">)</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span>
                    <span class="s4">&quot;Sampler {} has unsupported wrapT type {}&quot;</span>
                    <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">gltf_tex</span><span class="s3">[</span><span class="s4">'sampler'</span><span class="s3">], </span><span class="s1">gltf_sampler</span><span class="s3">[</span><span class="s4">'wrapT'</span><span class="s3">])</span>
                <span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">[</span><span class="s1">texid</span><span class="s3">] = </span><span class="s1">texture</span>

    <span class="s0">def </span><span class="s1">load_material</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">matid</span><span class="s3">, </span><span class="s1">gltf_mat</span><span class="s3">):</span>
        <span class="s1">matname </span><span class="s3">= </span><span class="s1">gltf_mat</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'mat'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">matid</span><span class="s3">))</span>
        <span class="s1">state </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mat_states</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">matid</span><span class="s3">, </span><span class="s1">RenderState</span><span class="s3">.</span><span class="s1">make_empty</span><span class="s3">())</span>

        <span class="s0">if </span><span class="s1">matid </span><span class="s0">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mat_mesh_map</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">mat_mesh_map</span><span class="s3">[</span><span class="s1">matid</span><span class="s3">] = []</span>

        <span class="s1">pmat </span><span class="s3">= </span><span class="s1">Material</span><span class="s3">(</span><span class="s1">matname</span><span class="s3">)</span>
        <span class="s1">base_color_fallback </span><span class="s3">= {</span><span class="s4">'index'</span><span class="s3">: </span><span class="s4">'__pbr-fallback'</span><span class="s3">, </span><span class="s4">'texCoord'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">}</span>
        <span class="s1">metallic_roughness_fallback </span><span class="s3">= {</span><span class="s4">'index'</span><span class="s3">: </span><span class="s4">'__pbr-fallback'</span><span class="s3">, </span><span class="s4">'texCoord'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">}</span>
        <span class="s1">emission_fallback </span><span class="s3">= {</span><span class="s4">'index'</span><span class="s3">: </span><span class="s4">'__emission-fallback'</span><span class="s3">, </span><span class="s4">'texCoord'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">}</span>
        <span class="s1">normal_fallback </span><span class="s3">= {</span><span class="s4">'index'</span><span class="s3">: </span><span class="s4">'__normal-fallback'</span><span class="s3">, </span><span class="s4">'texCoord'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">}</span>
        <span class="s1">texinfos </span><span class="s3">= []</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">legacy_materials</span><span class="s3">:</span>
            <span class="s0">if </span><span class="s4">'pbrMetallicRoughness' </span><span class="s0">in </span><span class="s1">gltf_mat</span><span class="s3">:</span>
                <span class="s1">pbrsettings </span><span class="s3">= </span><span class="s1">gltf_mat</span><span class="s3">[</span><span class="s4">'pbrMetallicRoughness'</span><span class="s3">]</span>

                <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_diffuse</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(*</span><span class="s1">pbrsettings</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'baseColorFactor'</span><span class="s3">, [</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">])))</span>
                <span class="s1">texinfos</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">pbrsettings</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'baseColorTexture'</span><span class="s3">, </span><span class="s1">base_color_fallback</span><span class="s3">))</span>
                <span class="s0">if </span><span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'index'</span><span class="s3">] </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">make_texture_srgb</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">[</span><span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'index'</span><span class="s3">]])</span>
                <span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'mode'</span><span class="s3">] = </span><span class="s1">TextureStage</span><span class="s3">.</span><span class="s1">M_modulate</span>

            <span class="s1">texinfos</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">gltf_mat</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'normalTexture'</span><span class="s3">, </span><span class="s1">normal_fallback</span><span class="s3">))</span>
            <span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'mode'</span><span class="s3">] = </span><span class="s1">TextureStage</span><span class="s3">.</span><span class="s1">M_normal</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">mat_extensions </span><span class="s3">= </span><span class="s1">gltf_mat</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'extensions'</span><span class="s3">, {})</span>
            <span class="s0">if </span><span class="s4">'BP_materials_legacy' </span><span class="s0">in </span><span class="s1">mat_extensions</span><span class="s3">:</span>
                <span class="s1">matsettings </span><span class="s3">= </span><span class="s1">mat_extensions</span><span class="s3">[</span><span class="s4">'BP_materials_legacy'</span><span class="s3">][</span><span class="s4">'bpLegacy'</span><span class="s3">]</span>
                <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_shininess</span><span class="s3">(</span><span class="s1">matsettings</span><span class="s3">[</span><span class="s4">'shininessFactor'</span><span class="s3">])</span>
                <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_ambient</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(*</span><span class="s1">matsettings</span><span class="s3">[</span><span class="s4">'ambientFactor'</span><span class="s3">]))</span>

                <span class="s0">if </span><span class="s4">'diffuseTexture' </span><span class="s0">in </span><span class="s1">matsettings</span><span class="s3">:</span>
                    <span class="s1">texinfo </span><span class="s3">= </span><span class="s1">matsettings</span><span class="s3">[</span><span class="s4">'diffuseTexture'</span><span class="s3">]</span>
                    <span class="s1">texinfos</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">texinfo</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s1">matsettings</span><span class="s3">[</span><span class="s4">'diffuseTextureSrgb'</span><span class="s3">] </span><span class="s0">and </span><span class="s1">texinfo</span><span class="s3">[</span><span class="s4">'index'</span><span class="s3">] </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">:</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">make_texture_srgb</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">[</span><span class="s1">texinfo</span><span class="s3">[</span><span class="s4">'index'</span><span class="s3">]])</span>
                    <span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'mode'</span><span class="s3">] = </span><span class="s1">TextureStage</span><span class="s3">.</span><span class="s1">M_modulate</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_diffuse</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(*</span><span class="s1">matsettings</span><span class="s3">[</span><span class="s4">'diffuseFactor'</span><span class="s3">]))</span>

                <span class="s0">if </span><span class="s4">'emissionTexture' </span><span class="s0">in </span><span class="s1">matsettings</span><span class="s3">:</span>
                    <span class="s1">texinfo </span><span class="s3">= </span><span class="s1">matsettings</span><span class="s3">[</span><span class="s4">'emissionTexture'</span><span class="s3">]</span>
                    <span class="s1">texinfos</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">texinfo</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s1">matsettings</span><span class="s3">[</span><span class="s4">'emissionTextureSrgb'</span><span class="s3">] </span><span class="s0">and </span><span class="s1">texinfo</span><span class="s3">[</span><span class="s4">'index'</span><span class="s3">] </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">:</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">make_texture_srgb</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">[</span><span class="s1">texinfo</span><span class="s3">[</span><span class="s4">'index'</span><span class="s3">]])</span>
                    <span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'mode'</span><span class="s3">] = </span><span class="s1">TextureStage</span><span class="s3">.</span><span class="s1">M_emission</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_emission</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(*</span><span class="s1">matsettings</span><span class="s3">[</span><span class="s4">'emissionFactor'</span><span class="s3">]))</span>

                <span class="s0">if </span><span class="s4">'specularTexture' </span><span class="s0">in </span><span class="s1">matsettings</span><span class="s3">:</span>
                    <span class="s1">texinfo </span><span class="s3">= </span><span class="s1">matsettings</span><span class="s3">[</span><span class="s4">'specularTexture'</span><span class="s3">]</span>
                    <span class="s1">texinfos</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">texinfo</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s1">matsettings</span><span class="s3">[</span><span class="s4">'specularTextureSrgb'</span><span class="s3">] </span><span class="s0">and </span><span class="s1">texinfo</span><span class="s3">[</span><span class="s4">'index'</span><span class="s3">] </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">:</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">make_texture_srgb</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">[</span><span class="s1">texinfo</span><span class="s3">[</span><span class="s4">'index'</span><span class="s3">]])</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_specular</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(*</span><span class="s1">matsettings</span><span class="s3">[</span><span class="s4">'specularFactor'</span><span class="s3">]))</span>
            <span class="s0">elif </span><span class="s4">'pbrMetallicRoughness' </span><span class="s0">in </span><span class="s1">gltf_mat</span><span class="s3">:</span>
                <span class="s1">pbrsettings </span><span class="s3">= </span><span class="s1">gltf_mat</span><span class="s3">[</span><span class="s4">'pbrMetallicRoughness'</span><span class="s3">]</span>

                <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_base_color</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(*</span><span class="s1">pbrsettings</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'baseColorFactor'</span><span class="s3">, [</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">])))</span>
                <span class="s1">texinfos</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">pbrsettings</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'baseColorTexture'</span><span class="s3">, </span><span class="s1">base_color_fallback</span><span class="s3">))</span>
                <span class="s0">if </span><span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'index'</span><span class="s3">] </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">make_texture_srgb</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">[</span><span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'index'</span><span class="s3">]])</span>

                <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_metallic</span><span class="s3">(</span><span class="s1">pbrsettings</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'metallicFactor'</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">))</span>
                <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_roughness</span><span class="s3">(</span><span class="s1">pbrsettings</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'roughnessFactor'</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">))</span>
                <span class="s1">texinfos</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">pbrsettings</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'metallicRoughnessTexture'</span><span class="s3">, </span><span class="s1">metallic_roughness_fallback</span><span class="s3">))</span>
                <span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'mode'</span><span class="s3">] = </span><span class="s1">TextureStage</span><span class="s3">.</span><span class="s1">M_selector</span>

            <span class="s2"># Normal map</span>
            <span class="s1">texinfos</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">gltf_mat</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'normalTexture'</span><span class="s3">, </span><span class="s1">normal_fallback</span><span class="s3">))</span>
            <span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'mode'</span><span class="s3">] = </span><span class="s1">TextureStage</span><span class="s3">.</span><span class="s1">M_normal</span>

            <span class="s2"># Emission map</span>
            <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_emission</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(*</span><span class="s1">gltf_mat</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'emissiveFactor'</span><span class="s3">, [</span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">]), </span><span class="s1">w</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">))</span>
            <span class="s1">texinfos</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">gltf_mat</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'emissiveTexture'</span><span class="s3">, </span><span class="s1">emission_fallback</span><span class="s3">))</span>
            <span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'mode'</span><span class="s3">] = </span><span class="s1">TextureStage</span><span class="s3">.</span><span class="s1">M_emission</span>
            <span class="s0">if </span><span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'index'</span><span class="s3">] </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">make_texture_srgb</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">[</span><span class="s1">texinfos</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][</span><span class="s4">'index'</span><span class="s3">]])</span>

            <span class="s2"># Index of refraction</span>
            <span class="s1">ior_ext </span><span class="s3">= </span><span class="s1">mat_extensions</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'KHR_materials_ior'</span><span class="s3">, {})</span>
            <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_refractive_index</span><span class="s3">(</span><span class="s1">ior_ext</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'ior'</span><span class="s3">, </span><span class="s5">1.5</span><span class="s3">))</span>

        <span class="s1">double_sided </span><span class="s3">= </span><span class="s1">gltf_mat</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'doubleSided'</span><span class="s3">, </span><span class="s0">False</span><span class="s3">)</span>
        <span class="s1">pmat</span><span class="s3">.</span><span class="s1">set_twoside</span><span class="s3">(</span><span class="s1">double_sided</span><span class="s3">)</span>

        <span class="s1">state </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">set_attrib</span><span class="s3">(</span><span class="s1">MaterialAttrib</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">pmat</span><span class="s3">))</span>

        <span class="s0">if </span><span class="s1">double_sided</span><span class="s3">:</span>
            <span class="s1">state </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">set_attrib</span><span class="s3">(</span><span class="s1">CullFaceAttrib</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">CullFaceAttrib</span><span class="s3">.</span><span class="s1">MCullNone</span><span class="s3">))</span>

        <span class="s2"># Setup textures</span>
        <span class="s1">tex_attrib </span><span class="s3">= </span><span class="s1">TextureAttrib</span><span class="s3">.</span><span class="s1">make</span><span class="s3">()</span>
        <span class="s1">tex_mat_attrib </span><span class="s3">= </span><span class="s0">None</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">texinfo </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">texinfos</span><span class="s3">):</span>
            <span class="s1">texdata </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">texinfo</span><span class="s3">[</span><span class="s4">'index'</span><span class="s3">], </span><span class="s0">None</span><span class="s3">)</span>
            <span class="s0">if </span><span class="s1">texdata </span><span class="s0">is None</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Could not find texture for key: {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">texinfo</span><span class="s3">[</span><span class="s4">'index'</span><span class="s3">]))</span>
                <span class="s0">continue</span>

            <span class="s1">texstage </span><span class="s3">= </span><span class="s1">TextureStage</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">i</span><span class="s3">))</span>
            <span class="s1">texstage</span><span class="s3">.</span><span class="s1">set_sort</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>
            <span class="s1">texstage</span><span class="s3">.</span><span class="s1">set_texcoord_name</span><span class="s3">(</span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_texcoord_name</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">texinfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'texCoord'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))))</span>
            <span class="s1">texstage</span><span class="s3">.</span><span class="s1">set_mode</span><span class="s3">(</span><span class="s1">texinfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'mode'</span><span class="s3">, </span><span class="s1">TextureStage</span><span class="s3">.</span><span class="s1">M_modulate</span><span class="s3">))</span>
            <span class="s1">tex_attrib </span><span class="s3">= </span><span class="s1">tex_attrib</span><span class="s3">.</span><span class="s1">add_on_stage</span><span class="s3">(</span><span class="s1">texstage</span><span class="s3">, </span><span class="s1">texdata</span><span class="s3">)</span>

            <span class="s1">transform_ext </span><span class="s3">= </span><span class="s1">texinfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'extensions'</span><span class="s3">, {}).</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'KHR_texture_transform'</span><span class="s3">)</span>
            <span class="s0">if </span><span class="s1">transform_ext</span><span class="s3">:</span>
                <span class="s0">if </span><span class="s4">'texCoord' </span><span class="s0">in </span><span class="s1">transform_ext</span><span class="s3">:</span>
                    <span class="s2"># This overrides, if present.</span>
                    <span class="s1">texstage</span><span class="s3">.</span><span class="s1">set_texcoord_name</span><span class="s3">(</span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_texcoord_name</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">transform_ext</span><span class="s3">[</span><span class="s4">'texCoord'</span><span class="s3">])))</span>

                <span class="s2"># glTF uses a transform origin of the upper-left corner of the</span>
                <span class="s2"># texture, whereas Panda uses the lower-left corner.</span>
                <span class="s1">mat </span><span class="s3">= </span><span class="s1">Mat3</span><span class="s3">()</span>
                <span class="s1">scale </span><span class="s3">= </span><span class="s1">transform_ext</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'scale'</span><span class="s3">)</span>
                <span class="s0">if </span><span class="s1">scale</span><span class="s3">:</span>
                    <span class="s1">mat </span><span class="s3">*= (</span><span class="s1">Mat3</span><span class="s3">.</span><span class="s1">translate_mat</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">) *</span>
                            <span class="s1">Mat3</span><span class="s3">.</span><span class="s1">scale_mat</span><span class="s3">(</span><span class="s1">scale</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">scale</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) *</span>
                            <span class="s1">Mat3</span><span class="s3">.</span><span class="s1">translate_mat</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>

                <span class="s1">rot </span><span class="s3">= </span><span class="s1">transform_ext</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'rotation'</span><span class="s3">)</span>
                <span class="s0">if </span><span class="s1">rot</span><span class="s3">:</span>
                    <span class="s1">mat </span><span class="s3">*= (</span><span class="s1">Mat3</span><span class="s3">.</span><span class="s1">translate_mat</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">) *</span>
                            <span class="s1">Mat3</span><span class="s3">.</span><span class="s1">rotate_mat</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">degrees</span><span class="s3">(</span><span class="s1">rot</span><span class="s3">)) *</span>
                            <span class="s1">Mat3</span><span class="s3">.</span><span class="s1">translate_mat</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>

                <span class="s1">offset </span><span class="s3">= </span><span class="s1">transform_ext</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'offset'</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">])</span>
                <span class="s0">if </span><span class="s1">offset</span><span class="s3">:</span>
                    <span class="s1">mat </span><span class="s3">*= </span><span class="s1">Mat3</span><span class="s3">.</span><span class="s1">translate_mat</span><span class="s3">(</span><span class="s1">offset</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], -</span><span class="s1">offset</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>

                <span class="s1">transform </span><span class="s3">= </span><span class="s1">TransformState</span><span class="s3">.</span><span class="s1">make_mat3</span><span class="s3">(</span><span class="s1">mat</span><span class="s3">)</span>
                <span class="s0">if not </span><span class="s1">tex_mat_attrib</span><span class="s3">:</span>
                    <span class="s1">tex_mat_attrib </span><span class="s3">= </span><span class="s1">TexMatrixAttrib</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">texstage</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">)</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">tex_mat_attrib </span><span class="s3">= </span><span class="s1">tex_mat_attrib</span><span class="s3">.</span><span class="s1">add_stage</span><span class="s3">(</span><span class="s1">texstage</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">)</span>

        <span class="s1">state </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">set_attrib</span><span class="s3">(</span><span class="s1">tex_attrib</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">tex_mat_attrib</span><span class="s3">:</span>
            <span class="s1">state </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">set_attrib</span><span class="s3">(</span><span class="s1">tex_mat_attrib</span><span class="s3">)</span>

        <span class="s2"># Setup Alpha mode</span>
        <span class="s1">alpha_mode </span><span class="s3">= </span><span class="s1">gltf_mat</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'alphaMode'</span><span class="s3">, </span><span class="s4">'OPAQUE'</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">alpha_mode </span><span class="s3">== </span><span class="s4">'MASK'</span><span class="s3">:</span>
            <span class="s1">alpha_cutoff </span><span class="s3">= </span><span class="s1">gltf_mat</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'alphaCutoff'</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">)</span>
            <span class="s1">alpha_attrib </span><span class="s3">= </span><span class="s1">AlphaTestAttrib</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">AlphaTestAttrib</span><span class="s3">.</span><span class="s1">M_greater_equal</span><span class="s3">, </span><span class="s1">alpha_cutoff</span><span class="s3">)</span>
            <span class="s1">state </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">set_attrib</span><span class="s3">(</span><span class="s1">alpha_attrib</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">alpha_mode </span><span class="s3">== </span><span class="s4">'BLEND'</span><span class="s3">:</span>
            <span class="s1">transp_attrib </span><span class="s3">= </span><span class="s1">TransparencyAttrib</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">TransparencyAttrib</span><span class="s3">.</span><span class="s1">M_alpha</span><span class="s3">)</span>
            <span class="s1">state </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">set_attrib</span><span class="s3">(</span><span class="s1">transp_attrib</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">alpha_mode </span><span class="s3">!= </span><span class="s4">'OPAQUE'</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span>
                <span class="s4">&quot;Warning: material {} has an unsupported alphaMode: {}&quot;</span>
                <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">matid</span><span class="s3">, </span><span class="s1">alpha_mode</span><span class="s3">)</span>
            <span class="s3">)</span>

        <span class="s2"># Remove stale meshes</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">mat_mesh_map</span><span class="s3">[</span><span class="s1">matid</span><span class="s3">] = [</span>
            <span class="s1">pair </span><span class="s0">for </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mat_mesh_map</span><span class="s3">[</span><span class="s1">matid</span><span class="s3">] </span><span class="s0">if </span><span class="s1">pair</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">meshes</span>
        <span class="s3">]</span>

        <span class="s2"># Reload the material</span>
        <span class="s0">for </span><span class="s1">meshid</span><span class="s3">, </span><span class="s1">geom_idx </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mat_mesh_map</span><span class="s3">[</span><span class="s1">matid</span><span class="s3">]:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">meshes</span><span class="s3">[</span><span class="s1">meshid</span><span class="s3">].</span><span class="s1">set_geom_state</span><span class="s3">(</span><span class="s1">geom_idx</span><span class="s3">, </span><span class="s1">state</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">mat_states</span><span class="s3">[</span><span class="s1">matid</span><span class="s3">] = </span><span class="s1">state</span>

    <span class="s0">def </span><span class="s1">load_skin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">skinid</span><span class="s3">, </span><span class="s1">gltf_skin</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">):</span>
        <span class="s2"># Find a common root node.  First gather the parents of each node.</span>
        <span class="s2"># Note that we ignore the &quot;skeleton&quot; property of the glTF file, since it</span>
        <span class="s2"># is just a hint and not particularly necessary.</span>
        <span class="s1">parents </span><span class="s3">= [</span><span class="s0">None</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">])</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">node </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">]):</span>
            <span class="s0">for </span><span class="s1">child </span><span class="s0">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'children'</span><span class="s3">, ()):</span>
                <span class="s1">parents</span><span class="s3">[</span><span class="s1">child</span><span class="s3">] = </span><span class="s1">i</span>

        <span class="s2"># Now create a path for each joint node as well as each node that</span>
        <span class="s2"># is skinned with this skeleton, so that both are under the Character.</span>
        <span class="s1">paths </span><span class="s3">= []</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">gltf_node </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">]):</span>
            <span class="s0">if </span><span class="s1">i </span><span class="s0">in </span><span class="s1">gltf_skin</span><span class="s3">[</span><span class="s4">'joints'</span><span class="s3">] </span><span class="s0">or </span><span class="s1">gltf_node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'skin'</span><span class="s3">) == </span><span class="s1">skinid</span><span class="s3">:</span>
                <span class="s1">path </span><span class="s3">= [</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s0">while </span><span class="s1">parents</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s0">is not None</span><span class="s3">:</span>
                    <span class="s1">i </span><span class="s3">= </span><span class="s1">parents</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                    <span class="s1">path</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
                <span class="s1">paths</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">path</span><span class="s3">))</span>

        <span class="s2"># Find the longest prefix that is shared by all paths.</span>
        <span class="s1">common_path </span><span class="s3">= </span><span class="s1">paths</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">paths</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]:</span>
            <span class="s1">path </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">path</span><span class="s3">[:</span><span class="s1">len</span><span class="s3">(</span><span class="s1">common_path</span><span class="s3">)])</span>
            <span class="s0">while </span><span class="s1">path</span><span class="s3">:</span>
                <span class="s0">if </span><span class="s1">common_path</span><span class="s3">[:</span><span class="s1">len</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)] == </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
                    <span class="s1">common_path </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
                    <span class="s0">break</span>

                <span class="s1">path</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>

        <span class="s1">root_nodeid </span><span class="s3">= </span><span class="s1">common_path</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">skeletons</span><span class="s3">[</span><span class="s1">root_nodeid</span><span class="s3">] = </span><span class="s1">skinid</span>

    <span class="s0">def </span><span class="s1">load_primitive</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">geom_node</span><span class="s3">, </span><span class="s1">gltf_primitive</span><span class="s3">, </span><span class="s1">gltf_mesh</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">):</span>
        <span class="s2"># Build Vertex Format</span>
        <span class="s1">vformat </span><span class="s3">= </span><span class="s1">GeomVertexFormat</span><span class="s3">()</span>
        <span class="s1">mesh_attribs </span><span class="s3">= </span><span class="s1">gltf_primitive</span><span class="s3">[</span><span class="s4">'attributes'</span><span class="s3">]</span>
        <span class="s1">accessors </span><span class="s3">= [</span>
            <span class="s3">{**</span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'accessors'</span><span class="s3">][</span><span class="s1">acc_idx</span><span class="s3">], </span><span class="s4">'_attrib'</span><span class="s3">: </span><span class="s1">attrib_name</span><span class="s3">}</span>
            <span class="s0">for </span><span class="s1">attrib_name</span><span class="s3">, </span><span class="s1">acc_idx </span><span class="s0">in </span><span class="s1">mesh_attribs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
        <span class="s3">]</span>

        <span class="s2"># Check for morph target columns.</span>
        <span class="s1">targets </span><span class="s3">= </span><span class="s1">gltf_primitive</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'targets'</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">targets</span><span class="s3">:</span>
            <span class="s1">target_names </span><span class="s3">= </span><span class="s1">get_extras</span><span class="s3">(</span><span class="s1">gltf_mesh</span><span class="s3">).</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'targetNames'</span><span class="s3">, [])</span>

            <span class="s0">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">target </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">targets</span><span class="s3">):</span>
                <span class="s0">if </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_names</span><span class="s3">):</span>
                    <span class="s1">target_name </span><span class="s3">= </span><span class="s1">target_names</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">target_name </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>

                <span class="s1">accessors </span><span class="s3">+= [</span>
                    <span class="s3">{**</span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'accessors'</span><span class="s3">][</span><span class="s1">acc_idx</span><span class="s3">], </span><span class="s4">'_attrib'</span><span class="s3">: </span><span class="s1">attrib_name</span><span class="s3">, </span><span class="s4">'_target'</span><span class="s3">: </span><span class="s1">target_name</span><span class="s3">}</span>
                    <span class="s0">for </span><span class="s1">attrib_name</span><span class="s3">, </span><span class="s1">acc_idx </span><span class="s0">in </span><span class="s1">target</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
                <span class="s3">]</span>

        <span class="s1">accessors </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">accessors</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s0">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">[</span><span class="s4">'bufferView'</span><span class="s3">])</span>
        <span class="s1">data_copies </span><span class="s3">= []</span>
        <span class="s1">is_skinned </span><span class="s3">= </span><span class="s4">'JOINTS_0' </span><span class="s0">in </span><span class="s1">mesh_attribs</span>
        <span class="s1">calc_normals </span><span class="s3">= </span><span class="s0">not </span><span class="s4">'NORMAL' </span><span class="s0">in </span><span class="s1">mesh_attribs</span>
        <span class="s1">calc_tangents </span><span class="s3">= </span><span class="s0">not </span><span class="s4">'TANGENT' </span><span class="s0">in </span><span class="s1">mesh_attribs</span>
        <span class="s1">normalize_weights </span><span class="s3">= </span><span class="s0">False</span>

        <span class="s0">for </span><span class="s1">buffview</span><span class="s3">, </span><span class="s1">accs </span><span class="s0">in </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">groupby</span><span class="s3">(</span><span class="s1">accessors</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s0">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">[</span><span class="s4">'bufferView'</span><span class="s3">]):</span>
            <span class="s1">buffview </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'bufferViews'</span><span class="s3">][</span><span class="s1">buffview</span><span class="s3">]</span>
            <span class="s1">accs </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">accs</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s0">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>
            <span class="s1">is_interleaved </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">accs</span><span class="s3">) &gt; </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">accs</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) &lt; </span><span class="s1">buffview</span><span class="s3">[</span><span class="s4">'byteStride'</span><span class="s3">]</span>

            <span class="s1">varray </span><span class="s3">= </span><span class="s1">GeomVertexArrayFormat</span><span class="s3">()</span>
            <span class="s0">for </span><span class="s1">acc </span><span class="s0">in </span><span class="s1">accs</span><span class="s3">:</span>
                <span class="s2"># Gather column information</span>
                <span class="s1">attrib_parts </span><span class="s3">= </span><span class="s1">acc</span><span class="s3">[</span><span class="s4">'_attrib'</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">().</span><span class="s1">split</span><span class="s3">(</span><span class="s4">'_'</span><span class="s3">)</span>
                <span class="s1">attrib_name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ATTRIB_NAME_MAP</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">attrib_parts</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">attrib_parts</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
                <span class="s0">if </span><span class="s1">attrib_name </span><span class="s3">== </span><span class="s4">'texcoord' </span><span class="s0">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">attrib_parts</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">:</span>
                    <span class="s1">internal_name </span><span class="s3">= </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">attrib_name</span><span class="s3">+</span><span class="s4">'.'</span><span class="s3">, </span><span class="s1">int</span><span class="s3">(</span><span class="s1">attrib_parts</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]))</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">internal_name </span><span class="s3">= </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">attrib_name</span><span class="s3">)</span>
                <span class="s1">num_components </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_COMPONENT_NUM_MAP</span><span class="s3">[</span><span class="s1">acc</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]]</span>
                <span class="s1">numeric_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_COMPONENT_TYPE_MAP</span><span class="s3">[</span><span class="s1">acc</span><span class="s3">[</span><span class="s4">'componentType'</span><span class="s3">]]</span>
                <span class="s1">numeric_size </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_COMPONENT_SIZE_MAP</span><span class="s3">[</span><span class="s1">acc</span><span class="s3">[</span><span class="s4">'componentType'</span><span class="s3">]]</span>
                <span class="s1">content </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ATTRIB_CONTENT_MAP</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">attrib_name</span><span class="s3">, </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_other</span><span class="s3">)</span>
                <span class="s1">size </span><span class="s3">= </span><span class="s1">numeric_size </span><span class="s3">* </span><span class="s1">num_components</span>

                <span class="s0">if </span><span class="s4">'_target' </span><span class="s0">in </span><span class="s1">acc</span><span class="s3">:</span>
                    <span class="s1">internal_name </span><span class="s3">= </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_morph</span><span class="s3">(</span><span class="s1">attrib_name</span><span class="s3">, </span><span class="s1">acc</span><span class="s3">[</span><span class="s4">'_target'</span><span class="s3">])</span>
                    <span class="s1">content </span><span class="s3">= </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_morph_delta</span>

                <span class="s2"># Add this accessor as a column to the current vertex array format</span>
                <span class="s1">varray</span><span class="s3">.</span><span class="s1">add_column</span><span class="s3">(</span><span class="s1">internal_name</span><span class="s3">, </span><span class="s1">num_components</span><span class="s3">, </span><span class="s1">numeric_type</span><span class="s3">, </span><span class="s1">content</span><span class="s3">)</span>

                <span class="s2"># Check if the weights table is using float or integer component</span>
                <span class="s2"># Weights normalization will only be performed on float weights.</span>
                <span class="s0">if </span><span class="s1">attrib_parts</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s4">'weights'</span><span class="s3">:</span>
                    <span class="s1">normalize_weights </span><span class="s3">= </span><span class="s1">numeric_type </span><span class="s3">== </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">NT_float32</span>

                <span class="s0">if not </span><span class="s1">is_interleaved</span><span class="s3">:</span>
                    <span class="s2"># Start a new vertex array format</span>
                    <span class="s1">vformat</span><span class="s3">.</span><span class="s1">add_array</span><span class="s3">(</span><span class="s1">varray</span><span class="s3">)</span>
                    <span class="s1">varray </span><span class="s3">= </span><span class="s1">GeomVertexArrayFormat</span><span class="s3">()</span>
                    <span class="s1">data_copies</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span>
                        <span class="s1">buffview</span><span class="s3">[</span><span class="s4">'buffer'</span><span class="s3">],</span>
                        <span class="s1">acc</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) + </span><span class="s1">buffview</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                        <span class="s1">acc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">],</span>
                        <span class="s1">size</span><span class="s3">,</span>
                        <span class="s1">buffview</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteStride'</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
                    <span class="s3">))</span>

            <span class="s0">if </span><span class="s1">is_interleaved</span><span class="s3">:</span>
                <span class="s1">vformat</span><span class="s3">.</span><span class="s1">add_array</span><span class="s3">(</span><span class="s1">varray</span><span class="s3">)</span>
                <span class="s1">stride </span><span class="s3">= </span><span class="s1">buffview</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteStride'</span><span class="s3">, </span><span class="s1">varray</span><span class="s3">.</span><span class="s1">get_stride</span><span class="s3">())</span>
                <span class="s1">data_copies</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span>
                    <span class="s1">buffview</span><span class="s3">[</span><span class="s4">'buffer'</span><span class="s3">],</span>
                    <span class="s1">buffview</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                    <span class="s1">accs</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s4">'count'</span><span class="s3">],</span>
                    <span class="s1">stride</span><span class="s3">,</span>
                    <span class="s1">stride</span><span class="s3">,</span>
                <span class="s3">))</span>

        <span class="s2"># Copy data from buffers</span>
        <span class="s1">reg_format </span><span class="s3">= </span><span class="s1">GeomVertexFormat</span><span class="s3">.</span><span class="s1">register_format</span><span class="s3">(</span><span class="s1">vformat</span><span class="s3">)</span>
        <span class="s1">vdata </span><span class="s3">= </span><span class="s1">GeomVertexData</span><span class="s3">(</span><span class="s1">geom_node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">reg_format</span><span class="s3">, </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">UH_stream</span><span class="s3">)</span>

        <span class="s0">for </span><span class="s1">array_idx</span><span class="s3">, </span><span class="s1">data_info </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">data_copies</span><span class="s3">):</span>
            <span class="s1">buffid</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">count</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">stride </span><span class="s3">= </span><span class="s1">data_info</span>

            <span class="s1">handle </span><span class="s3">= </span><span class="s1">vdata</span><span class="s3">.</span><span class="s1">modify_array</span><span class="s3">(</span><span class="s1">array_idx</span><span class="s3">).</span><span class="s1">modify_handle</span><span class="s3">()</span>
            <span class="s1">handle</span><span class="s3">.</span><span class="s1">unclean_set_num_rows</span><span class="s3">(</span><span class="s1">count</span><span class="s3">)</span>

            <span class="s1">buff </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffers</span><span class="s3">[</span><span class="s1">buffid</span><span class="s3">]</span>
            <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">count </span><span class="s3">* </span><span class="s1">stride</span>
            <span class="s0">if </span><span class="s1">stride </span><span class="s3">== </span><span class="s1">size</span><span class="s3">:</span>
                <span class="s1">handle</span><span class="s3">.</span><span class="s1">copy_data_from</span><span class="s3">(</span><span class="s1">buff</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">])</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">src </span><span class="s3">= </span><span class="s1">start</span>
                <span class="s1">dest </span><span class="s3">= </span><span class="s5">0</span>
                <span class="s0">while </span><span class="s1">src </span><span class="s3">&lt; </span><span class="s1">end</span><span class="s3">:</span>
                    <span class="s1">handle</span><span class="s3">.</span><span class="s1">copy_subdata_from</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">buff</span><span class="s3">[</span><span class="s1">src</span><span class="s3">:</span><span class="s1">src</span><span class="s3">+</span><span class="s1">size</span><span class="s3">])</span>
                    <span class="s1">dest </span><span class="s3">+= </span><span class="s1">size</span>
                    <span class="s1">src </span><span class="s3">+= </span><span class="s1">stride</span>
            <span class="s1">handle </span><span class="s3">= </span><span class="s0">None</span>

        <span class="s2"># Flip UVs</span>
        <span class="s1">num_uvs </span><span class="s3">= </span><span class="s1">len</span><span class="s3">({</span><span class="s1">i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">gltf_primitive</span><span class="s3">[</span><span class="s4">'attributes'</span><span class="s3">] </span><span class="s0">if </span><span class="s1">i</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'TEXCOORD'</span><span class="s3">)})</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">num_uvs</span><span class="s3">):</span>
            <span class="s1">uv_data </span><span class="s3">= </span><span class="s1">GeomVertexRewriter</span><span class="s3">(</span><span class="s1">vdata</span><span class="s3">, </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_texcoord_name</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)))</span>

            <span class="s0">while not </span><span class="s1">uv_data</span><span class="s3">.</span><span class="s1">is_at_end</span><span class="s3">():</span>
                <span class="s1">uvs </span><span class="s3">= </span><span class="s1">uv_data</span><span class="s3">.</span><span class="s1">get_data2f</span><span class="s3">()</span>
                <span class="s1">uv_data</span><span class="s3">.</span><span class="s1">set_data2f</span><span class="s3">(</span><span class="s1">uvs</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s5">1 </span><span class="s3">- </span><span class="s1">uvs</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compose_cs </span><span class="s3">== </span><span class="s1">CS_yup_right</span><span class="s3">:</span>
            <span class="s2"># Flip morph deltas from Y-up to Z-up.  This is apparently not done by</span>
            <span class="s2"># transform_vertices(), below, so we do it ourselves.</span>
            <span class="s0">for </span><span class="s1">morph_i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">reg_format</span><span class="s3">.</span><span class="s1">get_num_morphs</span><span class="s3">()):</span>
                <span class="s1">delta_data </span><span class="s3">= </span><span class="s1">GeomVertexRewriter</span><span class="s3">(</span><span class="s1">vdata</span><span class="s3">, </span><span class="s1">reg_format</span><span class="s3">.</span><span class="s1">get_morph_delta</span><span class="s3">(</span><span class="s1">morph_i</span><span class="s3">))</span>

                <span class="s0">while not </span><span class="s1">delta_data</span><span class="s3">.</span><span class="s1">is_at_end</span><span class="s3">():</span>
                    <span class="s1">data </span><span class="s3">= </span><span class="s1">delta_data</span><span class="s3">.</span><span class="s1">get_data3f</span><span class="s3">()</span>
                    <span class="s1">delta_data</span><span class="s3">.</span><span class="s1">set_data3f</span><span class="s3">(</span><span class="s1">data</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], -</span><span class="s1">data</span><span class="s3">[</span><span class="s5">2</span><span class="s3">], </span><span class="s1">data</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
            <span class="s2"># Flip tangents from Y-up to Z-up.</span>
            <span class="s0">if </span><span class="s4">'TANGENT' </span><span class="s0">in </span><span class="s1">mesh_attribs</span><span class="s3">:</span>
                <span class="s1">tangent </span><span class="s3">= </span><span class="s1">GeomVertexRewriter</span><span class="s3">(</span><span class="s1">vdata</span><span class="s3">, </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s4">'tangent'</span><span class="s3">))</span>
                <span class="s0">while not </span><span class="s1">tangent</span><span class="s3">.</span><span class="s1">is_at_end</span><span class="s3">():</span>
                    <span class="s1">data </span><span class="s3">= </span><span class="s1">tangent</span><span class="s3">.</span><span class="s1">get_data4f</span><span class="s3">()</span>
                    <span class="s1">tangent</span><span class="s3">.</span><span class="s1">set_data4f</span><span class="s3">(</span><span class="s1">data</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], -</span><span class="s1">data</span><span class="s3">[</span><span class="s5">2</span><span class="s3">], </span><span class="s1">data</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">data</span><span class="s3">[</span><span class="s5">3</span><span class="s3">])</span>

        <span class="s0">if </span><span class="s1">normalize_weights</span><span class="s3">:</span>
            <span class="s2"># The linear sum of all the joint weights must be as close as possible to 1, if the weights are</span>
            <span class="s2"># stored as float.</span>
            <span class="s2"># Some malformed assets do not respect this, hence we are normalizing them here.</span>
            <span class="s1">weights_data </span><span class="s3">= </span><span class="s1">GeomVertexRewriter</span><span class="s3">(</span><span class="s1">vdata</span><span class="s3">, </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_transform_weight</span><span class="s3">())</span>
            <span class="s0">while not </span><span class="s1">weights_data</span><span class="s3">.</span><span class="s1">is_at_end</span><span class="s3">():</span>
                <span class="s1">weights </span><span class="s3">= </span><span class="s1">weights_data</span><span class="s3">.</span><span class="s1">get_data4f</span><span class="s3">()</span>
                <span class="s1">max_weight </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) + </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) + </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) + </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">[</span><span class="s5">3</span><span class="s3">])</span>
                <span class="s0">if </span><span class="s1">max_weight </span><span class="s3">!= </span><span class="s5">0.0</span><span class="s3">:</span>
                    <span class="s1">weights </span><span class="s3">= </span><span class="s1">weights </span><span class="s3">/ </span><span class="s1">max_weight</span>
                <span class="s1">weights_data</span><span class="s3">.</span><span class="s1">set_data4f</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">)</span>

        <span class="s2"># Repack mesh data</span>
        <span class="s1">vformat </span><span class="s3">= </span><span class="s1">GeomVertexFormat</span><span class="s3">()</span>
        <span class="s1">varray_vert </span><span class="s3">= </span><span class="s1">GeomVertexArrayFormat</span><span class="s3">()</span>
        <span class="s1">varray_skin </span><span class="s3">= </span><span class="s1">GeomVertexArrayFormat</span><span class="s3">()</span>
        <span class="s1">varray_morph </span><span class="s3">= </span><span class="s1">GeomVertexArrayFormat</span><span class="s3">()</span>

        <span class="s1">skip_columns </span><span class="s3">= (</span>
            <span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_transform_index</span><span class="s3">(),</span>
            <span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_transform_weight</span><span class="s3">(),</span>
            <span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_transform_blend</span><span class="s3">()</span>
        <span class="s3">)</span>
        <span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">reg_format</span><span class="s3">.</span><span class="s1">get_arrays</span><span class="s3">():</span>
            <span class="s0">for </span><span class="s1">column </span><span class="s0">in </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">get_columns</span><span class="s3">():</span>
                <span class="s1">column_name </span><span class="s3">= </span><span class="s1">column</span><span class="s3">.</span><span class="s1">get_name</span><span class="s3">()</span>
                <span class="s0">if </span><span class="s1">column_name </span><span class="s0">in </span><span class="s1">skip_columns</span><span class="s3">:</span>
                    <span class="s1">varray </span><span class="s3">= </span><span class="s1">varray_skin</span>
                <span class="s0">elif </span><span class="s1">column_name</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">basename </span><span class="s3">== </span><span class="s4">&quot;morph&quot;</span><span class="s3">:</span>
                    <span class="s1">varray </span><span class="s3">= </span><span class="s1">varray_morph</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">varray </span><span class="s3">= </span><span class="s1">varray_vert</span>
                <span class="s1">varray</span><span class="s3">.</span><span class="s1">add_column</span><span class="s3">(</span>
                    <span class="s1">column_name</span><span class="s3">,</span>
                    <span class="s1">column</span><span class="s3">.</span><span class="s1">get_num_components</span><span class="s3">(),</span>
                    <span class="s1">column</span><span class="s3">.</span><span class="s1">get_numeric_type</span><span class="s3">(),</span>
                    <span class="s1">column</span><span class="s3">.</span><span class="s1">get_contents</span><span class="s3">()</span>
                <span class="s3">)</span>
        <span class="s1">vformat</span><span class="s3">.</span><span class="s1">add_array</span><span class="s3">(</span><span class="s1">varray_vert</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s1">is_skinned </span><span class="s0">or </span><span class="s1">targets</span><span class="s3">:</span>
            <span class="s1">aspec </span><span class="s3">= </span><span class="s1">GeomVertexAnimationSpec</span><span class="s3">()</span>
            <span class="s1">aspec</span><span class="s3">.</span><span class="s1">set_panda</span><span class="s3">()</span>
            <span class="s1">vformat</span><span class="s3">.</span><span class="s1">set_animation</span><span class="s3">(</span><span class="s1">aspec</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s1">is_skinned</span><span class="s3">:</span>
            <span class="s1">varray_blends </span><span class="s3">= </span><span class="s1">GeomVertexArrayFormat</span><span class="s3">()</span>
            <span class="s1">varray_blends</span><span class="s3">.</span><span class="s1">add_column</span><span class="s3">(</span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_transform_blend</span><span class="s3">(), </span><span class="s5">1</span><span class="s3">, </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">NT_uint16</span><span class="s3">, </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_index</span><span class="s3">)</span>

            <span class="s1">vformat</span><span class="s3">.</span><span class="s1">add_array</span><span class="s3">(</span><span class="s1">varray_blends</span><span class="s3">)</span>
            <span class="s1">vformat</span><span class="s3">.</span><span class="s1">add_array</span><span class="s3">(</span><span class="s1">varray_skin</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s1">targets</span><span class="s3">:</span>
            <span class="s1">vformat</span><span class="s3">.</span><span class="s1">add_array</span><span class="s3">(</span><span class="s1">varray_morph</span><span class="s3">)</span>

        <span class="s1">reg_format </span><span class="s3">= </span><span class="s1">GeomVertexFormat</span><span class="s3">.</span><span class="s1">register_format</span><span class="s3">(</span><span class="s1">vformat</span><span class="s3">)</span>
        <span class="s1">vdata </span><span class="s3">= </span><span class="s1">vdata</span><span class="s3">.</span><span class="s1">convert_to</span><span class="s3">(</span><span class="s1">reg_format</span><span class="s3">)</span>

        <span class="s2"># Construct primitive</span>
        <span class="s1">primitiveid </span><span class="s3">= </span><span class="s1">geom_node</span><span class="s3">.</span><span class="s1">get_num_geoms</span><span class="s3">()</span>
        <span class="s1">primitivemode </span><span class="s3">= </span><span class="s1">gltf_primitive</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'mode'</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)</span>
        <span class="s0">try</span><span class="s3">:</span>
            <span class="s1">prim </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_PRIMITIVE_MODE_MAP</span><span class="s3">[</span><span class="s1">primitivemode</span><span class="s3">](</span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">UH_static</span><span class="s3">)</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span>
                <span class="s4">&quot;Warning: primitive {} on mesh {} has an unsupported mode: {}&quot;</span>
                <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">primitiveid</span><span class="s3">, </span><span class="s1">geom_node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">primitivemode</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s4">'indices' </span><span class="s0">in </span><span class="s1">gltf_primitive</span><span class="s3">:</span>
            <span class="s1">index_acc </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'accessors'</span><span class="s3">][</span><span class="s1">gltf_primitive</span><span class="s3">[</span><span class="s4">'indices'</span><span class="s3">]]</span>
            <span class="s1">prim</span><span class="s3">.</span><span class="s1">set_index_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_COMPONENT_TYPE_MAP</span><span class="s3">[</span><span class="s1">index_acc</span><span class="s3">[</span><span class="s4">'componentType'</span><span class="s3">]])</span>

            <span class="s1">handle </span><span class="s3">= </span><span class="s1">prim</span><span class="s3">.</span><span class="s1">modify_vertices</span><span class="s3">(</span><span class="s1">index_acc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">]).</span><span class="s1">modify_handle</span><span class="s3">()</span>
            <span class="s1">handle</span><span class="s3">.</span><span class="s1">unclean_set_num_rows</span><span class="s3">(</span><span class="s1">index_acc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">])</span>

            <span class="s1">buffview </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'bufferViews'</span><span class="s3">][</span><span class="s1">index_acc</span><span class="s3">[</span><span class="s4">'bufferView'</span><span class="s3">]]</span>
            <span class="s1">buff </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffers</span><span class="s3">[</span><span class="s1">buffview</span><span class="s3">[</span><span class="s4">'buffer'</span><span class="s3">]]</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">buffview</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) + </span><span class="s1">index_acc</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
            <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">index_acc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">] * </span><span class="s1">buffview</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteStride'</span><span class="s3">, </span><span class="s5">1</span><span class="s3">) * </span><span class="s1">prim</span><span class="s3">.</span><span class="s1">index_stride</span>
            <span class="s1">handle</span><span class="s3">.</span><span class="s1">copy_data_from</span><span class="s3">(</span><span class="s1">buff</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">])</span>
            <span class="s1">handle </span><span class="s3">= </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">index_acc </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'accessors'</span><span class="s3">][</span><span class="s1">gltf_primitive</span><span class="s3">[</span><span class="s4">'attributes'</span><span class="s3">][</span><span class="s4">&quot;POSITION&quot;</span><span class="s3">]]</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">index_acc</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
            <span class="s1">prim</span><span class="s3">.</span><span class="s1">setNonindexedVertices</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">index_acc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">])</span>

        <span class="s2"># Assign a material</span>
        <span class="s1">matid </span><span class="s3">= </span><span class="s1">gltf_primitive</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'material'</span><span class="s3">, </span><span class="s0">None</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">matid </span><span class="s0">is None</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span>
                <span class="s4">&quot;Warning: mesh {} has a primitive with no material, using an empty RenderState&quot;</span>
                <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">geom_node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">pmat </span><span class="s3">= </span><span class="s1">Material</span><span class="s3">(</span><span class="s4">'fallback material'</span><span class="s3">)</span>
            <span class="s1">matattrib </span><span class="s3">= </span><span class="s1">MaterialAttrib</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">pmat</span><span class="s3">)</span>
            <span class="s1">texattrib </span><span class="s3">= </span><span class="s1">TextureAttrib</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'__pbr-fallback'</span><span class="s3">))</span>
            <span class="s1">mat </span><span class="s3">= </span><span class="s1">RenderState</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">matattrib</span><span class="s3">, </span><span class="s1">texattrib</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">matid </span><span class="s0">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mat_states</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span>
                <span class="s4">&quot;Warning: material with name {} has no associated mat state, using an empty RenderState&quot;</span>
                <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">matid</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">pmat </span><span class="s3">= </span><span class="s1">Material</span><span class="s3">(</span><span class="s4">'fallback material'</span><span class="s3">)</span>
            <span class="s1">matattrib </span><span class="s3">= </span><span class="s1">MaterialAttrib</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">pmat</span><span class="s3">)</span>
            <span class="s1">texattrib </span><span class="s3">= </span><span class="s1">TextureAttrib</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">textures</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'__pbr-fallback'</span><span class="s3">))</span>
            <span class="s1">mat </span><span class="s3">= </span><span class="s1">RenderState</span><span class="s3">.</span><span class="s1">make</span><span class="s3">(</span><span class="s1">matattrib</span><span class="s3">, </span><span class="s1">texattrib</span><span class="s3">)</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">mat </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mat_states</span><span class="s3">[</span><span class="s1">gltf_primitive</span><span class="s3">[</span><span class="s4">'material'</span><span class="s3">]]</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">mat_mesh_map</span><span class="s3">[</span><span class="s1">gltf_primitive</span><span class="s3">[</span><span class="s4">'material'</span><span class="s3">]].</span><span class="s1">append</span><span class="s3">((</span><span class="s1">geom_node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">primitiveid</span><span class="s3">))</span>

        <span class="s2"># Add this primitive back to the geom node</span>
        <span class="s2">#ss = StringStream()</span>
        <span class="s2">#vdata.write(ss)</span>
        <span class="s2">###prim.write(ss, 2)</span>
        <span class="s2">#print(ss.data.decode('utf8'))</span>
        <span class="s1">geom </span><span class="s3">= </span><span class="s1">Geom</span><span class="s3">(</span><span class="s1">vdata</span><span class="s3">)</span>
        <span class="s1">geom</span><span class="s3">.</span><span class="s1">add_primitive</span><span class="s3">(</span><span class="s1">prim</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">calc_normals</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">calculate_normals</span><span class="s3">(</span><span class="s1">geom</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">calc_tangents</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">calculate_tangents</span><span class="s3">(</span><span class="s1">geom</span><span class="s3">)</span>
        <span class="s1">geom</span><span class="s3">.</span><span class="s1">transform_vertices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">csxform</span><span class="s3">)</span>
        <span class="s1">geom_node</span><span class="s3">.</span><span class="s1">add_geom</span><span class="s3">(</span><span class="s1">geom</span><span class="s3">, </span><span class="s1">mat</span><span class="s3">)</span>

    <span class="s0">def </span><span class="s1">calculate_normals</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">geom</span><span class="s3">):</span>
        <span class="s2"># Generate flat normals, as required by the glTF spec.</span>
        <span class="s0">if </span><span class="s1">geom</span><span class="s3">.</span><span class="s1">get_primitive_type</span><span class="s3">() != </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">PT_polygons</span><span class="s3">:</span>
            <span class="s0">return</span>

        <span class="s2"># We need to deindex the primitive since each occurrence of a vertex on</span>
        <span class="s2"># a triangle could have a different normal vector.</span>
        <span class="s1">geom</span><span class="s3">.</span><span class="s1">decompose_in_place</span><span class="s3">()</span>
        <span class="s1">geom</span><span class="s3">.</span><span class="s1">make_nonindexed</span><span class="s3">(</span><span class="s0">False</span><span class="s3">)</span>

        <span class="s1">gvd </span><span class="s3">= </span><span class="s1">geom</span><span class="s3">.</span><span class="s1">get_vertex_data</span><span class="s3">()</span>
        <span class="s1">gvd </span><span class="s3">= </span><span class="s1">gvd</span><span class="s3">.</span><span class="s1">replace_column</span><span class="s3">(</span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_normal</span><span class="s3">(), </span><span class="s5">3</span><span class="s3">, </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">NT_float32</span><span class="s3">, </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_normal</span><span class="s3">)</span>
        <span class="s1">vertex_reader </span><span class="s3">= </span><span class="s1">GeomVertexReader</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">, </span><span class="s4">'vertex'</span><span class="s3">)</span>
        <span class="s1">normal_writer </span><span class="s3">= </span><span class="s1">GeomVertexWriter</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">, </span><span class="s4">'normal'</span><span class="s3">)</span>

        <span class="s1">read_vertex </span><span class="s3">= </span><span class="s1">vertex_reader</span><span class="s3">.</span><span class="s1">get_data3</span>
        <span class="s1">write_normal </span><span class="s3">= </span><span class="s1">normal_writer</span><span class="s3">.</span><span class="s1">set_data3</span>

        <span class="s0">while not </span><span class="s1">vertex_reader</span><span class="s3">.</span><span class="s1">is_at_end</span><span class="s3">():</span>
            <span class="s1">vtx1 </span><span class="s3">= </span><span class="s1">read_vertex</span><span class="s3">()</span>
            <span class="s1">vtx2 </span><span class="s3">= </span><span class="s1">read_vertex</span><span class="s3">()</span>
            <span class="s1">vtx3 </span><span class="s3">= </span><span class="s1">read_vertex</span><span class="s3">()</span>
            <span class="s1">normal </span><span class="s3">= (</span><span class="s1">vtx2 </span><span class="s3">- </span><span class="s1">vtx1</span><span class="s3">).</span><span class="s1">cross</span><span class="s3">(</span><span class="s1">vtx3 </span><span class="s3">- </span><span class="s1">vtx1</span><span class="s3">)</span>
            <span class="s1">normal</span><span class="s3">.</span><span class="s1">normalize</span><span class="s3">()</span>
            <span class="s1">write_normal</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">)</span>
            <span class="s1">write_normal</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">)</span>
            <span class="s1">write_normal</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">)</span>

        <span class="s1">geom</span><span class="s3">.</span><span class="s1">set_vertex_data</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">)</span>

    <span class="s0">def </span><span class="s1">calculate_tangents</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">geom</span><span class="s3">):</span>
        <span class="s2"># Adapted from https://www.marti.works/calculating-tangents-for-your-mesh/</span>
        <span class="s1">prim </span><span class="s3">= </span><span class="s1">geom</span><span class="s3">.</span><span class="s1">get_primitive</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">gvd </span><span class="s3">= </span><span class="s1">geom</span><span class="s3">.</span><span class="s1">get_vertex_data</span><span class="s3">()</span>
        <span class="s1">gvd </span><span class="s3">= </span><span class="s1">gvd</span><span class="s3">.</span><span class="s1">replace_column</span><span class="s3">(</span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_tangent</span><span class="s3">(), </span><span class="s5">4</span><span class="s3">, </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">NT_float32</span><span class="s3">, </span><span class="s1">GeomEnums</span><span class="s3">.</span><span class="s1">C_other</span><span class="s3">)</span>
        <span class="s1">tangent_writer </span><span class="s3">= </span><span class="s1">GeomVertexWriter</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">, </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_tangent</span><span class="s3">())</span>

        <span class="s1">primverts </span><span class="s3">= </span><span class="s1">prim</span><span class="s3">.</span><span class="s1">get_vertex_list</span><span class="s3">()</span>
        <span class="s1">tris </span><span class="s3">= [</span><span class="s1">primverts</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:</span><span class="s1">i</span><span class="s3">+</span><span class="s5">3</span><span class="s3">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">primverts</span><span class="s3">), </span><span class="s5">3</span><span class="s3">)]</span>
        <span class="s1">posdata </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">read_vert_data</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">, </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_vertex</span><span class="s3">())</span>
        <span class="s1">normaldata </span><span class="s3">= [</span><span class="s1">LVector3</span><span class="s3">(</span><span class="s1">i</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">i</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">i</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">read_vert_data</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">, </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_normal</span><span class="s3">())]</span>
        <span class="s1">uvdata </span><span class="s3">= [</span><span class="s1">LVector2</span><span class="s3">(</span><span class="s1">i</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">i</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">read_vert_data</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">, </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_texcoord_name</span><span class="s3">(</span><span class="s4">'0'</span><span class="s3">))]</span>
        <span class="s1">tana </span><span class="s3">= [</span><span class="s1">LVector3</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">posdata</span><span class="s3">))]</span>
        <span class="s1">tanb </span><span class="s3">= [</span><span class="s1">LVector3</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">posdata</span><span class="s3">))]</span>

        <span class="s0">if not </span><span class="s1">uvdata</span><span class="s3">:</span>
            <span class="s2"># No point generating tangents without UVs.</span>
            <span class="s0">return</span>

        <span class="s2"># Gather tangent data from triangles</span>
        <span class="s0">for </span><span class="s1">tri </span><span class="s0">in </span><span class="s1">tris</span><span class="s3">:</span>
            <span class="s1">idx0</span><span class="s3">, </span><span class="s1">idx1</span><span class="s3">, </span><span class="s1">idx2 </span><span class="s3">= </span><span class="s1">tri</span>
            <span class="s1">edge1 </span><span class="s3">= </span><span class="s1">posdata</span><span class="s3">[</span><span class="s1">idx1</span><span class="s3">] - </span><span class="s1">posdata</span><span class="s3">[</span><span class="s1">idx0</span><span class="s3">]</span>
            <span class="s1">edge2 </span><span class="s3">= </span><span class="s1">posdata</span><span class="s3">[</span><span class="s1">idx2</span><span class="s3">] - </span><span class="s1">posdata</span><span class="s3">[</span><span class="s1">idx0</span><span class="s3">]</span>
            <span class="s1">duv1 </span><span class="s3">= </span><span class="s1">uvdata</span><span class="s3">[</span><span class="s1">idx1</span><span class="s3">] - </span><span class="s1">uvdata</span><span class="s3">[</span><span class="s1">idx0</span><span class="s3">]</span>
            <span class="s1">duv2 </span><span class="s3">= </span><span class="s1">uvdata</span><span class="s3">[</span><span class="s1">idx2</span><span class="s3">] - </span><span class="s1">uvdata</span><span class="s3">[</span><span class="s1">idx0</span><span class="s3">]</span>

            <span class="s1">denom </span><span class="s3">= </span><span class="s1">duv1</span><span class="s3">.</span><span class="s1">x </span><span class="s3">* </span><span class="s1">duv2</span><span class="s3">.</span><span class="s1">y </span><span class="s3">- </span><span class="s1">duv2</span><span class="s3">.</span><span class="s1">x </span><span class="s3">* </span><span class="s1">duv1</span><span class="s3">.</span><span class="s1">y</span>
            <span class="s0">if </span><span class="s1">denom </span><span class="s3">!= </span><span class="s5">0.0</span><span class="s3">:</span>
                <span class="s1">fconst </span><span class="s3">= </span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">denom</span>
                <span class="s1">tangent </span><span class="s3">= (</span><span class="s1">edge1</span><span class="s3">.</span><span class="s1">xyz </span><span class="s3">* </span><span class="s1">duv2</span><span class="s3">.</span><span class="s1">y </span><span class="s3">- </span><span class="s1">edge2</span><span class="s3">.</span><span class="s1">xyz </span><span class="s3">* </span><span class="s1">duv1</span><span class="s3">.</span><span class="s1">y</span><span class="s3">) * </span><span class="s1">fconst</span>
                <span class="s1">bitangent </span><span class="s3">= (</span><span class="s1">edge2</span><span class="s3">.</span><span class="s1">xyz </span><span class="s3">* </span><span class="s1">duv1</span><span class="s3">.</span><span class="s1">x </span><span class="s3">- </span><span class="s1">edge1</span><span class="s3">.</span><span class="s1">xyz </span><span class="s3">* </span><span class="s1">duv2</span><span class="s3">.</span><span class="s1">x</span><span class="s3">) * </span><span class="s1">fconst</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">tangent </span><span class="s3">= </span><span class="s1">LVector3</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
                <span class="s1">bitangent </span><span class="s3">= </span><span class="s1">LVector3</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>

            <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">tri</span><span class="s3">:</span>
                <span class="s1">tana</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] += </span><span class="s1">tangent</span>
                <span class="s1">tanb</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] += </span><span class="s1">bitangent</span>

        <span class="s2"># Calculate per-vertex tangent values</span>
        <span class="s0">for </span><span class="s1">normal</span><span class="s3">, </span><span class="s1">tan0</span><span class="s3">, </span><span class="s1">tan1 </span><span class="s0">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">normaldata</span><span class="s3">, </span><span class="s1">tana</span><span class="s3">, </span><span class="s1">tanb</span><span class="s3">):</span>
            <span class="s1">tangent </span><span class="s3">= </span><span class="s1">tan0 </span><span class="s3">- (</span><span class="s1">normal </span><span class="s3">* </span><span class="s1">normal</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">tan0</span><span class="s3">))</span>
            <span class="s1">tangent</span><span class="s3">.</span><span class="s1">normalize</span><span class="s3">()</span>

            <span class="s1">tangent4 </span><span class="s3">= </span><span class="s1">LVector4</span><span class="s3">(</span>
                <span class="s1">tangent</span><span class="s3">.</span><span class="s1">x</span><span class="s3">,</span>
                <span class="s1">tangent</span><span class="s3">.</span><span class="s1">y</span><span class="s3">,</span>
                <span class="s1">tangent</span><span class="s3">.</span><span class="s1">z</span><span class="s3">,</span>
                <span class="s3">-</span><span class="s5">1.0 </span><span class="s0">if </span><span class="s1">normal</span><span class="s3">.</span><span class="s1">cross</span><span class="s3">(</span><span class="s1">tan0</span><span class="s3">).</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">tan1</span><span class="s3">) &lt; </span><span class="s5">0 </span><span class="s0">else </span><span class="s5">1.0</span>
            <span class="s3">)</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compose_cs </span><span class="s3">== </span><span class="s1">CS_yup_right</span><span class="s3">:</span>
                <span class="s1">tangent_writer</span><span class="s3">.</span><span class="s1">set_data4</span><span class="s3">(</span><span class="s1">tangent4</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], -</span><span class="s1">tangent4</span><span class="s3">[</span><span class="s5">2</span><span class="s3">], </span><span class="s1">tangent4</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">tangent4</span><span class="s3">[</span><span class="s5">3</span><span class="s3">])</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">tangent_writer</span><span class="s3">.</span><span class="s1">set_data4</span><span class="s3">(</span><span class="s1">tangent4</span><span class="s3">)</span>

        <span class="s1">geom</span><span class="s3">.</span><span class="s1">set_vertex_data</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">)</span>

    <span class="s0">def </span><span class="s1">load_mesh</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">meshid</span><span class="s3">, </span><span class="s1">gltf_mesh</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">):</span>
        <span class="s1">mesh_name </span><span class="s3">= </span><span class="s1">gltf_mesh</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'mesh'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">meshid</span><span class="s3">))</span>
        <span class="s1">node </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">meshes</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">meshid</span><span class="s3">, </span><span class="s1">GeomNode</span><span class="s3">(</span><span class="s1">mesh_name</span><span class="s3">))</span>

        <span class="s2"># Clear any existing mesh data</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">remove_all_geoms</span><span class="s3">()</span>

        <span class="s2"># Load primitives</span>
        <span class="s0">for </span><span class="s1">gltf_primitive </span><span class="s0">in </span><span class="s1">gltf_mesh</span><span class="s3">[</span><span class="s4">'primitives'</span><span class="s3">]:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">load_primitive</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">gltf_primitive</span><span class="s3">, </span><span class="s1">gltf_mesh</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">)</span>

        <span class="s2"># Save mesh</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">meshes</span><span class="s3">[</span><span class="s1">meshid</span><span class="s3">] = </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">read_vert_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">gvd</span><span class="s3">, </span><span class="s1">column_name</span><span class="s3">):</span>
        <span class="s1">gvr </span><span class="s3">= </span><span class="s1">GeomVertexReader</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">, </span><span class="s1">column_name</span><span class="s3">)</span>
        <span class="s1">data </span><span class="s3">= []</span>
        <span class="s0">while not </span><span class="s1">gvr</span><span class="s3">.</span><span class="s1">is_at_end</span><span class="s3">():</span>
            <span class="s1">data</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">LVecBase4</span><span class="s3">(</span><span class="s1">gvr</span><span class="s3">.</span><span class="s1">get_data4</span><span class="s3">()))</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s0">def </span><span class="s1">build_character</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">charinfo</span><span class="s3">: </span><span class="s1">CharInfo</span><span class="s3">, </span><span class="s1">nodeid</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">, </span><span class="s1">recurse</span><span class="s3">=</span><span class="s0">True</span><span class="s3">):</span>
        <span class="s1">char </span><span class="s3">= </span><span class="s1">charinfo</span><span class="s3">.</span><span class="s1">character</span>
        <span class="s1">affected_nodeids </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s1">jvtmap </span><span class="s3">= </span><span class="s1">charinfo</span><span class="s3">.</span><span class="s1">jvtmap</span>
        <span class="s1">cvsmap </span><span class="s3">= </span><span class="s1">charinfo</span><span class="s3">.</span><span class="s1">cvsmap</span>

        <span class="s0">for </span><span class="s1">bundle </span><span class="s0">in </span><span class="s1">char</span><span class="s3">.</span><span class="s1">bundles</span><span class="s3">:</span>
            <span class="s1">bundle</span><span class="s3">.</span><span class="s1">frame_blend_flag </span><span class="s3">= </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">skeletons</span><span class="s3">:</span>
            <span class="s1">skinid </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">skeletons</span><span class="s3">[</span><span class="s1">nodeid</span><span class="s3">]</span>
            <span class="s1">gltf_skin </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'skins'</span><span class="s3">][</span><span class="s1">skinid</span><span class="s3">]</span>

            <span class="s0">if </span><span class="s4">'skeleton' </span><span class="s0">in </span><span class="s1">gltf_skin</span><span class="s3">:</span>
                <span class="s1">root_nodeids </span><span class="s3">= [</span><span class="s1">gltf_skin</span><span class="s3">[</span><span class="s4">'skeleton'</span><span class="s3">]]</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s2"># find a common root node</span>
                <span class="s1">joint_nodes </span><span class="s3">= [</span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">][</span><span class="s1">i</span><span class="s3">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">gltf_skin</span><span class="s3">[</span><span class="s4">'joints'</span><span class="s3">]]</span>
                <span class="s1">child_set </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">chain</span><span class="s3">(*[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'children'</span><span class="s3">, []) </span><span class="s0">for </span><span class="s1">node </span><span class="s0">in </span><span class="s1">joint_nodes</span><span class="s3">]))</span>
                <span class="s1">root_nodeids </span><span class="s3">= [</span><span class="s1">nodeid </span><span class="s0">for </span><span class="s1">nodeid </span><span class="s0">in </span><span class="s1">gltf_skin</span><span class="s3">[</span><span class="s4">'joints'</span><span class="s3">] </span><span class="s0">if </span><span class="s1">nodeid </span><span class="s0">not in </span><span class="s1">child_set</span><span class="s3">]</span>

            <span class="s1">jvtmap</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">build_character_joints</span><span class="s3">(</span><span class="s1">char</span><span class="s3">, </span><span class="s1">root_nodeids</span><span class="s3">,</span>
                                                      <span class="s1">affected_nodeids</span><span class="s3">, </span><span class="s1">skinid</span><span class="s3">,</span>
                                                      <span class="s1">gltf_data</span><span class="s3">))</span>

        <span class="s1">cvsmap</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">build_character_sliders</span><span class="s3">(</span><span class="s1">char</span><span class="s3">, </span><span class="s1">nodeid</span><span class="s3">, </span><span class="s1">affected_nodeids</span><span class="s3">,</span>
                                                   <span class="s1">gltf_data</span><span class="s3">, </span><span class="s1">recurse</span><span class="s3">=</span><span class="s1">recurse</span><span class="s3">))</span>

        <span class="s2"># Find animations that affect the collected nodes.</span>
        <span class="s2">#print(&quot;Looking for actions for&quot;, skinname, node_ids)</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">skip_animations</span><span class="s3">:</span>
            <span class="s1">anims </span><span class="s3">= [</span>
                <span class="s3">(</span><span class="s1">animid</span><span class="s3">, </span><span class="s1">anim</span><span class="s3">)</span>
                <span class="s0">for </span><span class="s1">animid</span><span class="s3">, </span><span class="s1">anim </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">gltf_data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'animations'</span><span class="s3">, []))</span>
                <span class="s0">if </span><span class="s1">affected_nodeids </span><span class="s3">&amp; {</span><span class="s1">chan</span><span class="s3">[</span><span class="s4">'target'</span><span class="s3">][</span><span class="s4">'node'</span><span class="s3">] </span><span class="s0">for </span><span class="s1">chan </span><span class="s0">in </span><span class="s1">anim</span><span class="s3">[</span><span class="s4">'channels'</span><span class="s3">]}</span>
            <span class="s3">]</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">anims </span><span class="s3">= []</span>

        <span class="s0">for </span><span class="s1">animid</span><span class="s3">, </span><span class="s1">gltf_anim </span><span class="s0">in </span><span class="s1">anims</span><span class="s3">:</span>
            <span class="s1">anim_name </span><span class="s3">= </span><span class="s1">gltf_anim</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'anim'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">animid</span><span class="s3">))</span>
            <span class="s2">#print(&quot;\t&quot;, anim_name)</span>

            <span class="s1">samplers </span><span class="s3">= </span><span class="s1">gltf_anim</span><span class="s3">[</span><span class="s4">'samplers'</span><span class="s3">]</span>
            <span class="s1">channels </span><span class="s3">= </span><span class="s1">gltf_anim</span><span class="s3">[</span><span class="s4">'channels'</span><span class="s3">]</span>

            <span class="s2"># Blender exports the same number of elements in each time parameter, so find</span>
            <span class="s2"># one and assume that the number of elements is the number of frames</span>
            <span class="s1">time_acc_id </span><span class="s3">= </span><span class="s1">samplers</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s4">'input'</span><span class="s3">]</span>
            <span class="s1">time_acc </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'accessors'</span><span class="s3">][</span><span class="s1">time_acc_id</span><span class="s3">]</span>
            <span class="s1">time_bv </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'bufferViews'</span><span class="s3">][</span><span class="s1">time_acc</span><span class="s3">[</span><span class="s4">'bufferView'</span><span class="s3">]]</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">time_acc</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) + </span><span class="s1">time_bv</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
            <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">time_acc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">] * </span><span class="s5">4</span>
            <span class="s1">time_data </span><span class="s3">= [</span>
                <span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s4">'&lt;f'</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffers</span><span class="s3">[</span><span class="s1">time_bv</span><span class="s3">[</span><span class="s4">'buffer'</span><span class="s3">]], </span><span class="s1">idx</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)</span>
            <span class="s3">]</span>
            <span class="s1">num_frames </span><span class="s3">= </span><span class="s1">time_acc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">]</span>
            <span class="s1">end_time </span><span class="s3">= </span><span class="s1">time_data</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">fps </span><span class="s3">= </span><span class="s1">num_frames </span><span class="s3">/ </span><span class="s1">time_data</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] </span><span class="s0">if </span><span class="s1">end_time </span><span class="s3">!= </span><span class="s5">0 </span><span class="s0">else </span><span class="s5">24</span>

            <span class="s1">bundle_name </span><span class="s3">= </span><span class="s1">anim_name</span>
            <span class="s1">bundle </span><span class="s3">= </span><span class="s1">AnimBundle</span><span class="s3">(</span><span class="s1">bundle_name</span><span class="s3">, </span><span class="s1">fps</span><span class="s3">, </span><span class="s1">num_frames</span><span class="s3">)</span>

            <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">skeletons </span><span class="s0">and </span><span class="s1">any</span><span class="s3">(</span><span class="s1">chan</span><span class="s3">[</span><span class="s4">'target'</span><span class="s3">][</span><span class="s4">'path'</span><span class="s3">] != </span><span class="s4">'weights' </span><span class="s0">for </span><span class="s1">chan </span><span class="s0">in </span><span class="s1">channels</span><span class="s3">):</span>
                <span class="s1">skeleton </span><span class="s3">= </span><span class="s1">AnimGroup</span><span class="s3">(</span><span class="s1">bundle</span><span class="s3">, </span><span class="s4">'&lt;skeleton&gt;'</span><span class="s3">)</span>
                <span class="s0">for </span><span class="s1">root_nodeid </span><span class="s0">in </span><span class="s1">root_nodeids</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">build_animation_skeleton</span><span class="s3">(</span><span class="s1">char</span><span class="s3">, </span><span class="s1">skeleton</span><span class="s3">, </span><span class="s1">root_nodeid</span><span class="s3">,</span>
                                                  <span class="s1">num_frames</span><span class="s3">, </span><span class="s1">gltf_anim</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">)</span>

            <span class="s0">if </span><span class="s1">cvsmap </span><span class="s0">and </span><span class="s1">any</span><span class="s3">(</span><span class="s1">chan</span><span class="s3">[</span><span class="s4">'target'</span><span class="s3">][</span><span class="s4">'path'</span><span class="s3">] == </span><span class="s4">'weights' </span><span class="s0">for </span><span class="s1">chan </span><span class="s0">in </span><span class="s1">channels</span><span class="s3">):</span>
                <span class="s1">morph </span><span class="s3">= </span><span class="s1">AnimGroup</span><span class="s3">(</span><span class="s1">bundle</span><span class="s3">, </span><span class="s4">'morph'</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">build_animation_morph</span><span class="s3">(</span><span class="s1">morph</span><span class="s3">, </span><span class="s1">nodeid</span><span class="s3">, </span><span class="s1">num_frames</span><span class="s3">, </span><span class="s1">gltf_anim</span><span class="s3">,</span>
                                           <span class="s1">gltf_data</span><span class="s3">, </span><span class="s1">recurse</span><span class="s3">=</span><span class="s1">recurse</span><span class="s3">)</span>

            <span class="s1">char</span><span class="s3">.</span><span class="s1">add_child</span><span class="s3">(</span><span class="s1">AnimBundleNode</span><span class="s3">(</span><span class="s1">char</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">bundle</span><span class="s3">))</span>

    <span class="s0">def </span><span class="s1">combine_mesh_skin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">geom_node</span><span class="s3">, </span><span class="s1">charinfo</span><span class="s3">):</span>
        <span class="s1">jvtmap </span><span class="s3">= </span><span class="s1">charinfo</span><span class="s3">.</span><span class="s1">jvtmap</span>
        <span class="s0">if not </span><span class="s1">jvtmap</span><span class="s3">:</span>
            <span class="s0">return</span>
        <span class="s1">jvtmap </span><span class="s3">= </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">OrderedDict</span><span class="s3">(</span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">jvtmap</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()))</span>

        <span class="s0">for </span><span class="s1">geom </span><span class="s0">in </span><span class="s1">geom_node</span><span class="s3">.</span><span class="s1">modify_geoms</span><span class="s3">():</span>
            <span class="s1">gvd </span><span class="s3">= </span><span class="s1">geom</span><span class="s3">.</span><span class="s1">modify_vertex_data</span><span class="s3">()</span>
            <span class="s1">tbtable </span><span class="s3">= </span><span class="s1">TransformBlendTable</span><span class="s3">()</span>
            <span class="s1">tdata </span><span class="s3">= </span><span class="s1">GeomVertexWriter</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">, </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_transform_blend</span><span class="s3">())</span>

            <span class="s0">if not </span><span class="s1">tdata</span><span class="s3">.</span><span class="s1">has_column</span><span class="s3">():</span>
                <span class="s0">continue</span>

            <span class="s1">jointdata </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">read_vert_data</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">, </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_transform_index</span><span class="s3">())</span>
            <span class="s1">weightdata </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">read_vert_data</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">, </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_transform_weight</span><span class="s3">())</span>

            <span class="s0">for </span><span class="s1">joints</span><span class="s3">, </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">jointdata</span><span class="s3">, </span><span class="s1">weightdata</span><span class="s3">):</span>
                <span class="s1">tblend </span><span class="s3">= </span><span class="s1">TransformBlend</span><span class="s3">()</span>
                <span class="s0">for </span><span class="s1">joint</span><span class="s3">, </span><span class="s1">weight </span><span class="s0">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">joints</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">):</span>
                    <span class="s1">joint </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">joint</span><span class="s3">)</span>
                    <span class="s0">try</span><span class="s3">:</span>
                        <span class="s1">jvt </span><span class="s3">= </span><span class="s1">jvtmap</span><span class="s3">[</span><span class="s1">joint</span><span class="s3">]</span>
                    <span class="s0">except </span><span class="s1">KeyError</span><span class="s3">:</span>
                        <span class="s1">print</span><span class="s3">(</span>
                            <span class="s4">&quot;Could not find joint in jvtmap:</span><span class="s0">\n\t</span><span class="s4">joint={}</span><span class="s0">\n\t</span><span class="s4">jvtmap={}&quot;</span>
                            <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">joint</span><span class="s3">, </span><span class="s1">jvtmap</span><span class="s3">)</span>
                        <span class="s3">)</span>
                        <span class="s2"># Don't warn again for this joint.</span>
                        <span class="s1">jvt </span><span class="s3">= </span><span class="s0">None</span>
                        <span class="s1">jvtmap</span><span class="s3">[</span><span class="s1">joint</span><span class="s3">] = </span><span class="s0">None</span>
                    <span class="s0">if </span><span class="s1">jvt </span><span class="s0">is not None</span><span class="s3">:</span>
                        <span class="s1">tblend</span><span class="s3">.</span><span class="s1">add_transform</span><span class="s3">(</span><span class="s1">jvt</span><span class="s3">, </span><span class="s1">weight</span><span class="s3">)</span>
                <span class="s1">tdata</span><span class="s3">.</span><span class="s1">add_data1i</span><span class="s3">(</span><span class="s1">tbtable</span><span class="s3">.</span><span class="s1">add_blend</span><span class="s3">(</span><span class="s1">tblend</span><span class="s3">))</span>
            <span class="s1">tbtable</span><span class="s3">.</span><span class="s1">set_rows</span><span class="s3">(</span><span class="s1">SparseArray</span><span class="s3">.</span><span class="s1">lower_on</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">.</span><span class="s1">get_num_rows</span><span class="s3">()))</span>
            <span class="s1">gvd</span><span class="s3">.</span><span class="s1">set_transform_blend_table</span><span class="s3">(</span><span class="s1">tbtable</span><span class="s3">)</span>

            <span class="s2"># Set the transform of the skinned node to the inverse of the parent's</span>
            <span class="s2"># transform.  This allows skinning to happen in global space.</span>
            <span class="s1">net_xform </span><span class="s3">= </span><span class="s1">NodePath</span><span class="s3">(</span><span class="s1">geom_node</span><span class="s3">.</span><span class="s1">get_parent</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)).</span><span class="s1">get_net_transform</span><span class="s3">()</span>
            <span class="s1">inverse </span><span class="s3">= </span><span class="s1">net_xform</span><span class="s3">.</span><span class="s1">get_inverse</span><span class="s3">()</span>
            <span class="s1">gvd</span><span class="s3">.</span><span class="s1">transform_vertices</span><span class="s3">(</span><span class="s1">inverse</span><span class="s3">.</span><span class="s1">get_mat</span><span class="s3">())</span>

    <span class="s0">def </span><span class="s1">combine_mesh_morphs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">geom_node</span><span class="s3">, </span><span class="s1">meshid</span><span class="s3">, </span><span class="s1">charinfo</span><span class="s3">):</span>
        <span class="s1">cvsmap </span><span class="s3">= </span><span class="s1">charinfo</span><span class="s3">.</span><span class="s1">cvsmap</span>
        <span class="s0">if not </span><span class="s1">cvsmap</span><span class="s3">:</span>
            <span class="s0">return</span>
        <span class="s1">zero </span><span class="s3">= </span><span class="s1">LVecBase4</span><span class="s3">.</span><span class="s1">zero</span><span class="s3">()</span>

        <span class="s0">for </span><span class="s1">geom </span><span class="s0">in </span><span class="s1">geom_node</span><span class="s3">.</span><span class="s1">modify_geoms</span><span class="s3">():</span>
            <span class="s1">gvd </span><span class="s3">= </span><span class="s1">geom</span><span class="s3">.</span><span class="s1">modify_vertex_data</span><span class="s3">()</span>
            <span class="s1">vformat </span><span class="s3">= </span><span class="s1">gvd</span><span class="s3">.</span><span class="s1">get_format</span><span class="s3">()</span>

            <span class="s1">stable </span><span class="s3">= </span><span class="s1">SliderTable</span><span class="s3">()</span>

            <span class="s0">for </span><span class="s3">(</span><span class="s1">slider_meshid</span><span class="s3">, </span><span class="s1">name</span><span class="s3">), </span><span class="s1">slider </span><span class="s0">in </span><span class="s1">cvsmap</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s0">if </span><span class="s1">slider_meshid </span><span class="s3">!= </span><span class="s1">meshid</span><span class="s3">:</span>
                    <span class="s0">continue</span>

                <span class="s2"># Iterate through the morph columns to figure out which rows are</span>
                <span class="s2"># affected by which slider.</span>
                <span class="s1">rows </span><span class="s3">= </span><span class="s1">SparseArray</span><span class="s3">()</span>

                <span class="s0">for </span><span class="s1">morph_i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">vformat</span><span class="s3">.</span><span class="s1">get_num_morphs</span><span class="s3">()):</span>
                    <span class="s1">column_name </span><span class="s3">= </span><span class="s1">vformat</span><span class="s3">.</span><span class="s1">get_morph_delta</span><span class="s3">(</span><span class="s1">morph_i</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s1">column_name</span><span class="s3">.</span><span class="s1">basename </span><span class="s3">== </span><span class="s1">name</span><span class="s3">:</span>
                        <span class="s1">gvr </span><span class="s3">= </span><span class="s1">GeomVertexReader</span><span class="s3">(</span><span class="s1">gvd</span><span class="s3">, </span><span class="s1">vformat</span><span class="s3">.</span><span class="s1">get_morph_delta</span><span class="s3">(</span><span class="s1">morph_i</span><span class="s3">))</span>
                        <span class="s1">row </span><span class="s3">= </span><span class="s5">0</span>
                        <span class="s0">while not </span><span class="s1">gvr</span><span class="s3">.</span><span class="s1">is_at_end</span><span class="s3">():</span>
                            <span class="s0">if </span><span class="s1">gvr</span><span class="s3">.</span><span class="s1">get_data4</span><span class="s3">() != </span><span class="s1">zero</span><span class="s3">:</span>
                                <span class="s1">rows</span><span class="s3">.</span><span class="s1">set_bit</span><span class="s3">(</span><span class="s1">row</span><span class="s3">)</span>
                            <span class="s1">row </span><span class="s3">+= </span><span class="s5">1</span>

                <span class="s0">if not </span><span class="s1">rows</span><span class="s3">.</span><span class="s1">is_zero</span><span class="s3">():</span>
                    <span class="s1">stable</span><span class="s3">.</span><span class="s1">add_slider</span><span class="s3">(</span><span class="s1">slider</span><span class="s3">, </span><span class="s1">rows</span><span class="s3">)</span>

            <span class="s0">if </span><span class="s1">stable</span><span class="s3">.</span><span class="s1">get_num_sliders</span><span class="s3">() &gt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">gvd</span><span class="s3">.</span><span class="s1">set_slider_table</span><span class="s3">(</span><span class="s1">SliderTable</span><span class="s3">.</span><span class="s1">register_table</span><span class="s3">(</span><span class="s1">stable</span><span class="s3">))</span>

    <span class="s0">def </span><span class="s1">build_character_joints</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">char</span><span class="s3">, </span><span class="s1">root_nodeids</span><span class="s3">, </span><span class="s1">affected_nodeids</span><span class="s3">, </span><span class="s1">skinid</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">):</span>
        <span class="s1">gltf_skin </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'skins'</span><span class="s3">][</span><span class="s1">skinid</span><span class="s3">]</span>

        <span class="s1">bundle </span><span class="s3">= </span><span class="s1">char</span><span class="s3">.</span><span class="s1">get_bundle</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">skeleton </span><span class="s3">= </span><span class="s1">PartGroup</span><span class="s3">(</span><span class="s1">bundle</span><span class="s3">, </span><span class="s4">&quot;&lt;skeleton&gt;&quot;</span><span class="s3">)</span>
        <span class="s1">jvtmap </span><span class="s3">= {}</span>

        <span class="s1">bind_mats </span><span class="s3">= {}</span>
        <span class="s0">if </span><span class="s4">'inverseBindMatrices' </span><span class="s0">in </span><span class="s1">gltf_skin</span><span class="s3">:</span>
            <span class="s1">ibmacc </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'accessors'</span><span class="s3">][</span><span class="s1">gltf_skin</span><span class="s3">[</span><span class="s4">'inverseBindMatrices'</span><span class="s3">]]</span>
            <span class="s1">ibmbv </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'bufferViews'</span><span class="s3">][</span><span class="s1">ibmacc</span><span class="s3">[</span><span class="s4">'bufferView'</span><span class="s3">]]</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">ibmacc</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) + </span><span class="s1">ibmbv</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
            <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">ibmacc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">] * </span><span class="s5">16 </span><span class="s3">* </span><span class="s5">4</span>
            <span class="s1">ibmdata </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffers</span><span class="s3">[</span><span class="s1">ibmbv</span><span class="s3">[</span><span class="s4">'buffer'</span><span class="s3">]][</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">]</span>

            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ibmacc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">]):</span>
                <span class="s1">mat </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s4">'&lt;{}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s4">'f'</span><span class="s3">*</span><span class="s5">16</span><span class="s3">), </span><span class="s1">ibmdata</span><span class="s3">, </span><span class="s1">i </span><span class="s3">* </span><span class="s5">16 </span><span class="s3">* </span><span class="s5">4</span><span class="s3">)</span>
                <span class="s2">#print('loaded', mat)</span>
                <span class="s1">mat </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">load_matrix</span><span class="s3">(</span><span class="s1">mat</span><span class="s3">)</span>
                <span class="s1">mat</span><span class="s3">.</span><span class="s1">invert_in_place</span><span class="s3">()</span>
                <span class="s1">bind_mats</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">mat</span>

        <span class="s0">def </span><span class="s1">create_joint</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">, </span><span class="s1">nodeid</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">):</span>
            <span class="s1">node </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">][</span><span class="s1">nodeid</span><span class="s3">]</span>
            <span class="s1">node_name </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'bone'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">))</span>

            <span class="s0">if </span><span class="s4">'mesh' </span><span class="s0">in </span><span class="s1">node</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">joint_parents</span><span class="s3">[</span><span class="s1">nodeid</span><span class="s3">] = </span><span class="s1">parent</span>
                <span class="s0">return</span>

            <span class="s1">inv_transform </span><span class="s3">= </span><span class="s1">LMatrix4</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">)</span>
            <span class="s1">inv_transform</span><span class="s3">.</span><span class="s1">invert_in_place</span><span class="s3">()</span>
            <span class="s1">joint_index </span><span class="s3">= </span><span class="s0">None</span>
            <span class="s1">joint_mat </span><span class="s3">= </span><span class="s1">LMatrix4</span><span class="s3">.</span><span class="s1">ident_mat</span><span class="s3">()</span>
            <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">in </span><span class="s1">gltf_skin</span><span class="s3">[</span><span class="s4">'joints'</span><span class="s3">]:</span>
                <span class="s1">joint_index </span><span class="s3">= </span><span class="s1">gltf_skin</span><span class="s3">[</span><span class="s4">'joints'</span><span class="s3">].</span><span class="s1">index</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">)</span>
                <span class="s1">joint_mat </span><span class="s3">= </span><span class="s1">bind_mats</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">joint_index</span><span class="s3">, </span><span class="s1">LMatrix4</span><span class="s3">.</span><span class="s1">ident_mat</span><span class="s3">())</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_joint_nodes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">)</span>

            <span class="s2"># glTF uses an absolute bind pose, Panda wants it local</span>
            <span class="s1">bind_pose </span><span class="s3">= </span><span class="s1">joint_mat </span><span class="s3">* </span><span class="s1">inv_transform</span>
            <span class="s1">joint </span><span class="s3">= </span><span class="s1">CharacterJoint</span><span class="s3">(</span><span class="s1">char</span><span class="s3">, </span><span class="s1">bundle</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">, </span><span class="s1">node_name</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">csxform_inv </span><span class="s3">* </span><span class="s1">bind_pose </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">csxform</span><span class="s3">)</span>

            <span class="s2"># Non-deforming bones are not in the skin's jointNames, don't add them to the jvtmap</span>
            <span class="s0">if </span><span class="s1">joint_index </span><span class="s0">is not None</span><span class="s3">:</span>
                <span class="s1">jvtmap</span><span class="s3">[</span><span class="s1">joint_index</span><span class="s3">] = </span><span class="s1">JointVertexTransform</span><span class="s3">(</span><span class="s1">joint</span><span class="s3">)</span>

            <span class="s1">affected_nodeids</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">)</span>

            <span class="s0">for </span><span class="s1">child </span><span class="s0">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'children'</span><span class="s3">, []):</span>
                <span class="s2">#print(&quot;Create joint for child&quot;, child)</span>
                <span class="s1">create_joint</span><span class="s3">(</span><span class="s1">joint</span><span class="s3">, </span><span class="s1">child</span><span class="s3">, </span><span class="s1">bind_pose </span><span class="s3">* </span><span class="s1">transform</span><span class="s3">)</span>

        <span class="s1">root_mat </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">csxform </span><span class="s3">* </span><span class="s1">NodePath</span><span class="s3">(</span><span class="s1">char</span><span class="s3">).</span><span class="s1">get_net_transform</span><span class="s3">().</span><span class="s1">get_mat</span><span class="s3">() * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">csxform_inv</span>
        <span class="s0">for </span><span class="s1">root_nodeid </span><span class="s0">in </span><span class="s1">root_nodeids</span><span class="s3">:</span>
            <span class="s2"># Construct a path to the root</span>
            <span class="s1">create_joint</span><span class="s3">(</span><span class="s1">skeleton</span><span class="s3">, </span><span class="s1">root_nodeid</span><span class="s3">, </span><span class="s1">root_mat</span><span class="s3">)</span>

        <span class="s0">return </span><span class="s1">jvtmap</span>

    <span class="s0">def </span><span class="s1">build_character_sliders</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">char</span><span class="s3">, </span><span class="s1">root_nodeid</span><span class="s3">, </span><span class="s1">affected_nodeids</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">, </span><span class="s1">recurse</span><span class="s3">=</span><span class="s0">True</span><span class="s3">):</span>
        <span class="s1">bundle </span><span class="s3">= </span><span class="s1">char</span><span class="s3">.</span><span class="s1">get_bundle</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">morph </span><span class="s3">= </span><span class="s1">PartGroup</span><span class="s3">(</span><span class="s1">bundle</span><span class="s3">, </span><span class="s4">&quot;morph&quot;</span><span class="s3">)</span>
        <span class="s1">cvsmap </span><span class="s3">= {}</span>

        <span class="s0">def </span><span class="s1">create_slider</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">):</span>
            <span class="s1">gltf_node </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">][</span><span class="s1">nodeid</span><span class="s3">]</span>

            <span class="s0">if </span><span class="s4">'mesh' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">:</span>
                <span class="s1">meshid </span><span class="s3">= </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'mesh'</span><span class="s3">]</span>
                <span class="s1">gltf_mesh </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'meshes'</span><span class="s3">][</span><span class="s1">meshid</span><span class="s3">]</span>
                <span class="s1">weights </span><span class="s3">= </span><span class="s1">gltf_mesh</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'weights'</span><span class="s3">)</span>

                <span class="s1">num_targets </span><span class="s3">= </span><span class="s5">0</span>
                <span class="s0">for </span><span class="s1">gltf_primitive </span><span class="s0">in </span><span class="s1">gltf_mesh</span><span class="s3">[</span><span class="s4">'primitives'</span><span class="s3">]:</span>
                    <span class="s1">targets </span><span class="s3">= </span><span class="s1">gltf_primitive</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'targets'</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s1">targets</span><span class="s3">:</span>
                        <span class="s1">num_targets </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">targets</span><span class="s3">), </span><span class="s1">num_targets</span><span class="s3">)</span>

                <span class="s0">if </span><span class="s1">num_targets </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">target_names </span><span class="s3">= </span><span class="s1">get_extras</span><span class="s3">(</span><span class="s1">gltf_mesh</span><span class="s3">).</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'targetNames'</span><span class="s3">, [])</span>
                    <span class="s1">num_targets </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_names</span><span class="s3">), </span><span class="s1">num_targets</span><span class="s3">)</span>

                    <span class="s0">if not </span><span class="s1">weights</span><span class="s3">:</span>
                        <span class="s1">weights </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">num_targets</span>

                    <span class="s0">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_names</span><span class="s3">) &lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">):</span>
                        <span class="s1">target_names </span><span class="s3">+= [</span><span class="s1">str</span><span class="s3">(</span><span class="s1">i</span><span class="s3">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_names</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">))]</span>

                    <span class="s0">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_names</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">)</span>
                    <span class="s1">affected_nodeids</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">nodeid</span><span class="s3">)</span>

                    <span class="s2"># If we do this recursively, create a group for every mesh.</span>
                    <span class="s0">if </span><span class="s1">recurse</span><span class="s3">:</span>
                        <span class="s1">group </span><span class="s3">= </span><span class="s1">PartGroup</span><span class="s3">(</span><span class="s1">morph</span><span class="s3">, </span><span class="s4">'mesh'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">meshid</span><span class="s3">))</span>
                    <span class="s0">else</span><span class="s3">:</span>
                        <span class="s1">group </span><span class="s3">= </span><span class="s1">morph</span>

                    <span class="s0">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">target_names</span><span class="s3">):</span>
                        <span class="s0">try</span><span class="s3">:</span>
                            <span class="s1">slider </span><span class="s3">= </span><span class="s1">CharacterSlider</span><span class="s3">(</span><span class="s1">group</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
                        <span class="s0">except </span><span class="s1">TypeError</span><span class="s3">:</span>
                            <span class="s2"># Panda versions before 1.10.6.dev6 did not permit default values.</span>
                            <span class="s1">slider </span><span class="s3">= </span><span class="s1">CharacterSlider</span><span class="s3">(</span><span class="s1">group</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

                        <span class="s1">cvsmap</span><span class="s3">[(</span><span class="s1">meshid</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)] = </span><span class="s1">CharacterVertexSlider</span><span class="s3">(</span><span class="s1">slider</span><span class="s3">)</span>

            <span class="s0">if </span><span class="s1">recurse</span><span class="s3">:</span>
                <span class="s0">for </span><span class="s1">child </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'children'</span><span class="s3">, []):</span>
                    <span class="s1">create_slider</span><span class="s3">(</span><span class="s1">child</span><span class="s3">)</span>

        <span class="s1">create_slider</span><span class="s3">(</span><span class="s1">root_nodeid</span><span class="s3">)</span>
        <span class="s0">return </span><span class="s1">cvsmap</span>

    <span class="s0">def </span><span class="s1">build_animation_skeleton</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">character</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">, </span><span class="s1">boneid</span><span class="s3">, </span><span class="s1">num_frames</span><span class="s3">, </span><span class="s1">gltf_anim</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">):</span>
        <span class="s1">samplers </span><span class="s3">= </span><span class="s1">gltf_anim</span><span class="s3">[</span><span class="s4">'samplers'</span><span class="s3">]</span>
        <span class="s1">bone </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">][</span><span class="s1">boneid</span><span class="s3">]</span>
        <span class="s1">bone_name </span><span class="s3">= </span><span class="s1">bone</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'bone'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">boneid</span><span class="s3">))</span>
        <span class="s1">channels </span><span class="s3">= [</span><span class="s1">chan </span><span class="s0">for </span><span class="s1">chan </span><span class="s0">in </span><span class="s1">gltf_anim</span><span class="s3">[</span><span class="s4">'channels'</span><span class="s3">] </span><span class="s0">if </span><span class="s1">chan</span><span class="s3">[</span><span class="s4">'target'</span><span class="s3">][</span><span class="s4">'node'</span><span class="s3">] == </span><span class="s1">boneid</span><span class="s3">]</span>
        <span class="s1">joint_mat </span><span class="s3">= </span><span class="s1">character</span><span class="s3">.</span><span class="s1">find_joint</span><span class="s3">(</span><span class="s1">bone_name</span><span class="s3">).</span><span class="s1">get_transform</span><span class="s3">()</span>

        <span class="s1">group </span><span class="s3">= </span><span class="s1">AnimChannelMatrixXfmTable</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">, </span><span class="s1">bone_name</span><span class="s3">)</span>

        <span class="s0">def </span><span class="s1">get_accessor</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">accessors </span><span class="s3">= [</span>
                <span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'accessors'</span><span class="s3">][</span><span class="s1">samplers</span><span class="s3">[</span><span class="s1">chan</span><span class="s3">[</span><span class="s4">'sampler'</span><span class="s3">]][</span><span class="s4">'output'</span><span class="s3">]]</span>
                <span class="s0">for </span><span class="s1">chan </span><span class="s0">in </span><span class="s1">channels</span>
                <span class="s0">if </span><span class="s1">chan</span><span class="s3">[</span><span class="s4">'target'</span><span class="s3">][</span><span class="s4">'path'</span><span class="s3">] == </span><span class="s1">path</span>
            <span class="s3">]</span>

            <span class="s0">return </span><span class="s1">accessors</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s0">if </span><span class="s1">accessors </span><span class="s0">else None</span>

        <span class="s0">def </span><span class="s1">extract_chan_data</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s1">get_accessor</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
            <span class="s0">if not </span><span class="s1">acc</span><span class="s3">:</span>
                <span class="s0">return None</span>

            <span class="s1">buff_view </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'bufferViews'</span><span class="s3">][</span><span class="s1">acc</span><span class="s3">[</span><span class="s4">'bufferView'</span><span class="s3">]]</span>
            <span class="s1">buff_data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffers</span><span class="s3">[</span><span class="s1">buff_view</span><span class="s3">[</span><span class="s4">'buffer'</span><span class="s3">]]</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">acc</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) + </span><span class="s1">buff_view</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

            <span class="s0">if </span><span class="s1">path </span><span class="s3">== </span><span class="s4">'rotation'</span><span class="s3">:</span>
                <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">acc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">] * </span><span class="s5">4 </span><span class="s3">* </span><span class="s5">4</span>
                <span class="s1">data </span><span class="s3">= [</span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s4">'&lt;ffff'</span><span class="s3">, </span><span class="s1">buff_data</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">) </span><span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s5">4 </span><span class="s3">* </span><span class="s5">4</span><span class="s3">)]</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">acc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">] * </span><span class="s5">3 </span><span class="s3">* </span><span class="s5">4</span>
                <span class="s1">data </span><span class="s3">= [</span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s4">'&lt;fff'</span><span class="s3">, </span><span class="s1">buff_data</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">) </span><span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s5">3 </span><span class="s3">* </span><span class="s5">4</span><span class="s3">)]</span>

            <span class="s0">return </span><span class="s1">data</span>

        <span class="s2"># Create default animaton data</span>
        <span class="s1">translation </span><span class="s3">= </span><span class="s1">LVector3</span><span class="s3">()</span>
        <span class="s1">rotation </span><span class="s3">= </span><span class="s1">LVector3</span><span class="s3">()</span>
        <span class="s1">scale </span><span class="s3">= </span><span class="s1">LVector3</span><span class="s3">()</span>
        <span class="s1">decompose_matrix</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">csxform </span><span class="s3">* </span><span class="s1">joint_mat </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">csxform_inv</span><span class="s3">, </span><span class="s1">scale</span><span class="s3">, </span><span class="s1">rotation</span><span class="s3">, </span><span class="s1">translation</span><span class="s3">, </span><span class="s1">CS_yup_right</span><span class="s3">)</span>

        <span class="s2"># Override defaults with any found animation data</span>
        <span class="s1">loc_data </span><span class="s3">= </span><span class="s1">extract_chan_data</span><span class="s3">(</span><span class="s4">'translation'</span><span class="s3">)</span>
        <span class="s1">rot_data </span><span class="s3">= </span><span class="s1">extract_chan_data</span><span class="s3">(</span><span class="s4">'rotation'</span><span class="s3">)</span>
        <span class="s1">scale_data </span><span class="s3">= </span><span class="s1">extract_chan_data</span><span class="s3">(</span><span class="s4">'scale'</span><span class="s3">)</span>

        <span class="s1">loc_vals </span><span class="s3">= [[], [], []]</span>
        <span class="s1">rot_vals </span><span class="s3">= [[], [], []]</span>
        <span class="s1">scale_vals </span><span class="s3">= [[], [], []]</span>

        <span class="s2"># Repeat last frame if we don't have enough data for all frames.</span>
        <span class="s0">if </span><span class="s1">loc_data </span><span class="s0">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">loc_data</span><span class="s3">) &lt; </span><span class="s1">num_frames</span><span class="s3">:</span>
            <span class="s1">loc_data </span><span class="s3">+= </span><span class="s1">loc_data</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">:] * (</span><span class="s1">num_frames </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">loc_data</span><span class="s3">))</span>
        <span class="s0">if </span><span class="s1">rot_data </span><span class="s0">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">rot_data</span><span class="s3">) &lt; </span><span class="s1">num_frames</span><span class="s3">:</span>
            <span class="s1">rot_data </span><span class="s3">+= </span><span class="s1">rot_data</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">:] * (</span><span class="s1">num_frames </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">rot_data</span><span class="s3">))</span>
        <span class="s0">if </span><span class="s1">scale_data </span><span class="s0">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">scale_data</span><span class="s3">) &lt; </span><span class="s1">num_frames</span><span class="s3">:</span>
            <span class="s1">scale_data </span><span class="s3">+= </span><span class="s1">scale_data</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">:] * (</span><span class="s1">num_frames </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">scale_data</span><span class="s3">))</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">num_frames</span><span class="s3">):</span>
            <span class="s0">if </span><span class="s1">scale_data</span><span class="s3">:</span>
                <span class="s1">frame_scale </span><span class="s3">= </span><span class="s1">scale_data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">frame_scale </span><span class="s3">= </span><span class="s1">scale</span>

            <span class="s0">if </span><span class="s1">rot_data</span><span class="s3">:</span>
                <span class="s1">quat </span><span class="s3">= </span><span class="s1">rot_data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s1">frame_rotation </span><span class="s3">= </span><span class="s1">LQuaternion</span><span class="s3">(</span><span class="s1">quat</span><span class="s3">[</span><span class="s5">3</span><span class="s3">], </span><span class="s1">quat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">quat</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">quat</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">frame_rotation </span><span class="s3">= </span><span class="s1">LQuaternion</span><span class="s3">()</span>
                <span class="s1">frame_rotation</span><span class="s3">.</span><span class="s1">set_hpr</span><span class="s3">(</span><span class="s1">rotation</span><span class="s3">, </span><span class="s1">CS_yup_right</span><span class="s3">)</span>

            <span class="s0">if </span><span class="s1">loc_data</span><span class="s3">:</span>
                <span class="s1">frame_translation </span><span class="s3">= </span><span class="s1">loc_data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">frame_translation </span><span class="s3">= </span><span class="s1">translation</span>

            <span class="s1">mat </span><span class="s3">= </span><span class="s1">LMatrix4</span><span class="s3">(</span><span class="s1">LMatrix4</span><span class="s3">.</span><span class="s1">ident_mat</span><span class="s3">())</span>
            <span class="s1">mat </span><span class="s3">*= </span><span class="s1">LMatrix4</span><span class="s3">.</span><span class="s1">scale_mat</span><span class="s3">(</span><span class="s1">frame_scale</span><span class="s3">)</span>
            <span class="s1">mat </span><span class="s3">= </span><span class="s1">frame_rotation </span><span class="s3">* </span><span class="s1">mat</span>
            <span class="s1">mat </span><span class="s3">*= </span><span class="s1">LMatrix4</span><span class="s3">.</span><span class="s1">translate_mat</span><span class="s3">(</span><span class="s1">frame_translation</span><span class="s3">)</span>
            <span class="s1">mat </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">csxform_inv </span><span class="s3">* </span><span class="s1">mat </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">csxform</span>

            <span class="s1">frame_translation </span><span class="s3">= </span><span class="s1">LVector3</span><span class="s3">()</span>
            <span class="s1">frame_scale </span><span class="s3">= </span><span class="s1">LVector3</span><span class="s3">()</span>
            <span class="s1">frame_rotation </span><span class="s3">= </span><span class="s1">LVector3</span><span class="s3">()</span>
            <span class="s1">decompose_matrix</span><span class="s3">(</span><span class="s1">mat</span><span class="s3">, </span><span class="s1">frame_scale</span><span class="s3">, </span><span class="s1">frame_rotation</span><span class="s3">, </span><span class="s1">frame_translation</span><span class="s3">)</span>

            <span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">frame_translation</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
            <span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">frame_translation</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
            <span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">frame_translation</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>
            <span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">frame_rotation</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
            <span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">frame_rotation</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
            <span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">frame_rotation</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>
            <span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">frame_scale</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
            <span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">frame_scale</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
            <span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">frame_scale</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>

        <span class="s2"># If all frames are the same, we only need to store one frame.</span>
        <span class="s0">if </span><span class="s1">min</span><span class="s3">(</span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) == </span><span class="s1">max</span><span class="s3">(</span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) </span><span class="s0">and </span><span class="s1">\</span>
           <span class="s1">min</span><span class="s3">(</span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) == </span><span class="s1">max</span><span class="s3">(</span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) </span><span class="s0">and </span><span class="s1">\</span>
           <span class="s1">min</span><span class="s3">(</span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) == </span><span class="s1">max</span><span class="s3">(</span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) </span><span class="s0">and </span><span class="s1">\</span>
           <span class="s1">min</span><span class="s3">(</span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) == </span><span class="s1">max</span><span class="s3">(</span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) </span><span class="s0">and </span><span class="s1">\</span>
           <span class="s1">min</span><span class="s3">(</span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) == </span><span class="s1">max</span><span class="s3">(</span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) </span><span class="s0">and </span><span class="s1">\</span>
           <span class="s1">min</span><span class="s3">(</span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) == </span><span class="s1">max</span><span class="s3">(</span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) </span><span class="s0">and </span><span class="s1">\</span>
           <span class="s1">min</span><span class="s3">(</span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) == </span><span class="s1">max</span><span class="s3">(</span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) </span><span class="s0">and </span><span class="s1">\</span>
           <span class="s1">min</span><span class="s3">(</span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) == </span><span class="s1">max</span><span class="s3">(</span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) </span><span class="s0">and </span><span class="s1">\</span>
           <span class="s1">min</span><span class="s3">(</span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) == </span><span class="s1">max</span><span class="s3">(</span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]):</span>
            <span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][:</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][:</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">][:</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][:</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][:</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">][:</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][:</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][:</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">][:</span><span class="s5">1</span><span class="s3">]</span>

        <span class="s2"># Write data to tables</span>
        <span class="s1">group</span><span class="s3">.</span><span class="s1">set_table</span><span class="s3">(</span><span class="s6">b'x'</span><span class="s3">, </span><span class="s1">CPTA_stdfloat</span><span class="s3">(</span><span class="s1">PTA_stdfloat</span><span class="s3">(</span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])))</span>
        <span class="s1">group</span><span class="s3">.</span><span class="s1">set_table</span><span class="s3">(</span><span class="s6">b'y'</span><span class="s3">, </span><span class="s1">CPTA_stdfloat</span><span class="s3">(</span><span class="s1">PTA_stdfloat</span><span class="s3">(</span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])))</span>
        <span class="s1">group</span><span class="s3">.</span><span class="s1">set_table</span><span class="s3">(</span><span class="s6">b'z'</span><span class="s3">, </span><span class="s1">CPTA_stdfloat</span><span class="s3">(</span><span class="s1">PTA_stdfloat</span><span class="s3">(</span><span class="s1">loc_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])))</span>

        <span class="s1">group</span><span class="s3">.</span><span class="s1">set_table</span><span class="s3">(</span><span class="s6">b'h'</span><span class="s3">, </span><span class="s1">CPTA_stdfloat</span><span class="s3">(</span><span class="s1">PTA_stdfloat</span><span class="s3">(</span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])))</span>
        <span class="s1">group</span><span class="s3">.</span><span class="s1">set_table</span><span class="s3">(</span><span class="s6">b'p'</span><span class="s3">, </span><span class="s1">CPTA_stdfloat</span><span class="s3">(</span><span class="s1">PTA_stdfloat</span><span class="s3">(</span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])))</span>
        <span class="s1">group</span><span class="s3">.</span><span class="s1">set_table</span><span class="s3">(</span><span class="s6">b'r'</span><span class="s3">, </span><span class="s1">CPTA_stdfloat</span><span class="s3">(</span><span class="s1">PTA_stdfloat</span><span class="s3">(</span><span class="s1">rot_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])))</span>

        <span class="s1">group</span><span class="s3">.</span><span class="s1">set_table</span><span class="s3">(</span><span class="s6">b'i'</span><span class="s3">, </span><span class="s1">CPTA_stdfloat</span><span class="s3">(</span><span class="s1">PTA_stdfloat</span><span class="s3">(</span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])))</span>
        <span class="s1">group</span><span class="s3">.</span><span class="s1">set_table</span><span class="s3">(</span><span class="s6">b'j'</span><span class="s3">, </span><span class="s1">CPTA_stdfloat</span><span class="s3">(</span><span class="s1">PTA_stdfloat</span><span class="s3">(</span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])))</span>
        <span class="s1">group</span><span class="s3">.</span><span class="s1">set_table</span><span class="s3">(</span><span class="s6">b'k'</span><span class="s3">, </span><span class="s1">CPTA_stdfloat</span><span class="s3">(</span><span class="s1">PTA_stdfloat</span><span class="s3">(</span><span class="s1">scale_vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])))</span>

        <span class="s0">for </span><span class="s1">childid </span><span class="s0">in </span><span class="s1">bone</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'children'</span><span class="s3">, []):</span>
            <span class="s1">gltf_node </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">][</span><span class="s1">childid</span><span class="s3">]</span>
            <span class="s0">if </span><span class="s4">'mesh' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">:</span>
                <span class="s0">continue</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">build_animation_skeleton</span><span class="s3">(</span><span class="s1">character</span><span class="s3">, </span><span class="s1">group</span><span class="s3">, </span><span class="s1">childid</span><span class="s3">, </span><span class="s1">num_frames</span><span class="s3">, </span><span class="s1">gltf_anim</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">)</span>

    <span class="s0">def </span><span class="s1">build_animation_morph</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">, </span><span class="s1">nodeid</span><span class="s3">, </span><span class="s1">num_frames</span><span class="s3">, </span><span class="s1">gltf_anim</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">, </span><span class="s1">recurse</span><span class="s3">=</span><span class="s0">True</span><span class="s3">):</span>
        <span class="s1">samplers </span><span class="s3">= </span><span class="s1">gltf_anim</span><span class="s3">[</span><span class="s4">'samplers'</span><span class="s3">]</span>

        <span class="s0">def </span><span class="s1">create_channels</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">, </span><span class="s1">nodeid</span><span class="s3">, </span><span class="s1">target_names</span><span class="s3">, </span><span class="s1">default_weights</span><span class="s3">):</span>
            <span class="s1">channels </span><span class="s3">= [</span>
                <span class="s1">chan </span><span class="s0">for </span><span class="s1">chan </span><span class="s0">in </span><span class="s1">gltf_anim</span><span class="s3">[</span><span class="s4">'channels'</span><span class="s3">]</span>
                <span class="s0">if </span><span class="s1">chan</span><span class="s3">[</span><span class="s4">'target'</span><span class="s3">][</span><span class="s4">'node'</span><span class="s3">] == </span><span class="s1">nodeid </span><span class="s0">and </span><span class="s1">chan</span><span class="s3">[</span><span class="s4">'target'</span><span class="s3">][</span><span class="s4">'path'</span><span class="s3">] == </span><span class="s4">'weights'</span>
            <span class="s3">]</span>

            <span class="s1">accessors </span><span class="s3">= [</span>
                <span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'accessors'</span><span class="s3">][</span><span class="s1">samplers</span><span class="s3">[</span><span class="s1">chan</span><span class="s3">[</span><span class="s4">'sampler'</span><span class="s3">]][</span><span class="s4">'output'</span><span class="s3">]]</span>
                <span class="s0">for </span><span class="s1">chan </span><span class="s0">in </span><span class="s1">channels</span>
                <span class="s0">if </span><span class="s1">chan</span><span class="s3">[</span><span class="s4">'target'</span><span class="s3">][</span><span class="s4">'path'</span><span class="s3">] == </span><span class="s4">'weights'</span>
            <span class="s3">]</span>

            <span class="s0">if </span><span class="s1">accessors</span><span class="s3">:</span>
                <span class="s1">acc </span><span class="s3">= </span><span class="s1">accessors</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s1">buff_view </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'bufferViews'</span><span class="s3">][</span><span class="s1">acc</span><span class="s3">[</span><span class="s4">'bufferView'</span><span class="s3">]]</span>
                <span class="s1">buff_data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffers</span><span class="s3">[</span><span class="s1">buff_view</span><span class="s3">[</span><span class="s4">'buffer'</span><span class="s3">]]</span>
                <span class="s1">start </span><span class="s3">= </span><span class="s1">acc</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) + </span><span class="s1">buff_view</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'byteOffset'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

                <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">acc</span><span class="s3">[</span><span class="s4">'count'</span><span class="s3">] * </span><span class="s5">4</span>
                <span class="s1">weights </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">CPTAFloat</span><span class="s3">(</span><span class="s1">buff_data</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">]))</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">weights </span><span class="s3">= </span><span class="s1">default_weights</span>

            <span class="s1">num_targets </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">default_weights</span><span class="s3">)</span>

            <span class="s0">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">target_name </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">target_names</span><span class="s3">):</span>
                <span class="s0">try</span><span class="s3">:</span>
                    <span class="s1">group </span><span class="s3">= </span><span class="s1">AnimChannelScalarTable</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">, </span><span class="s1">target_name</span><span class="s3">)</span>
                <span class="s0">except </span><span class="s1">TypeError</span><span class="s3">:</span>
                    <span class="s2"># Panda version too old, requires at least 1.10.6.dev5</span>
                    <span class="s0">return</span>

                <span class="s1">target_weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">[</span><span class="s1">i</span><span class="s3">::</span><span class="s1">num_targets</span><span class="s3">]</span>

                <span class="s0">if </span><span class="s1">min</span><span class="s3">(</span><span class="s1">target_weights</span><span class="s3">) == </span><span class="s1">max</span><span class="s3">(</span><span class="s1">target_weights</span><span class="s3">):</span>
                    <span class="s2"># If all frames are the same, we only need to store one frame.</span>
                    <span class="s1">target_weights </span><span class="s3">= </span><span class="s1">target_weights</span><span class="s3">[:</span><span class="s5">1</span><span class="s3">]</span>
                <span class="s0">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_weights</span><span class="s3">) &gt; </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_weights</span><span class="s3">) &lt; </span><span class="s1">num_frames</span><span class="s3">:</span>
                    <span class="s2"># If we don't have enough frames, repeat the last value.</span>
                    <span class="s1">target_weights </span><span class="s3">+= </span><span class="s1">target_weights</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">:] * (</span><span class="s1">num_frames </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_weights</span><span class="s3">))</span>
                <span class="s0">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_weights</span><span class="s3">) &gt; </span><span class="s1">num_frames</span><span class="s3">:</span>
                    <span class="s2"># We have too many frames.</span>
                    <span class="s1">target_weights </span><span class="s3">= </span><span class="s1">target_weights</span><span class="s3">[:</span><span class="s1">num_frames</span><span class="s3">]</span>

                <span class="s1">group</span><span class="s3">.</span><span class="s1">set_table</span><span class="s3">(</span><span class="s1">CPTA_stdfloat</span><span class="s3">(</span><span class="s1">target_weights</span><span class="s3">))</span>

        <span class="s1">gltf_node </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'nodes'</span><span class="s3">][</span><span class="s1">nodeid</span><span class="s3">]</span>

        <span class="s0">if </span><span class="s4">'mesh' </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">:</span>
            <span class="s1">meshid </span><span class="s3">= </span><span class="s1">gltf_node</span><span class="s3">[</span><span class="s4">'mesh'</span><span class="s3">]</span>
            <span class="s1">gltf_mesh </span><span class="s3">= </span><span class="s1">gltf_data</span><span class="s3">[</span><span class="s4">'meshes'</span><span class="s3">][</span><span class="s1">meshid</span><span class="s3">]</span>
            <span class="s1">weights </span><span class="s3">= </span><span class="s1">gltf_mesh</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'weights'</span><span class="s3">)</span>
            <span class="s0">if </span><span class="s1">weights</span><span class="s3">:</span>
                <span class="s1">target_names </span><span class="s3">= </span><span class="s1">get_extras</span><span class="s3">(</span><span class="s1">gltf_mesh</span><span class="s3">).</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'targetNames'</span><span class="s3">, [])</span>
                <span class="s0">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_names</span><span class="s3">) &lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">):</span>
                    <span class="s1">target_names </span><span class="s3">+= [</span><span class="s1">str</span><span class="s3">(</span><span class="s1">i</span><span class="s3">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_names</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">))]</span>

                <span class="s0">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_names</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">)</span>

                <span class="s2"># If we do this recursively, group the sliders for each mesh</span>
                <span class="s2"># under a group for their respective mesh, so that the names will</span>
                <span class="s2"># not conflict.</span>
                <span class="s0">if </span><span class="s1">recurse</span><span class="s3">:</span>
                    <span class="s1">group </span><span class="s3">= </span><span class="s1">AnimGroup</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">, </span><span class="s4">'mesh'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">meshid</span><span class="s3">))</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">group </span><span class="s3">= </span><span class="s1">parent</span>

                <span class="s1">create_channels</span><span class="s3">(</span><span class="s1">group</span><span class="s3">, </span><span class="s1">nodeid</span><span class="s3">, </span><span class="s1">target_names</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s1">recurse</span><span class="s3">:</span>
            <span class="s0">for </span><span class="s1">child </span><span class="s0">in </span><span class="s1">gltf_node</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'children'</span><span class="s3">, []):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">build_animation_morph</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">, </span><span class="s1">child</span><span class="s3">, </span><span class="s1">num_frames</span><span class="s3">, </span><span class="s1">gltf_anim</span><span class="s3">, </span><span class="s1">gltf_data</span><span class="s3">)</span>

    <span class="s0">def </span><span class="s1">load_camera</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">camid</span><span class="s3">, </span><span class="s1">gltf_camera</span><span class="s3">):</span>
        <span class="s1">camname </span><span class="s3">= </span><span class="s1">gltf_camera</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'cam'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">camid</span><span class="s3">))</span>
        <span class="s1">node </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cameras</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">camid</span><span class="s3">, </span><span class="s1">Camera</span><span class="s3">(</span><span class="s1">camname</span><span class="s3">))</span>

        <span class="s0">if </span><span class="s1">gltf_camera</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] == </span><span class="s4">'perspective'</span><span class="s3">:</span>
            <span class="s1">gltf_lens </span><span class="s3">= </span><span class="s1">gltf_camera</span><span class="s3">[</span><span class="s4">'perspective'</span><span class="s3">]</span>
            <span class="s1">lens </span><span class="s3">= </span><span class="s1">PerspectiveLens</span><span class="s3">()</span>
            <span class="s1">aspect_ratio </span><span class="s3">= </span><span class="s1">gltf_lens</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span>
                <span class="s4">'aspectRatio'</span><span class="s3">,</span>
                <span class="s1">lens</span><span class="s3">.</span><span class="s1">get_aspect_ratio</span><span class="s3">()</span>
            <span class="s3">)</span>
            <span class="s1">lens</span><span class="s3">.</span><span class="s1">set_fov</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">degrees</span><span class="s3">(</span><span class="s1">gltf_lens</span><span class="s3">[</span><span class="s4">'yfov'</span><span class="s3">] * </span><span class="s1">aspect_ratio</span><span class="s3">), </span><span class="s1">math</span><span class="s3">.</span><span class="s1">degrees</span><span class="s3">(</span><span class="s1">gltf_lens</span><span class="s3">[</span><span class="s4">'yfov'</span><span class="s3">]))</span>
            <span class="s1">lens</span><span class="s3">.</span><span class="s1">set_near_far</span><span class="s3">(</span><span class="s1">gltf_lens</span><span class="s3">[</span><span class="s4">'znear'</span><span class="s3">], </span><span class="s1">gltf_lens</span><span class="s3">[</span><span class="s4">'zfar'</span><span class="s3">])</span>
            <span class="s1">lens</span><span class="s3">.</span><span class="s1">set_view_vector</span><span class="s3">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">), (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">set_lens</span><span class="s3">(</span><span class="s1">lens</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">cameras</span><span class="s3">[</span><span class="s1">camid</span><span class="s3">] = </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">load_light</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lightid</span><span class="s3">, </span><span class="s1">gltf_light</span><span class="s3">, </span><span class="s1">punctual</span><span class="s3">=</span><span class="s0">False</span><span class="s3">):</span>
        <span class="s1">node </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lights</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">lightid</span><span class="s3">, </span><span class="s0">None</span><span class="s3">)</span>
        <span class="s1">lightname </span><span class="s3">= </span><span class="s1">gltf_light</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'light'</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">lightid</span><span class="s3">))</span>

        <span class="s1">ltype </span><span class="s3">= </span><span class="s1">gltf_light</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]</span>
        <span class="s2"># Construct a new light if needed</span>
        <span class="s0">if </span><span class="s1">node </span><span class="s0">is None</span><span class="s3">:</span>
            <span class="s0">if </span><span class="s1">ltype </span><span class="s3">== </span><span class="s4">'point'</span><span class="s3">:</span>
                <span class="s1">node </span><span class="s3">= </span><span class="s1">PointLight</span><span class="s3">(</span><span class="s1">lightname</span><span class="s3">)</span>
            <span class="s0">elif </span><span class="s1">ltype </span><span class="s3">== </span><span class="s4">'directional'</span><span class="s3">:</span>
                <span class="s1">node </span><span class="s3">= </span><span class="s1">DirectionalLight</span><span class="s3">(</span><span class="s1">lightname</span><span class="s3">)</span>
            <span class="s0">elif </span><span class="s1">ltype </span><span class="s3">== </span><span class="s4">'spot'</span><span class="s3">:</span>
                <span class="s1">node </span><span class="s3">= </span><span class="s1">Spotlight</span><span class="s3">(</span><span class="s1">lightname</span><span class="s3">)</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Unsupported light type for light with name {}: {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">lightname</span><span class="s3">, </span><span class="s1">gltf_light</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]))</span>
                <span class="s1">node </span><span class="s3">= </span><span class="s1">PandaNode</span><span class="s3">(</span><span class="s1">lightname</span><span class="s3">)</span>

        <span class="s2"># Update the light</span>
        <span class="s0">if </span><span class="s1">punctual</span><span class="s3">:</span>
            <span class="s2"># For PBR, attention should always be (1, 0, 1)</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s4">'attenuation'</span><span class="s3">):</span>
                <span class="s1">node</span><span class="s3">.</span><span class="s1">attenuation </span><span class="s3">= </span><span class="s1">LVector3</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

            <span class="s0">if </span><span class="s4">'color' </span><span class="s0">in </span><span class="s1">gltf_light</span><span class="s3">:</span>
                <span class="s1">node</span><span class="s3">.</span><span class="s1">set_color</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(*</span><span class="s1">gltf_light</span><span class="s3">[</span><span class="s4">'color'</span><span class="s3">], </span><span class="s1">w</span><span class="s3">=</span><span class="s5">1</span><span class="s3">) * </span><span class="s1">gltf_light</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'intensity'</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>
            <span class="s0">if </span><span class="s4">'range' </span><span class="s0">in </span><span class="s1">gltf_light</span><span class="s3">:</span>
                <span class="s1">node</span><span class="s3">.</span><span class="s1">max_distance </span><span class="s3">= </span><span class="s1">gltf_light</span><span class="s3">[</span><span class="s4">'range'</span><span class="s3">]</span>
            <span class="s0">if </span><span class="s1">ltype </span><span class="s3">== </span><span class="s4">'spot'</span><span class="s3">:</span>
                <span class="s1">spot </span><span class="s3">= </span><span class="s1">gltf_light</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'spot'</span><span class="s3">, {})</span>
                <span class="s1">inner </span><span class="s3">= </span><span class="s1">spot</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'innerConeAngle'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
                <span class="s1">outer </span><span class="s3">= </span><span class="s1">spot</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'outerConeAngle'</span><span class="s3">, </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">/ </span><span class="s5">4</span><span class="s3">)</span>
                <span class="s1">fov </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">degrees</span><span class="s3">(</span><span class="s1">outer</span><span class="s3">) * </span><span class="s5">2</span>
                <span class="s1">node</span><span class="s3">.</span><span class="s1">get_lens</span><span class="s3">().</span><span class="s1">set_fov</span><span class="s3">(</span><span class="s1">fov</span><span class="s3">, </span><span class="s1">fov</span><span class="s3">)</span>

                <span class="s0">if </span><span class="s1">inner </span><span class="s3">&gt;= </span><span class="s1">outer</span><span class="s3">:</span>
                    <span class="s1">node</span><span class="s3">.</span><span class="s1">exponent </span><span class="s3">= </span><span class="s5">0</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s2"># The value of exp was chosen empirically to give a smooth</span>
                    <span class="s2"># cutoff without straying too far from the spec; higher</span>
                    <span class="s2"># exponents will have a smoother cutoff but sharper falloff.</span>
                    <span class="s1">exp </span><span class="s3">= </span><span class="s5">8 </span><span class="s3">/ </span><span class="s5">3</span>
                    <span class="s1">node</span><span class="s3">.</span><span class="s1">exponent </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s5">0.5 </span><span class="s3">/ </span><span class="s1">outer</span><span class="s3">) ** </span><span class="s1">exp</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s0">if </span><span class="s1">ltype </span><span class="s3">== </span><span class="s4">'unsupported'</span><span class="s3">:</span>
                <span class="s1">lightprops </span><span class="s3">= {}</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">lightprops </span><span class="s3">= </span><span class="s1">gltf_light</span><span class="s3">[</span><span class="s1">ltype</span><span class="s3">]</span>

            <span class="s0">if </span><span class="s1">ltype </span><span class="s0">in </span><span class="s3">(</span><span class="s4">'point'</span><span class="s3">, </span><span class="s4">'directional'</span><span class="s3">, </span><span class="s4">'spot'</span><span class="s3">):</span>
                <span class="s1">node</span><span class="s3">.</span><span class="s1">set_color</span><span class="s3">(</span><span class="s1">LColor</span><span class="s3">(*</span><span class="s1">lightprops</span><span class="s3">[</span><span class="s4">'color'</span><span class="s3">], </span><span class="s1">w</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>

            <span class="s0">if </span><span class="s1">ltype </span><span class="s0">in </span><span class="s3">(</span><span class="s4">'point'</span><span class="s3">, </span><span class="s4">'spot'</span><span class="s3">):</span>
                <span class="s1">att </span><span class="s3">= </span><span class="s1">LPoint3</span><span class="s3">(</span>
                    <span class="s1">lightprops</span><span class="s3">[</span><span class="s4">'constantAttenuation'</span><span class="s3">],</span>
                    <span class="s1">lightprops</span><span class="s3">[</span><span class="s4">'linearAttenuation'</span><span class="s3">],</span>
                    <span class="s1">lightprops</span><span class="s3">[</span><span class="s4">'quadraticAttenuation'</span><span class="s3">]</span>
                <span class="s3">)</span>
                <span class="s1">node</span><span class="s3">.</span><span class="s1">set_attenuation</span><span class="s3">(</span><span class="s1">att</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">lights</span><span class="s3">[</span><span class="s1">lightid</span><span class="s3">] = </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">load_physics_bullet</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node_name</span><span class="s3">, </span><span class="s1">geomnode</span><span class="s3">, </span><span class="s1">shape_type</span><span class="s3">, </span><span class="s1">bounding_box</span><span class="s3">, </span><span class="s1">radius</span><span class="s3">, </span><span class="s1">height</span><span class="s3">, </span><span class="s1">intangible</span><span class="s3">, </span><span class="s1">gltf_rigidbody</span><span class="s3">): </span><span class="s2"># pylint: disable=line-too-long</span>
        <span class="s1">shape </span><span class="s3">= </span><span class="s0">None</span>
        <span class="s1">static </span><span class="s3">= </span><span class="s1">gltf_rigidbody </span><span class="s0">is not None and </span><span class="s4">'static' </span><span class="s0">in </span><span class="s1">gltf_rigidbody </span><span class="s0">and </span><span class="s1">gltf_rigidbody</span><span class="s3">[</span><span class="s4">'static'</span><span class="s3">]</span>

        <span class="s0">if </span><span class="s1">shape_type </span><span class="s3">== </span><span class="s4">'BOX'</span><span class="s3">:</span>
            <span class="s1">shape </span><span class="s3">= </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">BulletBoxShape</span><span class="s3">(</span><span class="s1">LVector3</span><span class="s3">(*</span><span class="s1">bounding_box</span><span class="s3">) / </span><span class="s5">2.0</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">shape_type </span><span class="s3">== </span><span class="s4">'SPHERE'</span><span class="s3">:</span>
            <span class="s1">shape </span><span class="s3">= </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">BulletSphereShape</span><span class="s3">(</span><span class="s1">max</span><span class="s3">(</span><span class="s1">bounding_box</span><span class="s3">) / </span><span class="s5">2.0</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">shape_type </span><span class="s3">== </span><span class="s4">'CAPSULE'</span><span class="s3">:</span>
            <span class="s1">shape </span><span class="s3">= </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">BulletCapsuleShape</span><span class="s3">(</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">height </span><span class="s3">- </span><span class="s5">2.0 </span><span class="s3">* </span><span class="s1">radius</span><span class="s3">, </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">ZUp</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">shape_type </span><span class="s3">== </span><span class="s4">'CYLINDER'</span><span class="s3">:</span>
            <span class="s1">shape </span><span class="s3">= </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">BulletCylinderShape</span><span class="s3">(</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">height</span><span class="s3">, </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">ZUp</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">shape_type </span><span class="s3">== </span><span class="s4">'CONE'</span><span class="s3">:</span>
            <span class="s1">shape </span><span class="s3">= </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">BulletConeShape</span><span class="s3">(</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">height</span><span class="s3">, </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">ZUp</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">shape_type </span><span class="s3">== </span><span class="s4">'CONVEX_HULL'</span><span class="s3">:</span>
            <span class="s0">if </span><span class="s1">geomnode</span><span class="s3">:</span>
                <span class="s1">shape </span><span class="s3">= </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">BulletConvexHullShape</span><span class="s3">()</span>

                <span class="s0">for </span><span class="s1">geom </span><span class="s0">in </span><span class="s1">geomnode</span><span class="s3">.</span><span class="s1">get_geoms</span><span class="s3">():</span>
                    <span class="s1">shape</span><span class="s3">.</span><span class="s1">add_geom</span><span class="s3">(</span><span class="s1">geom</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">shape_type </span><span class="s3">== </span><span class="s4">'MESH'</span><span class="s3">:</span>
            <span class="s0">if </span><span class="s1">geomnode</span><span class="s3">:</span>
                <span class="s1">mesh </span><span class="s3">= </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">BulletTriangleMesh</span><span class="s3">()</span>
                <span class="s0">for </span><span class="s1">geom </span><span class="s0">in </span><span class="s1">geomnode</span><span class="s3">.</span><span class="s1">get_geoms</span><span class="s3">():</span>
                    <span class="s1">mesh</span><span class="s3">.</span><span class="s1">add_geom</span><span class="s3">(</span><span class="s1">geom</span><span class="s3">)</span>
                <span class="s1">shape </span><span class="s3">= </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">BulletTriangleMeshShape</span><span class="s3">(</span><span class="s1">mesh</span><span class="s3">, </span><span class="s1">dynamic</span><span class="s3">=</span><span class="s0">not </span><span class="s1">static</span><span class="s3">)</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Unknown collision shape ({}) for object ({})&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">shape_type</span><span class="s3">, </span><span class="s1">node_name</span><span class="s3">))</span>

        <span class="s0">if </span><span class="s1">shape </span><span class="s0">is not None</span><span class="s3">:</span>
            <span class="s0">if </span><span class="s1">intangible</span><span class="s3">:</span>
                <span class="s1">phynode </span><span class="s3">= </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">BulletGhostNode</span><span class="s3">(</span><span class="s1">node_name</span><span class="s3">)</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">phynode </span><span class="s3">= </span><span class="s1">bullet</span><span class="s3">.</span><span class="s1">BulletRigidBodyNode</span><span class="s3">(</span><span class="s1">node_name</span><span class="s3">)</span>
            <span class="s1">phynode</span><span class="s3">.</span><span class="s1">add_shape</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s0">if not </span><span class="s1">static</span><span class="s3">:</span>
                <span class="s1">mass </span><span class="s3">= </span><span class="s5">1.0 </span><span class="s0">if </span><span class="s1">gltf_rigidbody </span><span class="s0">is None else </span><span class="s1">gltf_rigidbody</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'mass'</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">)</span>
                <span class="s1">phynode</span><span class="s3">.</span><span class="s1">set_mass</span><span class="s3">(</span><span class="s1">mass</span><span class="s3">)</span>
            <span class="s0">return </span><span class="s1">phynode</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Could not create collision shape for object ({})&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">node_name</span><span class="s3">))</span>

    <span class="s0">def </span><span class="s1">load_physics_builtin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node_name</span><span class="s3">, </span><span class="s1">geomnode</span><span class="s3">, </span><span class="s1">shape_type</span><span class="s3">, </span><span class="s1">bounding_box</span><span class="s3">, </span><span class="s1">radius</span><span class="s3">, </span><span class="s1">height</span><span class="s3">, </span><span class="s1">intangible</span><span class="s3">):</span>
        <span class="s1">phynode </span><span class="s3">= </span><span class="s1">CollisionNode</span><span class="s3">(</span><span class="s1">node_name</span><span class="s3">)</span>

        <span class="s1">solids </span><span class="s3">= []</span>

        <span class="s0">if </span><span class="s1">shape_type </span><span class="s3">== </span><span class="s4">'BOX'</span><span class="s3">:</span>
            <span class="s1">solids</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">CollisionBox</span><span class="s3">(</span><span class="s1">Point3</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">), *</span><span class="s1">LVector3</span><span class="s3">(*</span><span class="s1">bounding_box</span><span class="s3">) / </span><span class="s5">2.0</span><span class="s3">))</span>
        <span class="s0">elif </span><span class="s1">shape_type </span><span class="s3">== </span><span class="s4">'SPHERE'</span><span class="s3">:</span>
            <span class="s1">solids</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">CollisionSphere</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">radius</span><span class="s3">))</span>
        <span class="s0">elif </span><span class="s1">shape_type </span><span class="s0">in </span><span class="s3">(</span><span class="s4">'CAPSULE'</span><span class="s3">, </span><span class="s4">'CYLINDER'</span><span class="s3">, </span><span class="s4">'CONE'</span><span class="s3">):</span>
            <span class="s0">if </span><span class="s1">shape_type </span><span class="s3">!= </span><span class="s4">'CAPSULE'</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span>
                    <span class="s4">'Warning: builtin collisions do not support shape type {} for object {}, falling back to {}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                        <span class="s1">shape_type</span><span class="s3">,</span>
                        <span class="s1">node_name</span><span class="s3">,</span>
                        <span class="s4">'CAPSULE'</span>
                    <span class="s3">))</span>
            <span class="s1">half_height </span><span class="s3">= </span><span class="s1">height </span><span class="s3">/ </span><span class="s5">2.0 </span><span class="s3">- </span><span class="s1">radius</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">LPoint3</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s1">half_height</span><span class="s3">)</span>
            <span class="s1">end </span><span class="s3">= </span><span class="s1">LPoint3</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">half_height</span><span class="s3">)</span>
            <span class="s1">solids</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">CollisionCapsule</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">radius</span><span class="s3">))</span>
        <span class="s0">elif </span><span class="s1">shape_type </span><span class="s0">in </span><span class="s3">(</span><span class="s4">'MESH'</span><span class="s3">, </span><span class="s4">'CONVEX_HULL'</span><span class="s3">):</span>
            <span class="s0">if </span><span class="s1">shape_type </span><span class="s3">!= </span><span class="s4">'MESH'</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span>
                    <span class="s4">'Warning: builtin collisions do not support shape type {} for object {}, falling back to {}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                        <span class="s1">shape_type</span><span class="s3">,</span>
                        <span class="s1">node_name</span><span class="s3">,</span>
                        <span class="s4">'MESH'</span>
                    <span class="s3">))</span>
            <span class="s0">if </span><span class="s1">geomnode</span><span class="s3">:</span>
                <span class="s0">for </span><span class="s1">geom </span><span class="s0">in </span><span class="s1">geomnode</span><span class="s3">.</span><span class="s1">get_geoms</span><span class="s3">():</span>
                    <span class="s1">vdata </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">read_vert_data</span><span class="s3">(</span><span class="s1">geom</span><span class="s3">.</span><span class="s1">get_vertex_data</span><span class="s3">(), </span><span class="s1">InternalName</span><span class="s3">.</span><span class="s1">get_vertex</span><span class="s3">())</span>
                    <span class="s1">polygons </span><span class="s3">= []</span>
                    <span class="s1">triangle_map </span><span class="s3">= {}</span>

                    <span class="s0">for </span><span class="s1">prim </span><span class="s0">in </span><span class="s1">geom</span><span class="s3">.</span><span class="s1">primitives</span><span class="s3">:</span>
                        <span class="s1">prim_tmp </span><span class="s3">= </span><span class="s1">prim</span><span class="s3">.</span><span class="s1">decompose</span><span class="s3">()</span>

                        <span class="s1">vertices </span><span class="s3">= </span><span class="s1">prim_tmp</span><span class="s3">.</span><span class="s1">get_vertex_list</span><span class="s3">()</span>
                        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">vertices</span><span class="s3">), </span><span class="s5">3</span><span class="s3">):</span>
                            <span class="s1">pos0 </span><span class="s3">= </span><span class="s1">vdata</span><span class="s3">[</span><span class="s1">vertices</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]].</span><span class="s1">xyz</span>
                            <span class="s1">pos1 </span><span class="s3">= </span><span class="s1">vdata</span><span class="s3">[</span><span class="s1">vertices</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]].</span><span class="s1">xyz</span>
                            <span class="s1">pos2 </span><span class="s3">= </span><span class="s1">vdata</span><span class="s3">[</span><span class="s1">vertices</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">2</span><span class="s3">]].</span><span class="s1">xyz</span>

                            <span class="s2"># Find adjacent triangles lying on the same plane.</span>
                            <span class="s1">normal </span><span class="s3">= (</span><span class="s1">pos2 </span><span class="s3">- </span><span class="s1">pos0</span><span class="s3">).</span><span class="s1">cross</span><span class="s3">(</span><span class="s1">pos1 </span><span class="s3">- </span><span class="s1">pos0</span><span class="s3">)</span>
                            <span class="s0">if not </span><span class="s1">normal</span><span class="s3">.</span><span class="s1">normalize</span><span class="s3">():</span>
                                <span class="s2"># Zero-area triangle.</span>
                                <span class="s0">continue</span>

                            <span class="s2"># Quantize the normal.</span>
                            <span class="s1">normal </span><span class="s3">= (</span><span class="s1">int</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s5">0x1000 </span><span class="s3">+ </span><span class="s5">0.5</span><span class="s3">),</span>
                                      <span class="s1">int</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s5">0x1000 </span><span class="s3">+ </span><span class="s5">0.5</span><span class="s3">),</span>
                                      <span class="s1">int</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] * </span><span class="s5">0x1000 </span><span class="s3">+ </span><span class="s5">0.5</span><span class="s3">))</span>

                            <span class="s1">key0 </span><span class="s3">= (</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos1</span><span class="s3">, </span><span class="s1">pos0</span><span class="s3">)</span>
                            <span class="s1">key1 </span><span class="s3">= (</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos2</span><span class="s3">, </span><span class="s1">pos1</span><span class="s3">)</span>
                            <span class="s1">key2 </span><span class="s3">= (</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos0</span><span class="s3">, </span><span class="s1">pos2</span><span class="s3">)</span>
                            <span class="s0">if </span><span class="s1">key0 </span><span class="s0">in </span><span class="s1">triangle_map</span><span class="s3">:</span>
                                <span class="s1">poly</span><span class="s3">, </span><span class="s1">pos3 </span><span class="s3">= </span><span class="s1">triangle_map</span><span class="s3">[</span><span class="s1">key0</span><span class="s3">]</span>
                                <span class="s1">quad </span><span class="s3">= (</span><span class="s1">pos0</span><span class="s3">, </span><span class="s1">pos3</span><span class="s3">, </span><span class="s1">pos1</span><span class="s3">, </span><span class="s1">pos2</span><span class="s3">)</span>
                                <span class="s0">if </span><span class="s1">CollisionPolygon</span><span class="s3">.</span><span class="s1">verify_points</span><span class="s3">(*</span><span class="s1">quad</span><span class="s3">) </span><span class="s0">and </span><span class="s1">\</span>
                                   <span class="s0">not </span><span class="s1">CollisionPolygon</span><span class="s3">(*</span><span class="s1">quad</span><span class="s3">).</span><span class="s1">is_concave</span><span class="s3">():</span>
                                    <span class="s1">poly</span><span class="s3">[:] = </span><span class="s1">quad</span>
                                    <span class="s0">del </span><span class="s1">triangle_map</span><span class="s3">[</span><span class="s1">key0</span><span class="s3">]</span>
                                    <span class="s0">del </span><span class="s1">triangle_map</span><span class="s3">[(</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos0</span><span class="s3">, </span><span class="s1">pos3</span><span class="s3">)]</span>
                                    <span class="s0">del </span><span class="s1">triangle_map</span><span class="s3">[(</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos3</span><span class="s3">, </span><span class="s1">pos1</span><span class="s3">)]</span>
                                    <span class="s0">continue</span>

                            <span class="s0">if </span><span class="s1">key1 </span><span class="s0">in </span><span class="s1">triangle_map</span><span class="s3">:</span>
                                <span class="s1">poly</span><span class="s3">, </span><span class="s1">pos3 </span><span class="s3">= </span><span class="s1">triangle_map</span><span class="s3">[</span><span class="s1">key1</span><span class="s3">]</span>
                                <span class="s1">quad </span><span class="s3">= (</span><span class="s1">pos1</span><span class="s3">, </span><span class="s1">pos3</span><span class="s3">, </span><span class="s1">pos2</span><span class="s3">, </span><span class="s1">pos0</span><span class="s3">)</span>
                                <span class="s0">if </span><span class="s1">CollisionPolygon</span><span class="s3">.</span><span class="s1">verify_points</span><span class="s3">(*</span><span class="s1">quad</span><span class="s3">) </span><span class="s0">and </span><span class="s1">\</span>
                                   <span class="s0">not </span><span class="s1">CollisionPolygon</span><span class="s3">(*</span><span class="s1">quad</span><span class="s3">).</span><span class="s1">is_concave</span><span class="s3">():</span>
                                    <span class="s1">poly</span><span class="s3">[:] = </span><span class="s1">quad</span>
                                    <span class="s0">del </span><span class="s1">triangle_map</span><span class="s3">[</span><span class="s1">key1</span><span class="s3">]</span>
                                    <span class="s0">del </span><span class="s1">triangle_map</span><span class="s3">[(</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos1</span><span class="s3">, </span><span class="s1">pos3</span><span class="s3">)]</span>
                                    <span class="s0">del </span><span class="s1">triangle_map</span><span class="s3">[(</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos3</span><span class="s3">, </span><span class="s1">pos2</span><span class="s3">)]</span>
                                    <span class="s0">continue</span>

                            <span class="s0">if </span><span class="s1">key2 </span><span class="s0">in </span><span class="s1">triangle_map</span><span class="s3">:</span>
                                <span class="s1">poly</span><span class="s3">, </span><span class="s1">pos3 </span><span class="s3">= </span><span class="s1">triangle_map</span><span class="s3">[</span><span class="s1">key2</span><span class="s3">]</span>
                                <span class="s1">quad </span><span class="s3">= (</span><span class="s1">pos2</span><span class="s3">, </span><span class="s1">pos3</span><span class="s3">, </span><span class="s1">pos0</span><span class="s3">, </span><span class="s1">pos1</span><span class="s3">)</span>
                                <span class="s0">if </span><span class="s1">CollisionPolygon</span><span class="s3">.</span><span class="s1">verify_points</span><span class="s3">(*</span><span class="s1">quad</span><span class="s3">) </span><span class="s0">and </span><span class="s1">\</span>
                                   <span class="s0">not </span><span class="s1">CollisionPolygon</span><span class="s3">(*</span><span class="s1">quad</span><span class="s3">).</span><span class="s1">is_concave</span><span class="s3">():</span>
                                    <span class="s1">poly</span><span class="s3">[:] = </span><span class="s1">quad</span>
                                    <span class="s0">del </span><span class="s1">triangle_map</span><span class="s3">[</span><span class="s1">key2</span><span class="s3">]</span>
                                    <span class="s0">del </span><span class="s1">triangle_map</span><span class="s3">[(</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos2</span><span class="s3">, </span><span class="s1">pos3</span><span class="s3">)]</span>
                                    <span class="s0">del </span><span class="s1">triangle_map</span><span class="s3">[(</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos3</span><span class="s3">, </span><span class="s1">pos0</span><span class="s3">)]</span>
                                    <span class="s0">continue</span>

                            <span class="s0">if </span><span class="s1">triangle_map</span><span class="s3">.</span><span class="s1">get</span><span class="s3">((</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos0</span><span class="s3">, </span><span class="s1">pos1</span><span class="s3">), (</span><span class="s0">None</span><span class="s3">, </span><span class="s0">None</span><span class="s3">))[</span><span class="s5">1</span><span class="s3">] != </span><span class="s1">pos2</span><span class="s3">:</span>
                                <span class="s1">poly </span><span class="s3">= [</span><span class="s1">pos0</span><span class="s3">, </span><span class="s1">pos1</span><span class="s3">, </span><span class="s1">pos2</span><span class="s3">]</span>
                                <span class="s1">triangle_map</span><span class="s3">[(</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos0</span><span class="s3">, </span><span class="s1">pos1</span><span class="s3">)] = (</span><span class="s1">poly</span><span class="s3">, </span><span class="s1">pos2</span><span class="s3">)</span>
                                <span class="s1">triangle_map</span><span class="s3">[(</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos1</span><span class="s3">, </span><span class="s1">pos2</span><span class="s3">)] = (</span><span class="s1">poly</span><span class="s3">, </span><span class="s1">pos0</span><span class="s3">)</span>
                                <span class="s1">triangle_map</span><span class="s3">[(</span><span class="s1">normal</span><span class="s3">, </span><span class="s1">pos2</span><span class="s3">, </span><span class="s1">pos0</span><span class="s3">)] = (</span><span class="s1">poly</span><span class="s3">, </span><span class="s1">pos1</span><span class="s3">)</span>
                                <span class="s1">polygons</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">poly</span><span class="s3">)</span>

                    <span class="s1">solids</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">CollisionPolygon</span><span class="s3">(*</span><span class="s1">poly</span><span class="s3">) </span><span class="s0">for </span><span class="s1">poly </span><span class="s0">in </span><span class="s1">polygons</span><span class="s3">)</span>

        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Unknown collision shape ({}) for object ({})&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">shape_type</span><span class="s3">, </span><span class="s1">node_name</span><span class="s3">))</span>

        <span class="s0">for </span><span class="s1">solid </span><span class="s0">in </span><span class="s1">solids</span><span class="s3">:</span>
            <span class="s0">if </span><span class="s1">intangible</span><span class="s3">:</span>
                <span class="s1">solid</span><span class="s3">.</span><span class="s1">set_tangible</span><span class="s3">(</span><span class="s0">False</span><span class="s3">)</span>
            <span class="s1">phynode</span><span class="s3">.</span><span class="s1">add_solid</span><span class="s3">(</span><span class="s1">solid</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s1">phynode</span><span class="s3">.</span><span class="s1">solids</span><span class="s3">:</span>
            <span class="s0">return </span><span class="s1">phynode</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Could not create collision shape for object ({})&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">node_name</span><span class="s3">))</span>
</pre>
</body>
</html>