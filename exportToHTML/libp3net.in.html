<html>
<head>
<title>libp3net.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3net.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">8 libp3net 4 7xrj 12 panda3d.core </span>
<span class="s0">175</span>
<span class="s0">169 5 clear 0 4 345 34 PointerToBase&lt; Connection &gt;::clear 0 1 10 0</span>
<span class="s0">53</span>
<span class="s0">inline void PointerToBase&lt; Connection &gt;::clear(void);</span>

<span class="s0">170 6 output 0 4 345 35 PointerToBase&lt; Connection &gt;::output 0 1 11 0</span>
<span class="s0">66</span>
<span class="s0">void PointerToBase&lt; Connection &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">171 9 PointerTo 0 260 344 34 PointerTo&lt; Connection &gt;::PointerTo 0 4 1 2 3 4 0</span>
<span class="s0">317</span>
<span class="s0">inline constexpr PointerTo&lt; Connection &gt;::PointerTo(void) noexcept = default;</span>
<span class="s0">inline explicit constexpr PointerTo&lt; Connection &gt;::PointerTo(decltype(nullptr) ) noexcept;</span>
<span class="s0">inline PointerTo&lt; Connection &gt;::PointerTo(Connection *ptr) noexcept;</span>
<span class="s0">inline PointerTo&lt; Connection &gt;::PointerTo(PointerTo&lt; Connection &gt; const &amp;copy);</span>

<span class="s0">172 1 p 0 4 344 26 PointerTo&lt; Connection &gt;::p 0 1 5 289</span>
<span class="s0">// If your base class is a derivative of TypedObject, you might want to use</span>
<span class="s0">// the DCAST macro defined in typedObject.h instead, e.g.  DCAST(MyType,</span>
<span class="s0">// ptr).  This provides a clean downcast that doesn't require .p() or any</span>
<span class="s0">// double-casting, and it can be run-time checked for correctness.</span>
<span class="s0">70</span>
<span class="s0">constexpr Connection *PointerTo&lt; Connection &gt;::p(void) const noexcept;</span>

<span class="s0">173 10 operator = 0 4 344 35 PointerTo&lt; Connection &gt;::operator = 0 2 6 7 0</span>
<span class="s0">151</span>
<span class="s0">inline void PointerTo&lt; Connection &gt;::operator =(Connection *ptr);</span>
<span class="s0">inline void PointerTo&lt; Connection &gt;::operator =(PointerTo&lt; Connection &gt; const &amp;copy);</span>

<span class="s0">174 7 is_null 0 4 344 32 PointerTo&lt; Connection &gt;::is_null 0 1 8 0</span>
<span class="s0">57</span>
<span class="s0">inline bool PointerTo&lt; Connection &gt;::is_null(void) const;</span>

<span class="s0">175 5 clear 0 4 344 30 PointerTo&lt; Connection &gt;::clear 0 1 9 0</span>
<span class="s0">49</span>
<span class="s0">inline void PointerTo&lt; Connection &gt;::clear(void);</span>

<span class="s0">176 10 ~PointerTo 0 516 344 35 PointerTo&lt; Connection &gt;::~PointerTo 0 0 0</span>
<span class="s0">42</span>
<span class="s0">PointerTo&lt; Connection &gt;::~PointerTo(void);</span>

<span class="s0">177 10 NetAddress 0 260 347 22 NetAddress::NetAddress 0 3 12 13 14 271</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an unspecified address.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs an address from a given Socket_Address.  Normally, this</span>
 <span class="s0">* constructor should not be used by user code; instead, create a default</span>
 <span class="s0">* NetAddress and use one of the set_*() functions to set up an address.</span>
 <span class="s0">*/</span>
<span class="s0">142</span>
<span class="s0">NetAddress::NetAddress(void);</span>
<span class="s0">NetAddress::NetAddress(Socket_Address const &amp;addr);</span>
<span class="s0">inline NetAddress::NetAddress(NetAddress const &amp;) = default;</span>

<span class="s0">178 7 set_any 0 4 347 19 NetAddress::set_any 0 1 15 179</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the address up to refer to a particular port, but not to any</span>
 <span class="s0">* particular IP.  Returns true if successful, false otherwise (currently,</span>
 <span class="s0">* this only returns true).</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">bool NetAddress::set_any(int port);</span>

<span class="s0">179 13 set_localhost 0 4 347 25 NetAddress::set_localhost 0 1 16 75</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the address up to refer to a particular port, on this host.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">bool NetAddress::set_localhost(int port);</span>

<span class="s0">180 13 set_broadcast 0 4 347 25 NetAddress::set_broadcast 0 1 17 53</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the address to the broadcast address.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">bool NetAddress::set_broadcast(int port);</span>

<span class="s0">181 8 set_host 0 4 347 20 NetAddress::set_host 0 1 18 141</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the address up to refer to a particular port on a particular host.</span>
 <span class="s0">* Returns true if the hostname is known, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">bool NetAddress::set_host(std::string const &amp;hostname, int port);</span>

<span class="s0">182 5 clear 0 4 347 17 NetAddress::clear 0 1 19 54</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the NetAddress to its initial state.</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">void NetAddress::clear(void);</span>

<span class="s0">183 8 get_port 0 4 347 20 NetAddress::get_port 0 1 20 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the port number to which this address refers.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">int NetAddress::get_port(void) const;</span>

<span class="s0">184 8 set_port 0 4 347 20 NetAddress::set_port 0 1 21 73</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the port number without otherwise changing the address.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void NetAddress::set_port(int port);</span>

<span class="s0">185 13 get_ip_string 0 4 347 25 NetAddress::get_ip_string 0 1 22 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the IP address to which this address refers, formatted as a string.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">std::string NetAddress::get_ip_string(void) const;</span>

<span class="s0">186 6 is_any 0 4 347 18 NetAddress::is_any 0 1 23 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the IP address has only zeroes.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">bool NetAddress::is_any(void) const;</span>

<span class="s0">187 6 get_ip 0 4 347 18 NetAddress::get_ip 0 1 24 158</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the IP address to which this address refers, as a 32-bit integer,</span>
 <span class="s0">* in host byte order.</span>
 <span class="s0">* @deprecated  Does not work with IPv6 addresses.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">uint32_t NetAddress::get_ip(void) const;</span>

<span class="s0">188 16 get_ip_component 0 4 347 28 NetAddress::get_ip_component 0 1 25 213</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth 8-bit component of the IP address.  An IP address has four</span>
 <span class="s0">* components; component 0 is the first (leftmost), and component 3 is the</span>
 <span class="s0">* last (rightmost) in the dotted number convention.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">uint8_t NetAddress::get_ip_component(int n) const;</span>

<span class="s0">189 8 get_addr 0 4 347 20 NetAddress::get_addr 0 1 26 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Socket_Address for this address.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">Socket_Address const &amp;NetAddress::get_addr(void) const;</span>

<span class="s0">190 6 output 0 4 347 18 NetAddress::output 0 1 27 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void NetAddress::output(std::ostream &amp;out) const;</span>

<span class="s0">191 8 get_hash 0 4 347 20 NetAddress::get_hash 0 1 28 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">std::size_t NetAddress::get_hash(void) const;</span>

<span class="s0">192 11 operator == 0 4 347 23 NetAddress::operator == 0 1 29 0</span>
<span class="s0">60</span>
<span class="s0">bool NetAddress::operator ==(NetAddress const &amp;other) const;</span>

<span class="s0">193 11 operator != 0 4 347 23 NetAddress::operator != 0 1 30 0</span>
<span class="s0">60</span>
<span class="s0">bool NetAddress::operator !=(NetAddress const &amp;other) const;</span>

<span class="s0">194 11 ~NetAddress 0 516 347 23 NetAddress::~NetAddress 0 0 0</span>
<span class="s0">30</span>
<span class="s0">NetAddress::~NetAddress(void);</span>

<span class="s0">195 10 Connection 0 260 348 22 Connection::Connection 0 1 31 177</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a connection.  Normally this constructor should not be used</span>
 <span class="s0">* directly by user code; use one of the methods in ConnectionManager to make</span>
 <span class="s0">* a new connection.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">explicit Connection::Connection(ConnectionManager *manager, Socket_IP *socket);</span>

<span class="s0">196 11 get_address 0 4 348 23 Connection::get_address 0 1 32 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the address bound to this connection, if it is a TCP connection.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">NetAddress Connection::get_address(void) const;</span>

<span class="s0">197 11 get_manager 0 4 348 23 Connection::get_manager 0 1 33 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the ConnectionManager object that serves this</span>
 <span class="s0">* connection.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">ConnectionManager *Connection::get_manager(void) const;</span>

<span class="s0">198 10 get_socket 0 4 348 22 Connection::get_socket 0 1 34 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the internal Socket_IP that defines the connection.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">Socket_IP *Connection::get_socket(void) const;</span>

<span class="s0">199 15 set_collect_tcp 0 4 348 27 Connection::set_collect_tcp 0 1 35 719</span>
<span class="s0">/**</span>
 <span class="s0">* Enables or disables &quot;collect-tcp&quot; mode.  In this mode, individual TCP</span>
 <span class="s0">* packets are not sent immediately, but rather they are collected together</span>
 <span class="s0">* and accumulated to be sent periodically as one larger TCP packet.  This</span>
 <span class="s0">* cuts down on overhead from the TCP/IP protocol, especially if many small</span>
 <span class="s0">* packets need to be sent on the same connection, but it introduces</span>
 <span class="s0">* additional latency (since packets must be held before they can be sent).</span>
 <span class="s0">*</span>
 <span class="s0">* See set_collect_tcp_interval() to specify the interval of time for which to</span>
 <span class="s0">* hold packets before sending them.</span>
 <span class="s0">*</span>
 <span class="s0">* If you enable this mode, you may also need to periodically call</span>
 <span class="s0">* consider_flush() to flush the queue if no packets have been sent recently.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void Connection::set_collect_tcp(bool collect_tcp);</span>

<span class="s0">200 15 get_collect_tcp 0 4 348 27 Connection::get_collect_tcp 0 1 36 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of &quot;collect-tcp&quot; mode.  See set_collect_tcp().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">bool Connection::get_collect_tcp(void) const;</span>

<span class="s0">201 24 set_collect_tcp_interval 0 4 348 36 Connection::set_collect_tcp_interval 0 1 37 231</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the interval in time, in seconds, for which to hold TCP packets</span>
 <span class="s0">* before sending all of the recently received packets at once.  This only has</span>
 <span class="s0">* meaning if &quot;collect-tcp&quot; mode is enabled; see set_collect_tcp().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void Connection::set_collect_tcp_interval(double interval);</span>

<span class="s0">202 24 get_collect_tcp_interval 0 4 348 36 Connection::get_collect_tcp_interval 0 1 38 229</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the interval in time, in seconds, for which to hold TCP packets</span>
 <span class="s0">* before sending all of the recently received packets at once.  This only has</span>
 <span class="s0">* meaning if &quot;collect-tcp&quot; mode is enabled; see set_collect_tcp().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">double Connection::get_collect_tcp_interval(void) const;</span>

<span class="s0">203 14 consider_flush 0 4 348 26 Connection::consider_flush 0 1 39 153</span>
<span class="s0">/**</span>
 <span class="s0">* Sends the most recently queued TCP datagram(s) if enough time has elapsed.</span>
 <span class="s0">* This only has meaning if set_collect_tcp() has been set to true.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">bool Connection::consider_flush(void);</span>

<span class="s0">204 5 flush 0 4 348 17 Connection::flush 0 1 40 131</span>
<span class="s0">/**</span>
 <span class="s0">* Sends the most recently queued TCP datagram(s) now.  This only has meaning</span>
 <span class="s0">* if set_collect_tcp() has been set to true.</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">bool Connection::flush(void);</span>

<span class="s0">205 10 set_linger 0 4 348 22 Connection::set_linger 0 1 41 467</span>
<span class="s0">// Socket options.  void set_nonblock(bool flag);</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the time to linger on close if data is present.  If flag is false,</span>
 <span class="s0">* when you close a socket with data available the system attempts to deliver</span>
 <span class="s0">* the data to the peer (the default behavior).  If flag is false but time is</span>
 <span class="s0">* zero, the system discards any undelivered data when you close the socket.</span>
 <span class="s0">* If flag is false but time is nonzero, the system waits up to time seconds</span>
 <span class="s0">* to deliver the data.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void Connection::set_linger(bool flag, double time);</span>

<span class="s0">206 14 set_reuse_addr 0 4 348 26 Connection::set_reuse_addr 0 1 42 55</span>
<span class="s0">/**</span>
 <span class="s0">* Sets whether local address reuse is allowed.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void Connection::set_reuse_addr(bool flag);</span>

<span class="s0">207 14 set_keep_alive 0 4 348 26 Connection::set_keep_alive 0 1 43 93</span>
<span class="s0">/**</span>
 <span class="s0">* Sets whether the connection is periodically tested to see if it is still</span>
 <span class="s0">* alive.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void Connection::set_keep_alive(bool flag);</span>

<span class="s0">208 20 set_recv_buffer_size 0 4 348 32 Connection::set_recv_buffer_size 0 1 44 57</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the size of the receive buffer, in bytes.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void Connection::set_recv_buffer_size(int size);</span>

<span class="s0">209 20 set_send_buffer_size 0 4 348 32 Connection::set_send_buffer_size 0 1 45 54</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the size of the send buffer, in bytes.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void Connection::set_send_buffer_size(int size);</span>

<span class="s0">210 19 set_ip_time_to_live 0 4 348 31 Connection::set_ip_time_to_live 0 1 46 32</span>
<span class="s0">/**</span>
 <span class="s0">* Sets IP time-to-live.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void Connection::set_ip_time_to_live(int ttl);</span>

<span class="s0">211 22 set_ip_type_of_service 0 4 348 34 Connection::set_ip_type_of_service 0 1 47 50</span>
<span class="s0">/**</span>
 <span class="s0">* Sets IP type-of-service and precedence.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void Connection::set_ip_type_of_service(int tos);</span>

<span class="s0">212 12 set_no_delay 0 4 348 24 Connection::set_no_delay 0 1 48 116</span>
<span class="s0">/**</span>
 <span class="s0">* If flag is true, this disables the Nagle algorithm, and prevents delaying</span>
 <span class="s0">* of send to coalesce packets.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void Connection::set_no_delay(bool flag);</span>

<span class="s0">213 15 set_max_segment 0 4 348 27 Connection::set_max_segment 0 1 49 41</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the maximum segment size.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void Connection::set_max_segment(int size);</span>

<span class="s0">214 17 ~ConnectionReader 0 518 350 35 ConnectionReader::~ConnectionReader 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">virtual ConnectionReader::~ConnectionReader(void);</span>

<span class="s0">215 14 add_connection 0 4 350 32 ConnectionReader::add_connection 0 1 50 504</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new socket to the list of sockets the ConnectionReader will monitor.</span>
 <span class="s0">* A datagram that comes in on any of the monitored sockets will be reported.</span>
 <span class="s0">* In the case of a ConnectionListener, this adds a new rendezvous socket; any</span>
 <span class="s0">* activity on any of the monitored sockets will cause a connection to be</span>
 <span class="s0">* accepted.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the connection was added, false if it was</span>
 <span class="s0">* already there.</span>
 <span class="s0">*</span>
 <span class="s0">* add_connection() is thread-safe, and may be called at will by any thread.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool ConnectionReader::add_connection(Connection *connection);</span>

<span class="s0">216 17 remove_connection 0 4 350 35 ConnectionReader::remove_connection 0 1 51 264</span>
<span class="s0">/**</span>
 <span class="s0">* Removes a socket from the list of sockets being monitored.  Returns true if</span>
 <span class="s0">* the socket was correctly removed, false if it was not on the list in the</span>
 <span class="s0">* first place.</span>
 <span class="s0">*</span>
 <span class="s0">* remove_connection() is thread-safe, and may be called at will by any</span>
 <span class="s0">* thread.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">bool ConnectionReader::remove_connection(Connection *connection);</span>

<span class="s0">217 16 is_connection_ok 0 4 350 34 ConnectionReader::is_connection_ok 0 1 52 345</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated connection has been added to the</span>
 <span class="s0">* ConnectionReader and is being monitored properly, false if it is not known,</span>
 <span class="s0">* or if there was some error condition detected on the connection.  (If there</span>
 <span class="s0">* was an error condition, normally the ConnectionManager would have been</span>
 <span class="s0">* informed and closed the connection.)</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">bool ConnectionReader::is_connection_ok(Connection *connection);</span>

<span class="s0">218 4 poll 0 4 350 22 ConnectionReader::poll 0 1 53 328</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly polls the available sockets to see if any of them have any</span>
 <span class="s0">* noise.  This function does nothing unless this is a polling-type</span>
 <span class="s0">* ConnectionReader, i.e.  it was created with zero threads (and is_polling()</span>
 <span class="s0">* will return true).</span>
 <span class="s0">*</span>
 <span class="s0">* It is not necessary to call this explicitly for a QueuedConnectionReader.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">void ConnectionReader::poll(void);</span>

<span class="s0">219 11 get_manager 0 4 350 29 ConnectionReader::get_manager 0 1 54 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the ConnectionManager object that serves this</span>
 <span class="s0">* ConnectionReader.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">ConnectionManager *ConnectionReader::get_manager(void) const;</span>

<span class="s0">220 10 is_polling 0 4 350 28 ConnectionReader::is_polling 0 1 55 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the reader is a polling reader, i.e.  it has no threads.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool ConnectionReader::is_polling(void) const;</span>

<span class="s0">221 15 get_num_threads 0 4 350 33 ConnectionReader::get_num_threads 0 1 56 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of threads the ConnectionReader has been created with.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">int ConnectionReader::get_num_threads(void) const;</span>

<span class="s0">222 12 set_raw_mode 0 4 350 30 ConnectionReader::set_raw_mode 0 1 57 314</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the ConnectionReader into raw mode (or turns off raw mode).  In raw</span>
 <span class="s0">* mode, datagram headers are not expected; instead, all the data available on</span>
 <span class="s0">* the pipe is treated as a single datagram.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to set_tcp_header_size(0), except that it also turns off</span>
 <span class="s0">* headers for UDP packets.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void ConnectionReader::set_raw_mode(bool mode);</span>

<span class="s0">223 12 get_raw_mode 0 4 350 30 ConnectionReader::get_raw_mode 0 1 58 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the raw mode flag.  See set_raw_mode().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool ConnectionReader::get_raw_mode(void) const;</span>

<span class="s0">224 19 set_tcp_header_size 0 4 350 37 ConnectionReader::set_tcp_header_size 0 1 59 270</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the header size of TCP packets.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void ConnectionReader::set_tcp_header_size(int tcp_header_size);</span>

<span class="s0">225 19 get_tcp_header_size 0 4 350 37 ConnectionReader::get_tcp_header_size 0 1 60 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of TCP header size.  See set_tcp_header_size().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">int ConnectionReader::get_tcp_header_size(void) const;</span>

<span class="s0">226 8 shutdown 0 4 350 26 ConnectionReader::shutdown 0 1 61 146</span>
<span class="s0">/**</span>
 <span class="s0">* Terminates all threads cleanly.  Normally this is only called by the</span>
 <span class="s0">* destructor, but it may be called explicitly before destruction.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void ConnectionReader::shutdown(void);</span>

<span class="s0">227 19 ~ConnectionListener 0 516 351 39 ConnectionListener::~ConnectionListener 0 0 0</span>
<span class="s0">46</span>
<span class="s0">ConnectionListener::~ConnectionListener(void);</span>

<span class="s0">228 11 NetDatagram 0 260 352 24 NetDatagram::NetDatagram 0 3 62 63 64 130</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an empty datagram.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a datagram from an existing block of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">192</span>
<span class="s0">NetDatagram::NetDatagram(void);</span>
<span class="s0">NetDatagram::NetDatagram(void const *data, std::size_t size);</span>
<span class="s0">NetDatagram::NetDatagram(Datagram const &amp;copy);</span>
<span class="s0">NetDatagram::NetDatagram(NetDatagram const &amp;copy);</span>

<span class="s0">229 10 operator = 0 4 352 23 NetDatagram::operator = 0 2 65 66 0</span>
<span class="s0">106</span>
<span class="s0">void NetDatagram::operator =(Datagram const &amp;copy);</span>
<span class="s0">void NetDatagram::operator =(NetDatagram const &amp;copy);</span>

<span class="s0">230 14 set_connection 0 4 352 27 NetDatagram::set_connection 0 1 67 72</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the socket to which the datagram should be written.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void NetDatagram::set_connection(PointerTo&lt; Connection &gt; const &amp;connection);</span>

<span class="s0">231 14 get_connection 0 4 352 27 NetDatagram::get_connection 0 1 68 111</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the socket from which the datagram was read, or to which it is</span>
 <span class="s0">* scheduled to be written.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">PointerTo&lt; Connection &gt; NetDatagram::get_connection(void) const;</span>

<span class="s0">232 11 set_address 0 4 352 24 NetDatagram::set_address 0 1 69 67</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the host to which the datagram should be sent.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void NetDatagram::set_address(NetAddress const &amp;address);</span>

<span class="s0">233 11 get_address 0 4 352 24 NetDatagram::get_address 0 1 70 106</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the host from which the datagram was read, or to which it is</span>
 <span class="s0">* scheduled to be sent.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">NetAddress const &amp;NetDatagram::get_address(void) const;</span>

<span class="s0">234 14 get_class_type 0 4 352 27 NetDatagram::get_class_type 0 1 71 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle NetDatagram::get_class_type(void);</span>

<span class="s0">235 12 ~NetDatagram 0 516 352 25 NetDatagram::~NetDatagram 0 0 0</span>
<span class="s0">32</span>
<span class="s0">NetDatagram::~NetDatagram(void);</span>

<span class="s0">236 17 ConnectionManager 0 260 354 36 ConnectionManager::ConnectionManager 0 1 72 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">ConnectionManager::ConnectionManager(void);</span>

<span class="s0">237 18 ~ConnectionManager 0 518 354 37 ConnectionManager::~ConnectionManager 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">virtual ConnectionManager::~ConnectionManager(void);</span>

<span class="s0">238 19 open_UDP_connection 0 4 354 38 ConnectionManager::open_UDP_connection 0 2 73 74 1047</span>
<span class="s0">/**</span>
 <span class="s0">* Opens a socket for sending and/or receiving UDP packets.  If the port</span>
 <span class="s0">* number is greater than zero, the UDP connection will be opened for</span>
 <span class="s0">* listening on the indicated port; otherwise, it will be useful only for</span>
 <span class="s0">* sending.</span>
 <span class="s0">*</span>
 <span class="s0">* Use a ConnectionReader and ConnectionWriter to handle the actual</span>
 <span class="s0">* communication.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Opens a socket for sending and/or receiving UDP packets.  If the port</span>
 <span class="s0">* number is greater than zero, the UDP connection will be opened for</span>
 <span class="s0">* listening on the indicated port; otherwise, it will be useful only for</span>
 <span class="s0">* sending.</span>
 <span class="s0">*</span>
 <span class="s0">* This variant accepts both a hostname and port to listen on a particular</span>
 <span class="s0">* interface; if the hostname is empty, all interfaces will be available,</span>
 <span class="s0">* both IPv4 and IPv6.</span>
 <span class="s0">*</span>
 <span class="s0">* If for_broadcast is true, this UDP connection will be configured to send</span>
 <span class="s0">* and/or receive messages on the broadcast address (255.255.255.255);</span>
 <span class="s0">* otherwise, these messages may be automatically filtered by the OS.</span>
 <span class="s0">*</span>
 <span class="s0">* Use a ConnectionReader and ConnectionWriter to handle the actual</span>
 <span class="s0">* communication.</span>
 <span class="s0">*/</span>
<span class="s0">218</span>
<span class="s0">PointerTo&lt; Connection &gt; ConnectionManager::open_UDP_connection(uint16_t port = 0);</span>
<span class="s0">PointerTo&lt; Connection &gt; ConnectionManager::open_UDP_connection(std::string const &amp;hostname, uint16_t port, bool for_broadcast = false);</span>

<span class="s0">239 26 open_TCP_server_rendezvous 0 4 354 45 ConnectionManager::open_TCP_server_rendezvous 0 3 75 76 77 1436</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a socket to be used as a rendezvous socket for a server to listen</span>
 <span class="s0">* for TCP connections.  The socket returned by this call should only be added</span>
 <span class="s0">* to a ConnectionListener (not to a generic ConnectionReader).</span>
 <span class="s0">*</span>
 <span class="s0">* This variant of this method accepts a single port, and will listen to that</span>
 <span class="s0">* port on all available interfaces, both IPv4 and IPv6.</span>
 <span class="s0">*</span>
 <span class="s0">* backlog is the maximum length of the queue of pending connections.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a socket to be used as a rendezvous socket for a server to listen</span>
 <span class="s0">* for TCP connections.  The socket returned by this call should only be added</span>
 <span class="s0">* to a ConnectionListener (not to a generic ConnectionReader).</span>
 <span class="s0">*</span>
 <span class="s0">* This variant of this method accepts a &quot;hostname&quot;, which is usually just an</span>
 <span class="s0">* IP address in dotted notation, and a port number.  It will listen on the</span>
 <span class="s0">* interface indicated by the IP address.  If the IP address is empty string,</span>
 <span class="s0">* it will listen on all interfaces.</span>
 <span class="s0">*</span>
 <span class="s0">* backlog is the maximum length of the queue of pending connections.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a socket to be used as a rendezvous socket for a server to listen</span>
 <span class="s0">* for TCP connections.  The socket returned by this call should only be added</span>
 <span class="s0">* to a ConnectionListener (not to a generic ConnectionReader).</span>
 <span class="s0">*</span>
 <span class="s0">* This variant of this method accepts a NetAddress, which allows you to</span>
 <span class="s0">* specify a specific interface to listen to.</span>
 <span class="s0">*</span>
 <span class="s0">* backlog is the maximum length of the queue of pending connections.</span>
 <span class="s0">*/</span>
<span class="s0">337</span>
<span class="s0">PointerTo&lt; Connection &gt; ConnectionManager::open_TCP_server_rendezvous(uint16_t port, int backlog);</span>
<span class="s0">PointerTo&lt; Connection &gt; ConnectionManager::open_TCP_server_rendezvous(std::string const &amp;hostname, uint16_t port, int backlog);</span>
<span class="s0">PointerTo&lt; Connection &gt; ConnectionManager::open_TCP_server_rendezvous(NetAddress const &amp;address, int backlog);</span>

<span class="s0">240 26 open_TCP_client_connection 0 4 354 45 ConnectionManager::open_TCP_client_connection 0 2 78 79 323</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to establish a TCP client connection to a server at the indicated</span>
 <span class="s0">* address.  If the connection is not established within timeout_ms</span>
 <span class="s0">* milliseconds, a null connection is returned.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This is a shorthand version of the function to directly establish</span>
 <span class="s0">* communications to a named host and port.</span>
 <span class="s0">*/</span>
<span class="s0">244</span>
<span class="s0">PointerTo&lt; Connection &gt; ConnectionManager::open_TCP_client_connection(NetAddress const &amp;address, int timeout_ms);</span>
<span class="s0">PointerTo&lt; Connection &gt; ConnectionManager::open_TCP_client_connection(std::string const &amp;hostname, uint16_t port, int timeout_ms);</span>

<span class="s0">241 16 close_connection 0 4 354 35 ConnectionManager::close_connection 0 1 80 693</span>
<span class="s0">/**</span>
 <span class="s0">* Terminates a UDP or TCP socket previously opened.  This also removes it</span>
 <span class="s0">* from any associated ConnectionReader or ConnectionListeners.</span>
 <span class="s0">*</span>
 <span class="s0">* The socket itself may not be immediately closed--it will not be closed</span>
 <span class="s0">* until all outstanding pointers to it are cleared, including any pointers</span>
 <span class="s0">* remaining in NetDatagrams recently received from the socket.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the connection was marked to be closed, or</span>
 <span class="s0">* false if close_connection() had already been called (or the connection did</span>
 <span class="s0">* not belong to this ConnectionManager).  In neither case can you infer</span>
 <span class="s0">* anything about whether the connection has *actually* been closed yet based</span>
 <span class="s0">* on the return value.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">bool ConnectionManager::close_connection(PointerTo&lt; Connection &gt; const &amp;connection);</span>

<span class="s0">242 16 wait_for_readers 0 4 354 35 ConnectionManager::wait_for_readers 0 1 81 664</span>
<span class="s0">/**</span>
 <span class="s0">* Blocks the process for timeout number of seconds, or until any data is</span>
 <span class="s0">* available on any of the non-threaded ConnectionReaders or</span>
 <span class="s0">* ConnectionListeners, whichever comes first.  The return value is true if</span>
 <span class="s0">* there is data available (but you have to iterate through all readers to</span>
 <span class="s0">* find it), or false if the timeout occurred without any data.</span>
 <span class="s0">*</span>
 <span class="s0">* If the timeout value is negative, this will block forever or until data is</span>
 <span class="s0">* available.</span>
 <span class="s0">*</span>
 <span class="s0">* This only works if all ConnectionReaders and ConnectionListeners are non-</span>
 <span class="s0">* threaded.  If any threaded ConnectionReaders are part of the</span>
 <span class="s0">* ConnectionManager, the timeout value is implicitly treated as 0.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">bool ConnectionManager::wait_for_readers(double timeout);</span>

<span class="s0">243 13 get_host_name 0 4 354 32 ConnectionManager::get_host_name 0 1 82 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of this particular machine on the network, if available,</span>
 <span class="s0">* or the empty string if the hostname cannot be determined.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">static std::string ConnectionManager::get_host_name(void);</span>

<span class="s0">244 8 get_name 0 4 355 38 ConnectionManager::Interface::get_name 0 1 87 0</span>
<span class="s0">70</span>
<span class="s0">std::string const &amp;ConnectionManager::Interface::get_name(void) const;</span>

<span class="s0">245 15 get_mac_address 0 4 355 45 ConnectionManager::Interface::get_mac_address 0 1 88 0</span>
<span class="s0">77</span>
<span class="s0">std::string const &amp;ConnectionManager::Interface::get_mac_address(void) const;</span>

<span class="s0">246 6 has_ip 0 4 355 36 ConnectionManager::Interface::has_ip 0 1 89 0</span>
<span class="s0">54</span>
<span class="s0">bool ConnectionManager::Interface::has_ip(void) const;</span>

<span class="s0">247 6 get_ip 0 4 355 36 ConnectionManager::Interface::get_ip 0 1 90 0</span>
<span class="s0">67</span>
<span class="s0">NetAddress const &amp;ConnectionManager::Interface::get_ip(void) const;</span>

<span class="s0">248 11 has_netmask 0 4 355 41 ConnectionManager::Interface::has_netmask 0 1 91 0</span>
<span class="s0">59</span>
<span class="s0">bool ConnectionManager::Interface::has_netmask(void) const;</span>

<span class="s0">249 11 get_netmask 0 4 355 41 ConnectionManager::Interface::get_netmask 0 1 92 0</span>
<span class="s0">72</span>
<span class="s0">NetAddress const &amp;ConnectionManager::Interface::get_netmask(void) const;</span>

<span class="s0">250 13 has_broadcast 0 4 355 43 ConnectionManager::Interface::has_broadcast 0 1 93 0</span>
<span class="s0">61</span>
<span class="s0">bool ConnectionManager::Interface::has_broadcast(void) const;</span>

<span class="s0">251 13 get_broadcast 0 4 355 43 ConnectionManager::Interface::get_broadcast 0 1 94 0</span>
<span class="s0">74</span>
<span class="s0">NetAddress const &amp;ConnectionManager::Interface::get_broadcast(void) const;</span>

<span class="s0">252 7 has_p2p 0 4 355 37 ConnectionManager::Interface::has_p2p 0 1 95 0</span>
<span class="s0">55</span>
<span class="s0">bool ConnectionManager::Interface::has_p2p(void) const;</span>

<span class="s0">253 7 get_p2p 0 4 355 37 ConnectionManager::Interface::get_p2p 0 1 96 0</span>
<span class="s0">68</span>
<span class="s0">NetAddress const &amp;ConnectionManager::Interface::get_p2p(void) const;</span>

<span class="s0">254 6 output 0 4 355 36 ConnectionManager::Interface::output 0 1 97 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void ConnectionManager::Interface::output(std::ostream &amp;out) const;</span>

<span class="s0">255 9 Interface 0 260 355 39 ConnectionManager::Interface::Interface 0 1 86 0</span>
<span class="s0">95</span>
<span class="s0">inline ConnectionManager::Interface::Interface(ConnectionManager::Interface const &amp;) = default;</span>

<span class="s0">256 10 ~Interface 0 516 355 40 ConnectionManager::Interface::~Interface 0 0 0</span>
<span class="s0">47</span>
<span class="s0">ConnectionManager::Interface::~Interface(void);</span>

<span class="s0">257 15 scan_interfaces 0 4 354 34 ConnectionManager::scan_interfaces 0 1 83 258</span>
<span class="s0">/**</span>
 <span class="s0">* Repopulates the list reported by get_num_interface()/get_interface().  It</span>
 <span class="s0">* is not necessary to call this explicitly, unless you want to re-determine</span>
 <span class="s0">* the connected interfaces (for instance, if you suspect the hardware has</span>
 <span class="s0">* recently changed).</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void ConnectionManager::scan_interfaces(void);</span>

<span class="s0">258 18 get_num_interfaces 0 4 354 37 ConnectionManager::get_num_interfaces 0 1 84 140</span>
<span class="s0">/**</span>
 <span class="s0">* This returns the number of usable network interfaces detected on this</span>
 <span class="s0">* machine.  See scan_interfaces() to repopulate this list.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">std::size_t ConnectionManager::get_num_interfaces(void);</span>

<span class="s0">259 13 get_interface 0 4 354 32 ConnectionManager::get_interface 0 1 85 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth usable network interface detected on this machine.</span>
 <span class="s0">* See scan_interfaces() to repopulate this list.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">ConnectionManager::Interface const &amp;ConnectionManager::get_interface(std::size_t n);</span>

<span class="s0">260 16 ConnectionWriter 0 260 359 34 ConnectionWriter::ConnectionWriter 0 1 98 224</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new ConnectionWriter with the indicated number of threads to</span>
 <span class="s0">* handle output.</span>
 <span class="s0">*</span>
 <span class="s0">* If num_threads is 0, all datagrams will be sent immediately instead of</span>
 <span class="s0">* queueing for later transmission by a thread.</span>
 <span class="s0">*/</span>
<span class="s0">132</span>
<span class="s0">explicit ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, std::string const &amp;thread_name = string());</span>

<span class="s0">261 17 ~ConnectionWriter 0 516 359 35 ConnectionWriter::~ConnectionWriter 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">ConnectionWriter::~ConnectionWriter(void);</span>

<span class="s0">262 18 set_max_queue_size 0 4 359 36 ConnectionWriter::set_max_queue_size 0 1 99 192</span>
<span class="s0">/**</span>
 <span class="s0">* Limits the number of packets that may be pending on the outbound queue.</span>
 <span class="s0">* This only has an effect when using threads; if num_threads is 0, then all</span>
 <span class="s0">* packets are sent immediately.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void ConnectionWriter::set_max_queue_size(int max_size);</span>

<span class="s0">263 18 get_max_queue_size 0 4 359 36 ConnectionWriter::get_max_queue_size 0 1 100 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum size the queue is allowed to grow to.  See</span>
 <span class="s0">* set_max_queue_size().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">int ConnectionWriter::get_max_queue_size(void) const;</span>

<span class="s0">264 22 get_current_queue_size 0 4 359 40 ConnectionWriter::get_current_queue_size 0 1 101 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current number of things in the queue.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">int ConnectionWriter::get_current_queue_size(void) const;</span>

<span class="s0">265 4 send 0 4 359 22 ConnectionWriter::send 0 2 102 103 1230</span>
<span class="s0">/**</span>
 <span class="s0">* Enqueues a datagram for transmittal on the indicated socket.  Since the</span>
 <span class="s0">* host address is not specified with this form, this function should only be</span>
 <span class="s0">* used for sending TCP packets.  Use the other send() method for sending UDP</span>
 <span class="s0">* packets.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false if there was an error.  In the normal,</span>
 <span class="s0">* threaded case, this function only returns false if the send queue is</span>
 <span class="s0">* filled; it's impossible to detect a transmission error at this point.</span>
 <span class="s0">*</span>
 <span class="s0">* If block is true, this will not return false if the send queue is filled;</span>
 <span class="s0">* instead, it will wait until there is space available.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Enqueues a datagram for transmittal on the indicated socket.  This form of</span>
 <span class="s0">* the function allows the specification of a destination host address, and so</span>
 <span class="s0">* is appropriate for UDP packets.  Use the other send() method for sending</span>
 <span class="s0">* TCP packets.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false if there was an error.  In the normal,</span>
 <span class="s0">* threaded case, this function only returns false if the send queue is</span>
 <span class="s0">* filled; it's impossible to detect a transmission error at this point.</span>
 <span class="s0">*</span>
 <span class="s0">* If block is true, this will not return false if the send queue is filled;</span>
 <span class="s0">* instead, it will wait until there is space available.</span>
 <span class="s0">*/</span>
<span class="s0">262</span>
<span class="s0">bool ConnectionWriter::send(Datagram const &amp;datagram, PointerTo&lt; Connection &gt; const &amp;connection, bool block = false);</span>
<span class="s0">bool ConnectionWriter::send(Datagram const &amp;datagram, PointerTo&lt; Connection &gt; const &amp;connection, NetAddress const &amp;address, bool block = false);</span>

<span class="s0">266 16 is_valid_for_udp 0 4 359 34 ConnectionWriter::is_valid_for_udp 0 1 104 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the datagram is small enough to be sent over a UDP packet,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">bool ConnectionWriter::is_valid_for_udp(Datagram const &amp;datagram) const;</span>

<span class="s0">267 11 get_manager 0 4 359 29 ConnectionWriter::get_manager 0 1 105 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the ConnectionManager object that serves this</span>
 <span class="s0">* ConnectionWriter.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">ConnectionManager *ConnectionWriter::get_manager(void) const;</span>

<span class="s0">268 12 is_immediate 0 4 359 30 ConnectionWriter::is_immediate 0 1 106 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the writer is an immediate writer, i.e.  it has no threads.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool ConnectionWriter::is_immediate(void) const;</span>

<span class="s0">269 15 get_num_threads 0 4 359 33 ConnectionWriter::get_num_threads 0 1 107 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of threads the ConnectionWriter has been created with.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">int ConnectionWriter::get_num_threads(void) const;</span>

<span class="s0">270 12 set_raw_mode 0 4 359 30 ConnectionWriter::set_raw_mode 0 1 108 455</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the ConnectionWriter into raw mode (or turns off raw mode).  In raw</span>
 <span class="s0">* mode, datagrams are not sent along with their headers; the bytes in the</span>
 <span class="s0">* datagram are simply sent down the pipe.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting the ConnectionWriter to raw mode must be done with care.  This can</span>
 <span class="s0">* only be done when the matching ConnectionReader is also set to raw mode, or</span>
 <span class="s0">* when the ConnectionWriter is communicating to a process that does not</span>
 <span class="s0">* expect datagrams.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void ConnectionWriter::set_raw_mode(bool mode);</span>

<span class="s0">271 12 get_raw_mode 0 4 359 30 ConnectionWriter::get_raw_mode 0 1 109 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the raw mode flag.  See set_raw_mode().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool ConnectionWriter::get_raw_mode(void) const;</span>

<span class="s0">272 19 set_tcp_header_size 0 4 359 37 ConnectionWriter::set_tcp_header_size 0 1 110 270</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the header size of TCP packets.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void ConnectionWriter::set_tcp_header_size(int tcp_header_size);</span>

<span class="s0">273 19 get_tcp_header_size 0 4 359 37 ConnectionWriter::get_tcp_header_size 0 1 111 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of TCP header size.  See set_tcp_header_size().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">int ConnectionWriter::get_tcp_header_size(void) const;</span>

<span class="s0">274 8 shutdown 0 4 359 26 ConnectionWriter::shutdown 0 1 112 156</span>
<span class="s0">/**</span>
 <span class="s0">* Stops all the threads and cleans them up.  This is called automatically by</span>
 <span class="s0">* the destructor, but it may be called explicitly before destruction.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void ConnectionWriter::shutdown(void);</span>

<span class="s0">275 27 upcast_to_DatagramGenerator 0 12 360 49 DatagramGeneratorNet::upcast_to_DatagramGenerator 0 1 117 53</span>
<span class="s0">upcast from DatagramGeneratorNet to DatagramGenerator</span>
<span class="s0">75</span>
<span class="s0">DatagramGenerator *DatagramGeneratorNet::upcast_to_DatagramGenerator(void);</span>

<span class="s0">276 32 downcast_to_DatagramGeneratorNet 0 12 361 51 DatagramGenerator::downcast_to_DatagramGeneratorNet 0 0 55</span>
<span class="s0">downcast from DatagramGenerator to DatagramGeneratorNet</span>
<span class="s0">80</span>
<span class="s0">DatagramGeneratorNet *DatagramGenerator::downcast_to_DatagramGeneratorNet(void);</span>

<span class="s0">277 26 upcast_to_ConnectionReader 0 12 360 48 DatagramGeneratorNet::upcast_to_ConnectionReader 0 1 118 52</span>
<span class="s0">upcast from DatagramGeneratorNet to ConnectionReader</span>
<span class="s0">73</span>
<span class="s0">ConnectionReader *DatagramGeneratorNet::upcast_to_ConnectionReader(void);</span>

<span class="s0">278 32 downcast_to_DatagramGeneratorNet 0 12 350 50 ConnectionReader::downcast_to_DatagramGeneratorNet 0 0 54</span>
<span class="s0">downcast from ConnectionReader to DatagramGeneratorNet</span>
<span class="s0">79</span>
<span class="s0">DatagramGeneratorNet *ConnectionReader::downcast_to_DatagramGeneratorNet(void);</span>

<span class="s0">279 18 set_max_queue_size 0 4 362 44 QueuedReturn&lt; Datagram &gt;::set_max_queue_size 0 1 120 0</span>
<span class="s0">64</span>
<span class="s0">void QueuedReturn&lt; Datagram &gt;::set_max_queue_size(int max_size);</span>

<span class="s0">280 18 get_max_queue_size 0 4 362 44 QueuedReturn&lt; Datagram &gt;::get_max_queue_size 0 1 121 0</span>
<span class="s0">61</span>
<span class="s0">int QueuedReturn&lt; Datagram &gt;::get_max_queue_size(void) const;</span>

<span class="s0">281 22 get_current_queue_size 0 4 362 48 QueuedReturn&lt; Datagram &gt;::get_current_queue_size 0 1 122 0</span>
<span class="s0">65</span>
<span class="s0">int QueuedReturn&lt; Datagram &gt;::get_current_queue_size(void) const;</span>

<span class="s0">282 17 get_overflow_flag 0 4 362 43 QueuedReturn&lt; Datagram &gt;::get_overflow_flag 0 1 123 0</span>
<span class="s0">61</span>
<span class="s0">bool QueuedReturn&lt; Datagram &gt;::get_overflow_flag(void) const;</span>

<span class="s0">283 19 reset_overflow_flag 0 4 362 45 QueuedReturn&lt; Datagram &gt;::reset_overflow_flag 0 1 124 0</span>
<span class="s0">57</span>
<span class="s0">void QueuedReturn&lt; Datagram &gt;::reset_overflow_flag(void);</span>

<span class="s0">284 31 upcast_to_QueuedReturn_Datagram 0 12 360 53 DatagramGeneratorNet::upcast_to_QueuedReturn_Datagram 0 1 119 60</span>
<span class="s0">upcast from DatagramGeneratorNet to QueuedReturn&lt; Datagram &gt;</span>
<span class="s0">86</span>
<span class="s0">QueuedReturn&lt; Datagram &gt; *DatagramGeneratorNet::upcast_to_QueuedReturn_Datagram(void);</span>

<span class="s0">285 32 downcast_to_DatagramGeneratorNet 0 12 362 58 QueuedReturn&lt; Datagram &gt;::downcast_to_DatagramGeneratorNet 0 0 62</span>
<span class="s0">downcast from QueuedReturn&lt; Datagram &gt; to DatagramGeneratorNet</span>
<span class="s0">87</span>
<span class="s0">DatagramGeneratorNet *QueuedReturn&lt; Datagram &gt;::downcast_to_DatagramGeneratorNet(void);</span>

<span class="s0">286 20 DatagramGeneratorNet 0 260 360 42 DatagramGeneratorNet::DatagramGeneratorNet 0 1 113 243</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new DatagramGeneratorNet with the indicated number of threads to</span>
 <span class="s0">* handle requests.  Normally num_threads should be either 0 or 1 to guarantee</span>
 <span class="s0">* that datagrams are generated in the same order in which they were received.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">explicit DatagramGeneratorNet::DatagramGeneratorNet(ConnectionManager *manager, int num_threads);</span>

<span class="s0">287 21 ~DatagramGeneratorNet 0 518 360 43 DatagramGeneratorNet::~DatagramGeneratorNet 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">virtual DatagramGeneratorNet::~DatagramGeneratorNet(void);</span>

<span class="s0">288 12 get_datagram 0 6 360 34 DatagramGeneratorNet::get_datagram 0 1 114 189</span>
<span class="s0">// Inherited from DatagramGenerator</span>

<span class="s0">/**</span>
 <span class="s0">* Reads the next datagram from the stream.  Blocks until a datagram is</span>
 <span class="s0">* available.  Returns true on success, false on stream closed or error.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">virtual bool DatagramGeneratorNet::get_datagram(Datagram &amp;data);</span>

<span class="s0">289 6 is_eof 0 6 360 28 DatagramGeneratorNet::is_eof 0 1 115 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the stream has been closed normally.  This test may only be</span>
 <span class="s0">* made after a call to get_datagram() has failed.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">virtual bool DatagramGeneratorNet::is_eof(void);</span>

<span class="s0">290 8 is_error 0 6 360 30 DatagramGeneratorNet::is_error 0 1 116 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the stream has an error condition.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">virtual bool DatagramGeneratorNet::is_error(void);</span>

<span class="s0">291 22 upcast_to_DatagramSink 0 12 363 39 DatagramSinkNet::upcast_to_DatagramSink 0 1 131 43</span>
<span class="s0">upcast from DatagramSinkNet to DatagramSink</span>
<span class="s0">60</span>
<span class="s0">DatagramSink *DatagramSinkNet::upcast_to_DatagramSink(void);</span>

<span class="s0">292 27 downcast_to_DatagramSinkNet 0 12 364 41 DatagramSink::downcast_to_DatagramSinkNet 0 0 45</span>
<span class="s0">downcast from DatagramSink to DatagramSinkNet</span>
<span class="s0">65</span>
<span class="s0">DatagramSinkNet *DatagramSink::downcast_to_DatagramSinkNet(void);</span>

<span class="s0">293 26 upcast_to_ConnectionWriter 0 12 363 43 DatagramSinkNet::upcast_to_ConnectionWriter 0 1 132 47</span>
<span class="s0">upcast from DatagramSinkNet to ConnectionWriter</span>
<span class="s0">68</span>
<span class="s0">ConnectionWriter *DatagramSinkNet::upcast_to_ConnectionWriter(void);</span>

<span class="s0">294 27 downcast_to_DatagramSinkNet 0 12 359 45 ConnectionWriter::downcast_to_DatagramSinkNet 0 0 49</span>
<span class="s0">downcast from ConnectionWriter to DatagramSinkNet</span>
<span class="s0">69</span>
<span class="s0">DatagramSinkNet *ConnectionWriter::downcast_to_DatagramSinkNet(void);</span>

<span class="s0">295 15 DatagramSinkNet 0 260 363 32 DatagramSinkNet::DatagramSinkNet 0 1 125 233</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new DatagramSinkNet with the indicated number of threads to</span>
 <span class="s0">* handle writing.  Normally num_threads should be either 0 or 1 to guarantee</span>
 <span class="s0">* that datagrams are delivered in the same order in which they were sent.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">explicit DatagramSinkNet::DatagramSinkNet(ConnectionManager *manager, int num_threads);</span>

<span class="s0">296 10 set_target 0 4 363 27 DatagramSinkNet::set_target 0 1 126 80</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the Connection that will receive all future Datagrams sent.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void DatagramSinkNet::set_target(Connection *connection);</span>

<span class="s0">297 10 get_target 0 4 363 27 DatagramSinkNet::get_target 0 1 127 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current target Connection, or NULL if the target has not yet</span>
 <span class="s0">* been set.  See set_target().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline Connection *DatagramSinkNet::get_target(void) const;</span>

<span class="s0">298 12 put_datagram 0 6 363 29 DatagramSinkNet::put_datagram 0 1 128 187</span>
<span class="s0">// Inherited from DatagramSink</span>

<span class="s0">/**</span>
 <span class="s0">* Sends the given datagram to the target.  Returns true on success, false if</span>
 <span class="s0">* there is an error.  Blocks if necessary until the target is ready.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">virtual bool DatagramSinkNet::put_datagram(Datagram const &amp;data);</span>

<span class="s0">299 8 is_error 0 6 363 25 DatagramSinkNet::is_error 0 1 129 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is an error on the target connection, or if the</span>
 <span class="s0">* target has never been set.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">virtual bool DatagramSinkNet::is_error(void);</span>

<span class="s0">300 5 flush 0 6 363 22 DatagramSinkNet::flush 0 1 130 90</span>
<span class="s0">/**</span>
 <span class="s0">* Ensures that all datagrams previously written will be visible on the</span>
 <span class="s0">* stream.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">virtual void DatagramSinkNet::flush(void);</span>

<span class="s0">301 16 ~DatagramSinkNet 0 516 363 33 DatagramSinkNet::~DatagramSinkNet 0 0 0</span>
<span class="s0">40</span>
<span class="s0">DatagramSinkNet::~DatagramSinkNet(void);</span>

<span class="s0">302 28 upcast_to_ConnectionListener 0 12 365 54 QueuedConnectionListener::upcast_to_ConnectionListener 0 1 137 58</span>
<span class="s0">upcast from QueuedConnectionListener to ConnectionListener</span>
<span class="s0">81</span>
<span class="s0">ConnectionListener *QueuedConnectionListener::upcast_to_ConnectionListener(void);</span>

<span class="s0">303 36 downcast_to_QueuedConnectionListener 0 12 351 56 ConnectionListener::downcast_to_QueuedConnectionListener 0 0 60</span>
<span class="s0">downcast from ConnectionListener to QueuedConnectionListener</span>
<span class="s0">89</span>
<span class="s0">QueuedConnectionListener *ConnectionListener::downcast_to_QueuedConnectionListener(void);</span>

<span class="s0">304 18 set_max_queue_size 0 4 366 58 QueuedReturn&lt; ConnectionListenerData &gt;::set_max_queue_size 0 1 139 0</span>
<span class="s0">78</span>
<span class="s0">void QueuedReturn&lt; ConnectionListenerData &gt;::set_max_queue_size(int max_size);</span>

<span class="s0">305 18 get_max_queue_size 0 4 366 58 QueuedReturn&lt; ConnectionListenerData &gt;::get_max_queue_size 0 1 140 0</span>
<span class="s0">75</span>
<span class="s0">int QueuedReturn&lt; ConnectionListenerData &gt;::get_max_queue_size(void) const;</span>

<span class="s0">306 22 get_current_queue_size 0 4 366 62 QueuedReturn&lt; ConnectionListenerData &gt;::get_current_queue_size 0 1 141 0</span>
<span class="s0">79</span>
<span class="s0">int QueuedReturn&lt; ConnectionListenerData &gt;::get_current_queue_size(void) const;</span>

<span class="s0">307 17 get_overflow_flag 0 4 366 57 QueuedReturn&lt; ConnectionListenerData &gt;::get_overflow_flag 0 1 142 0</span>
<span class="s0">75</span>
<span class="s0">bool QueuedReturn&lt; ConnectionListenerData &gt;::get_overflow_flag(void) const;</span>

<span class="s0">308 19 reset_overflow_flag 0 4 366 59 QueuedReturn&lt; ConnectionListenerData &gt;::reset_overflow_flag 0 1 143 0</span>
<span class="s0">71</span>
<span class="s0">void QueuedReturn&lt; ConnectionListenerData &gt;::reset_overflow_flag(void);</span>

<span class="s0">309 45 upcast_to_QueuedReturn_ConnectionListenerData 0 12 365 71 QueuedConnectionListener::upcast_to_QueuedReturn_ConnectionListenerData 0 1 138 78</span>
<span class="s0">upcast from QueuedConnectionListener to QueuedReturn&lt; ConnectionListenerData &gt;</span>
<span class="s0">118</span>
<span class="s0">QueuedReturn&lt; ConnectionListenerData &gt; *QueuedConnectionListener::upcast_to_QueuedReturn_ConnectionListenerData(void);</span>

<span class="s0">310 36 downcast_to_QueuedConnectionListener 0 12 366 76 QueuedReturn&lt; ConnectionListenerData &gt;::downcast_to_QueuedConnectionListener 0 0 80</span>
<span class="s0">downcast from QueuedReturn&lt; ConnectionListenerData &gt; to QueuedConnectionListener</span>
<span class="s0">109</span>
<span class="s0">QueuedConnectionListener *QueuedReturn&lt; ConnectionListenerData &gt;::downcast_to_QueuedConnectionListener(void);</span>

<span class="s0">311 24 QueuedConnectionListener 0 260 365 50 QueuedConnectionListener::QueuedConnectionListener 0 1 133 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">explicit QueuedConnectionListener::QueuedConnectionListener(ConnectionManager *manager, int num_threads);</span>

<span class="s0">312 25 ~QueuedConnectionListener 0 518 365 51 QueuedConnectionListener::~QueuedConnectionListener 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">virtual QueuedConnectionListener::~QueuedConnectionListener(void);</span>

<span class="s0">313 24 new_connection_available 0 4 365 50 QueuedConnectionListener::new_connection_available 0 1 134 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a new connection was recently established; the connection</span>
 <span class="s0">* information may then be retrieved via get_new_connection().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool QueuedConnectionListener::new_connection_available(void);</span>

<span class="s0">314 18 get_new_connection 0 4 365 44 QueuedConnectionListener::get_new_connection 0 2 135 136 935</span>
<span class="s0">/**</span>
 <span class="s0">* If a previous call to new_connection_available() returned true, this</span>
 <span class="s0">* function will return information about the newly established connection.</span>
 <span class="s0">*</span>
 <span class="s0">* The rendezvous parameter is the particular rendezvous socket this new</span>
 <span class="s0">* connection originally communicated with; it is provided in case the</span>
 <span class="s0">* ConnectionListener was monitorind more than one and you care which one it</span>
 <span class="s0">* was.  The address parameter is the net address of the new client, and</span>
 <span class="s0">* new_connection is the socket of the newly established connection.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if a connection was successfully returned, or</span>
 <span class="s0">* false if there was, in fact, no new connection.  (This may happen if there</span>
 <span class="s0">* are multiple threads accessing the QueuedConnectionListener).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of get_new_connection() simply returns a new connection,</span>
 <span class="s0">* assuming the user doesn't care about the rendezvous socket that originated</span>
 <span class="s0">* it or the address it came from.</span>
 <span class="s0">*/</span>
<span class="s0">241</span>
<span class="s0">bool QueuedConnectionListener::get_new_connection(PointerTo&lt; Connection &gt; &amp;rendezvous, NetAddress &amp;address, PointerTo&lt; Connection &gt; &amp;new_connection);</span>
<span class="s0">bool QueuedConnectionListener::get_new_connection(PointerTo&lt; Connection &gt; &amp;new_connection);</span>

<span class="s0">315 27 upcast_to_ConnectionManager 0 12 367 52 QueuedConnectionManager::upcast_to_ConnectionManager 0 1 147 56</span>
<span class="s0">upcast from QueuedConnectionManager to ConnectionManager</span>
<span class="s0">78</span>
<span class="s0">ConnectionManager *QueuedConnectionManager::upcast_to_ConnectionManager(void);</span>

<span class="s0">316 35 downcast_to_QueuedConnectionManager 0 12 354 54 ConnectionManager::downcast_to_QueuedConnectionManager 0 0 58</span>
<span class="s0">downcast from ConnectionManager to QueuedConnectionManager</span>
<span class="s0">86</span>
<span class="s0">QueuedConnectionManager *ConnectionManager::downcast_to_QueuedConnectionManager(void);</span>

<span class="s0">317 18 set_max_queue_size 0 4 368 59 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::set_max_queue_size 0 1 149 0</span>
<span class="s0">79</span>
<span class="s0">void QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::set_max_queue_size(int max_size);</span>

<span class="s0">318 18 get_max_queue_size 0 4 368 59 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::get_max_queue_size 0 1 150 0</span>
<span class="s0">76</span>
<span class="s0">int QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::get_max_queue_size(void) const;</span>

<span class="s0">319 22 get_current_queue_size 0 4 368 63 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::get_current_queue_size 0 1 151 0</span>
<span class="s0">80</span>
<span class="s0">int QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::get_current_queue_size(void) const;</span>

<span class="s0">320 17 get_overflow_flag 0 4 368 58 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::get_overflow_flag 0 1 152 0</span>
<span class="s0">76</span>
<span class="s0">bool QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::get_overflow_flag(void) const;</span>

<span class="s0">321 19 reset_overflow_flag 0 4 368 60 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::reset_overflow_flag 0 1 153 0</span>
<span class="s0">72</span>
<span class="s0">void QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::reset_overflow_flag(void);</span>

<span class="s0">322 43 upcast_to_QueuedReturn_PointerTo_Connection 0 12 367 68 QueuedConnectionManager::upcast_to_QueuedReturn_PointerTo_Connection 0 1 148 78</span>
<span class="s0">upcast from QueuedConnectionManager to QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;</span>
<span class="s0">116</span>
<span class="s0">QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; *QueuedConnectionManager::upcast_to_QueuedReturn_PointerTo_Connection(void);</span>

<span class="s0">323 35 downcast_to_QueuedConnectionManager 0 12 368 76 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::downcast_to_QueuedConnectionManager 0 0 80</span>
<span class="s0">downcast from QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; to QueuedConnectionManager</span>
<span class="s0">108</span>
<span class="s0">QueuedConnectionManager *QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt;::downcast_to_QueuedConnectionManager(void);</span>

<span class="s0">324 23 QueuedConnectionManager 0 260 367 48 QueuedConnectionManager::QueuedConnectionManager 0 1 144 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">QueuedConnectionManager::QueuedConnectionManager(void);</span>

<span class="s0">325 24 ~QueuedConnectionManager 0 518 367 49 QueuedConnectionManager::~QueuedConnectionManager 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">virtual QueuedConnectionManager::~QueuedConnectionManager(void);</span>

<span class="s0">326 26 reset_connection_available 0 4 367 51 QueuedConnectionManager::reset_connection_available 0 1 145 631</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if one of the readers/writers/listeners reported a connection</span>
 <span class="s0">* reset recently.  If so, the particular connection that has been reset can</span>
 <span class="s0">* be extracted via get_reset_connection().</span>
 <span class="s0">*</span>
 <span class="s0">* Only connections which were externally reset are certain to appear in this</span>
 <span class="s0">* list.  Those which were explicitly closed via a call to close_connection()</span>
 <span class="s0">* may or may not be reported.  Furthermore, it is the responsibility of the</span>
 <span class="s0">* caller to subsequently call close_connection() with any connection reported</span>
 <span class="s0">* reset by this call.  (There is no harm in calling close_connection() more</span>
 <span class="s0">* than once on a given socket.)</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">bool QueuedConnectionManager::reset_connection_available(void) const;</span>

<span class="s0">327 20 get_reset_connection 0 4 367 45 QueuedConnectionManager::get_reset_connection 0 1 146 797</span>
<span class="s0">/**</span>
 <span class="s0">* If a previous call to reset_connection_available() returned true, this</span>
 <span class="s0">* function will return information about the newly reset connection.</span>
 <span class="s0">*</span>
 <span class="s0">* Only connections which were externally reset are certain to appear in this</span>
 <span class="s0">* list.  Those which were explicitly closed via a call to close_connection()</span>
 <span class="s0">* may or may not be reported.  Furthermore, it is the responsibility of the</span>
 <span class="s0">* caller to subsequently call close_connection() with any connection reported</span>
 <span class="s0">* reset by this call.  (There is no harm in calling close_connection() more</span>
 <span class="s0">* than once on a given socket.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if a connection was successfully returned, or</span>
 <span class="s0">* false if there was, in fact, no reset connection.  (This may happen if</span>
 <span class="s0">* there are multiple threads accessing the QueuedConnectionManager).</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">bool QueuedConnectionManager::get_reset_connection(PointerTo&lt; Connection &gt; &amp;connection);</span>

<span class="s0">328 26 upcast_to_ConnectionReader 0 12 369 50 QueuedConnectionReader::upcast_to_ConnectionReader 0 1 158 54</span>
<span class="s0">upcast from QueuedConnectionReader to ConnectionReader</span>
<span class="s0">75</span>
<span class="s0">ConnectionReader *QueuedConnectionReader::upcast_to_ConnectionReader(void);</span>

<span class="s0">329 34 downcast_to_QueuedConnectionReader 0 12 350 52 ConnectionReader::downcast_to_QueuedConnectionReader 0 0 56</span>
<span class="s0">downcast from ConnectionReader to QueuedConnectionReader</span>
<span class="s0">83</span>
<span class="s0">QueuedConnectionReader *ConnectionReader::downcast_to_QueuedConnectionReader(void);</span>

<span class="s0">330 18 set_max_queue_size 0 4 370 47 QueuedReturn&lt; NetDatagram &gt;::set_max_queue_size 0 1 160 0</span>
<span class="s0">67</span>
<span class="s0">void QueuedReturn&lt; NetDatagram &gt;::set_max_queue_size(int max_size);</span>

<span class="s0">331 18 get_max_queue_size 0 4 370 47 QueuedReturn&lt; NetDatagram &gt;::get_max_queue_size 0 1 161 0</span>
<span class="s0">64</span>
<span class="s0">int QueuedReturn&lt; NetDatagram &gt;::get_max_queue_size(void) const;</span>

<span class="s0">332 22 get_current_queue_size 0 4 370 51 QueuedReturn&lt; NetDatagram &gt;::get_current_queue_size 0 1 162 0</span>
<span class="s0">68</span>
<span class="s0">int QueuedReturn&lt; NetDatagram &gt;::get_current_queue_size(void) const;</span>

<span class="s0">333 17 get_overflow_flag 0 4 370 46 QueuedReturn&lt; NetDatagram &gt;::get_overflow_flag 0 1 163 0</span>
<span class="s0">64</span>
<span class="s0">bool QueuedReturn&lt; NetDatagram &gt;::get_overflow_flag(void) const;</span>

<span class="s0">334 19 reset_overflow_flag 0 4 370 48 QueuedReturn&lt; NetDatagram &gt;::reset_overflow_flag 0 1 164 0</span>
<span class="s0">60</span>
<span class="s0">void QueuedReturn&lt; NetDatagram &gt;::reset_overflow_flag(void);</span>

<span class="s0">335 34 upcast_to_QueuedReturn_NetDatagram 0 12 369 58 QueuedConnectionReader::upcast_to_QueuedReturn_NetDatagram 0 1 159 65</span>
<span class="s0">upcast from QueuedConnectionReader to QueuedReturn&lt; NetDatagram &gt;</span>
<span class="s0">94</span>
<span class="s0">QueuedReturn&lt; NetDatagram &gt; *QueuedConnectionReader::upcast_to_QueuedReturn_NetDatagram(void);</span>

<span class="s0">336 34 downcast_to_QueuedConnectionReader 0 12 370 63 QueuedReturn&lt; NetDatagram &gt;::downcast_to_QueuedConnectionReader 0 0 67</span>
<span class="s0">downcast from QueuedReturn&lt; NetDatagram &gt; to QueuedConnectionReader</span>
<span class="s0">94</span>
<span class="s0">QueuedConnectionReader *QueuedReturn&lt; NetDatagram &gt;::downcast_to_QueuedConnectionReader(void);</span>

<span class="s0">337 22 QueuedConnectionReader 0 260 369 46 QueuedConnectionReader::QueuedConnectionReader 0 1 154 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">explicit QueuedConnectionReader::QueuedConnectionReader(ConnectionManager *manager, int num_threads);</span>

<span class="s0">338 23 ~QueuedConnectionReader 0 518 369 47 QueuedConnectionReader::~QueuedConnectionReader 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">virtual QueuedConnectionReader::~QueuedConnectionReader(void);</span>

<span class="s0">339 14 data_available 0 4 369 38 QueuedConnectionReader::data_available 0 1 155 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a datagram is available on the queue; call get_data() to</span>
 <span class="s0">* extract the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">bool QueuedConnectionReader::data_available(void);</span>

<span class="s0">340 8 get_data 0 4 369 32 QueuedConnectionReader::get_data 0 2 156 157 650</span>
<span class="s0">/**</span>
 <span class="s0">* If a previous call to data_available() returned true, this function will</span>
 <span class="s0">* return the datagram that has become available.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if a datagram was successfully returned, or false</span>
 <span class="s0">* if there was, in fact, no datagram available.  (This may happen if there</span>
 <span class="s0">* are multiple threads accessing the QueuedConnectionReader).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of QueuedConnectionReader::get_data(), works like the other,</span>
 <span class="s0">* except that it only fills a Datagram object, not a NetDatagram object.</span>
 <span class="s0">* This means that the Datagram cannot be queried for its source Connection</span>
 <span class="s0">* and/or NetAddress, but it is useful in all other respects.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">bool QueuedConnectionReader::get_data(NetDatagram &amp;result);</span>
<span class="s0">bool QueuedConnectionReader::get_data(Datagram &amp;result);</span>

<span class="s0">341 22 RecentConnectionReader 0 260 371 46 RecentConnectionReader::RecentConnectionReader 0 1 165 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">explicit RecentConnectionReader::RecentConnectionReader(ConnectionManager *manager);</span>

<span class="s0">342 14 data_available 0 4 371 38 RecentConnectionReader::data_available 0 1 166 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a datagram is available on the queue; call get_data() to</span>
 <span class="s0">* extract the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">bool RecentConnectionReader::data_available(void);</span>

<span class="s0">343 8 get_data 0 4 371 32 RecentConnectionReader::get_data 0 2 167 168 650</span>
<span class="s0">/**</span>
 <span class="s0">* If a previous call to data_available() returned true, this function will</span>
 <span class="s0">* return the datagram that has become available.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if a datagram was successfully returned, or false</span>
 <span class="s0">* if there was, in fact, no datagram available.  (This may happen if there</span>
 <span class="s0">* are multiple threads accessing the RecentConnectionReader).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of RecentConnectionReader::get_data(), works like the other,</span>
 <span class="s0">* except that it only fills a Datagram object, not a NetDatagram object.</span>
 <span class="s0">* This means that the Datagram cannot be queried for its source Connection</span>
 <span class="s0">* and/or NetAddress, but it is useful in all other respects.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">bool RecentConnectionReader::get_data(NetDatagram &amp;result);</span>
<span class="s0">bool RecentConnectionReader::get_data(Datagram &amp;result);</span>

<span class="s0">168</span>
<span class="s0">1 0 0 7 6 372 176 0 0 0 </span>
<span class="s0">2 0 0 23 6 372 176 0 0 1 3 ptr 1 373  </span>
<span class="s0">3 0 0 15 6 372 176 0 0 1 4 copy 1 373  </span>
<span class="s0">4 0 0 7 6 372 176 0 0 1 6 param0 0 374  </span>
<span class="s0">5 0 0 7 7 373 0 0 289 // If your base class is a derivative of TypedObject, you might want to use</span>
<span class="s0">// the DCAST macro defined in typedObject.h instead, e.g.  DCAST(MyType,</span>
<span class="s0">// ptr).  This provides a clean downcast that doesn't require .p() or any</span>
<span class="s0">// double-casting, and it can be run-time checked for correctness. 1 4 this 3 375  </span>
<span class="s0">6 0 0 6 8 372 0 0 0 2 4 this 3 372  3 ptr 1 373  </span>
<span class="s0">7 0 0 6 8 372 0 0 0 2 4 this 3 372  4 copy 1 373  </span>
<span class="s0">8 0 0 6 9 377 0 0 0 1 4 this 3 375  </span>
<span class="s0">9 0 0 4 10 378 0 0 0 1 4 this 3 372  </span>
<span class="s0">10 0 0 4 4 378 0 0 0 1 4 this 3 379  </span>
<span class="s0">11 0 0 4 5 378 0 0 0 2 4 this 3 380  3 out 1 382  </span>
<span class="s0">12 0 0 7 13 384 194 0 45 /**</span>
 <span class="s0">* Constructs an unspecified address.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">13 0 0 15 13 384 194 0 0 1 6 param0 0 385  </span>
<span class="s0">14 0 0 23 13 384 194 0 224 /**</span>
 <span class="s0">* Constructs an address from a given Socket_Address.  Normally, this</span>
 <span class="s0">* constructor should not be used by user code; instead, create a default</span>
 <span class="s0">* NetAddress and use one of the set_*() functions to set up an address.</span>
 <span class="s0">*/ 1 4 addr 1 387  </span>
<span class="s0">15 0 0 6 14 377 0 0 179 /**</span>
 <span class="s0">* Sets the address up to refer to a particular port, but not to any</span>
 <span class="s0">* particular IP.  Returns true if successful, false otherwise (currently,</span>
 <span class="s0">* this only returns true).</span>
 <span class="s0">*/ 2 4 this 3 384  4 port 1 390  </span>
<span class="s0">16 0 0 6 15 377 0 0 75 /**</span>
 <span class="s0">* Sets the address up to refer to a particular port, on this host.</span>
 <span class="s0">*/ 2 4 this 3 384  4 port 1 390  </span>
<span class="s0">17 0 0 6 16 377 0 0 53 /**</span>
 <span class="s0">* Sets the address to the broadcast address.</span>
 <span class="s0">*/ 2 4 this 3 384  4 port 1 390  </span>
<span class="s0">18 0 0 6 17 377 0 0 141 /**</span>
 <span class="s0">* Sets the address up to refer to a particular port on a particular host.</span>
 <span class="s0">* Returns true if the hostname is known, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 384  8 hostname 1 391  4 port 1 390  </span>
<span class="s0">19 0 0 4 18 378 0 0 54 /**</span>
 <span class="s0">* Resets the NetAddress to its initial state.</span>
 <span class="s0">*/ 1 4 this 3 384  </span>
<span class="s0">20 0 0 6 19 390 0 0 64 /**</span>
 <span class="s0">* Returns the port number to which this address refers.</span>
 <span class="s0">*/ 1 4 this 3 385  </span>
<span class="s0">21 0 0 4 20 378 0 0 73 /**</span>
 <span class="s0">* Resets the port number without otherwise changing the address.</span>
 <span class="s0">*/ 2 4 this 3 384  4 port 1 390  </span>
<span class="s0">22 0 0 6 21 391 0 0 86 /**</span>
 <span class="s0">* Returns the IP address to which this address refers, formatted as a string.</span>
 <span class="s0">*/ 1 4 this 3 385  </span>
<span class="s0">23 0 0 6 22 377 0 0 58 /**</span>
 <span class="s0">* Returns true if the IP address has only zeroes.</span>
 <span class="s0">*/ 1 4 this 3 385  </span>
<span class="s0">24 0 0 6 23 392 0 0 158 /**</span>
 <span class="s0">* Returns the IP address to which this address refers, as a 32-bit integer,</span>
 <span class="s0">* in host byte order.</span>
 <span class="s0">* @deprecated  Does not work with IPv6 addresses.</span>
 <span class="s0">*/ 1 4 this 3 385  </span>
<span class="s0">25 0 0 6 24 394 0 0 213 /**</span>
 <span class="s0">* Returns the nth 8-bit component of the IP address.  An IP address has four</span>
 <span class="s0">* components; component 0 is the first (leftmost), and component 3 is the</span>
 <span class="s0">* last (rightmost) in the dotted number convention.</span>
 <span class="s0">*/ 2 4 this 3 385  1 n 1 390  </span>
<span class="s0">26 0 0 6 25 387 0 0 55 /**</span>
 <span class="s0">* Returns the Socket_Address for this address.</span>
 <span class="s0">*/ 1 4 this 3 385  </span>
<span class="s0">27 0 0 4 26 378 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 385  3 out 1 382  </span>
<span class="s0">28 0 0 6 27 396 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 385  </span>
<span class="s0">29 0 0 6 28 377 0 0 0 2 4 this 3 385  5 other 1 385  </span>
<span class="s0">30 0 0 6 29 377 0 0 0 2 4 this 3 385  5 other 1 385  </span>
<span class="s0">31 0 0 7 33 373 0 0 177 /**</span>
 <span class="s0">* Creates a connection.  Normally this constructor should not be used</span>
 <span class="s0">* directly by user code; use one of the methods in ConnectionManager to make</span>
 <span class="s0">* a new connection.</span>
 <span class="s0">*/ 2 7 manager 1 398  6 socket 1 399  </span>
<span class="s0">32 0 0 7 34 384 194 0 83 /**</span>
 <span class="s0">* Returns the address bound to this connection, if it is a TCP connection.</span>
 <span class="s0">*/ 1 4 this 3 401  </span>
<span class="s0">33 0 0 6 35 398 0 0 92 /**</span>
 <span class="s0">* Returns a pointer to the ConnectionManager object that serves this</span>
 <span class="s0">* connection.</span>
 <span class="s0">*/ 1 4 this 3 401  </span>
<span class="s0">34 0 0 6 36 399 0 0 70 /**</span>
 <span class="s0">* Returns the internal Socket_IP that defines the connection.</span>
 <span class="s0">*/ 1 4 this 3 401  </span>
<span class="s0">35 0 0 4 37 378 0 0 719 /**</span>
 <span class="s0">* Enables or disables &quot;collect-tcp&quot; mode.  In this mode, individual TCP</span>
 <span class="s0">* packets are not sent immediately, but rather they are collected together</span>
 <span class="s0">* and accumulated to be sent periodically as one larger TCP packet.  This</span>
 <span class="s0">* cuts down on overhead from the TCP/IP protocol, especially if many small</span>
 <span class="s0">* packets need to be sent on the same connection, but it introduces</span>
 <span class="s0">* additional latency (since packets must be held before they can be sent).</span>
 <span class="s0">*</span>
 <span class="s0">* See set_collect_tcp_interval() to specify the interval of time for which to</span>
 <span class="s0">* hold packets before sending them.</span>
 <span class="s0">*</span>
 <span class="s0">* If you enable this mode, you may also need to periodically call</span>
 <span class="s0">* consider_flush() to flush the queue if no packets have been sent recently.</span>
 <span class="s0">*/ 2 4 this 3 373  11 collect_tcp 1 377  </span>
<span class="s0">36 0 0 6 38 377 0 0 85 /**</span>
 <span class="s0">* Returns the current setting of &quot;collect-tcp&quot; mode.  See set_collect_tcp().</span>
 <span class="s0">*/ 1 4 this 3 401  </span>
<span class="s0">37 0 0 4 39 378 0 0 231 /**</span>
 <span class="s0">* Specifies the interval in time, in seconds, for which to hold TCP packets</span>
 <span class="s0">* before sending all of the recently received packets at once.  This only has</span>
 <span class="s0">* meaning if &quot;collect-tcp&quot; mode is enabled; see set_collect_tcp().</span>
 <span class="s0">*/ 2 4 this 3 373  8 interval 1 403  </span>
<span class="s0">38 0 0 6 40 403 0 0 229 /**</span>
 <span class="s0">* Returns the interval in time, in seconds, for which to hold TCP packets</span>
 <span class="s0">* before sending all of the recently received packets at once.  This only has</span>
 <span class="s0">* meaning if &quot;collect-tcp&quot; mode is enabled; see set_collect_tcp().</span>
 <span class="s0">*/ 1 4 this 3 401  </span>
<span class="s0">39 0 0 6 41 377 0 0 153 /**</span>
 <span class="s0">* Sends the most recently queued TCP datagram(s) if enough time has elapsed.</span>
 <span class="s0">* This only has meaning if set_collect_tcp() has been set to true.</span>
 <span class="s0">*/ 1 4 this 3 373  </span>
<span class="s0">40 0 0 6 42 377 0 0 131 /**</span>
 <span class="s0">* Sends the most recently queued TCP datagram(s) now.  This only has meaning</span>
 <span class="s0">* if set_collect_tcp() has been set to true.</span>
 <span class="s0">*/ 1 4 this 3 373  </span>
<span class="s0">41 0 0 4 43 378 0 0 416 /**</span>
 <span class="s0">* Sets the time to linger on close if data is present.  If flag is false,</span>
 <span class="s0">* when you close a socket with data available the system attempts to deliver</span>
 <span class="s0">* the data to the peer (the default behavior).  If flag is false but time is</span>
 <span class="s0">* zero, the system discards any undelivered data when you close the socket.</span>
 <span class="s0">* If flag is false but time is nonzero, the system waits up to time seconds</span>
 <span class="s0">* to deliver the data.</span>
 <span class="s0">*/ 3 4 this 3 373  4 flag 1 377  4 time 1 403  </span>
<span class="s0">42 0 0 4 44 378 0 0 55 /**</span>
 <span class="s0">* Sets whether local address reuse is allowed.</span>
 <span class="s0">*/ 2 4 this 3 373  4 flag 1 377  </span>
<span class="s0">43 0 0 4 45 378 0 0 93 /**</span>
 <span class="s0">* Sets whether the connection is periodically tested to see if it is still</span>
 <span class="s0">* alive.</span>
 <span class="s0">*/ 2 4 this 3 373  4 flag 1 377  </span>
<span class="s0">44 0 0 4 46 378 0 0 57 /**</span>
 <span class="s0">* Sets the size of the receive buffer, in bytes.</span>
 <span class="s0">*/ 2 4 this 3 373  4 size 1 390  </span>
<span class="s0">45 0 0 4 47 378 0 0 54 /**</span>
 <span class="s0">* Sets the size of the send buffer, in bytes.</span>
 <span class="s0">*/ 2 4 this 3 373  4 size 1 390  </span>
<span class="s0">46 0 0 4 48 378 0 0 32 /**</span>
 <span class="s0">* Sets IP time-to-live.</span>
 <span class="s0">*/ 2 4 this 3 373  3 ttl 1 390  </span>
<span class="s0">47 0 0 4 49 378 0 0 50 /**</span>
 <span class="s0">* Sets IP type-of-service and precedence.</span>
 <span class="s0">*/ 2 4 this 3 373  3 tos 1 390  </span>
<span class="s0">48 0 0 4 50 378 0 0 116 /**</span>
 <span class="s0">* If flag is true, this disables the Nagle algorithm, and prevents delaying</span>
 <span class="s0">* of send to coalesce packets.</span>
 <span class="s0">*/ 2 4 this 3 373  4 flag 1 377  </span>
<span class="s0">49 0 0 4 51 378 0 0 41 /**</span>
 <span class="s0">* Sets the maximum segment size.</span>
 <span class="s0">*/ 2 4 this 3 373  4 size 1 390  </span>
<span class="s0">50 0 0 6 54 377 0 0 504 /**</span>
 <span class="s0">* Adds a new socket to the list of sockets the ConnectionReader will monitor.</span>
 <span class="s0">* A datagram that comes in on any of the monitored sockets will be reported.</span>
 <span class="s0">* In the case of a ConnectionListener, this adds a new rendezvous socket; any</span>
 <span class="s0">* activity on any of the monitored sockets will cause a connection to be</span>
 <span class="s0">* accepted.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the connection was added, false if it was</span>
 <span class="s0">* already there.</span>
 <span class="s0">*</span>
 <span class="s0">* add_connection() is thread-safe, and may be called at will by any thread.</span>
 <span class="s0">*/ 2 4 this 3 404  10 connection 1 373  </span>
<span class="s0">51 0 0 6 55 377 0 0 264 /**</span>
 <span class="s0">* Removes a socket from the list of sockets being monitored.  Returns true if</span>
 <span class="s0">* the socket was correctly removed, false if it was not on the list in the</span>
 <span class="s0">* first place.</span>
 <span class="s0">*</span>
 <span class="s0">* remove_connection() is thread-safe, and may be called at will by any</span>
 <span class="s0">* thread.</span>
 <span class="s0">*/ 2 4 this 3 404  10 connection 1 373  </span>
<span class="s0">52 0 0 6 56 377 0 0 345 /**</span>
 <span class="s0">* Returns true if the indicated connection has been added to the</span>
 <span class="s0">* ConnectionReader and is being monitored properly, false if it is not known,</span>
 <span class="s0">* or if there was some error condition detected on the connection.  (If there</span>
 <span class="s0">* was an error condition, normally the ConnectionManager would have been</span>
 <span class="s0">* informed and closed the connection.)</span>
 <span class="s0">*/ 2 4 this 3 404  10 connection 1 373  </span>
<span class="s0">53 0 0 4 57 378 0 0 328 /**</span>
 <span class="s0">* Explicitly polls the available sockets to see if any of them have any</span>
 <span class="s0">* noise.  This function does nothing unless this is a polling-type</span>
 <span class="s0">* ConnectionReader, i.e.  it was created with zero threads (and is_polling()</span>
 <span class="s0">* will return true).</span>
 <span class="s0">*</span>
 <span class="s0">* It is not necessary to call this explicitly for a QueuedConnectionReader.</span>
 <span class="s0">*/ 1 4 this 3 404  </span>
<span class="s0">54 0 0 6 58 398 0 0 98 /**</span>
 <span class="s0">* Returns a pointer to the ConnectionManager object that serves this</span>
 <span class="s0">* ConnectionReader.</span>
 <span class="s0">*/ 1 4 this 3 405  </span>
<span class="s0">55 0 0 6 59 377 0 0 83 /**</span>
 <span class="s0">* Returns true if the reader is a polling reader, i.e.  it has no threads.</span>
 <span class="s0">*/ 1 4 this 3 405  </span>
<span class="s0">56 0 0 6 60 390 0 0 84 /**</span>
 <span class="s0">* Returns the number of threads the ConnectionReader has been created with.</span>
 <span class="s0">*/ 1 4 this 3 405  </span>
<span class="s0">57 0 0 4 61 378 0 0 314 /**</span>
 <span class="s0">* Sets the ConnectionReader into raw mode (or turns off raw mode).  In raw</span>
 <span class="s0">* mode, datagram headers are not expected; instead, all the data available on</span>
 <span class="s0">* the pipe is treated as a single datagram.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to set_tcp_header_size(0), except that it also turns off</span>
 <span class="s0">* headers for UDP packets.</span>
 <span class="s0">*/ 2 4 this 3 404  4 mode 1 377  </span>
<span class="s0">58 0 0 6 62 377 0 0 81 /**</span>
 <span class="s0">* Returns the current setting of the raw mode flag.  See set_raw_mode().</span>
 <span class="s0">*/ 1 4 this 3 405  </span>
<span class="s0">59 0 0 4 63 378 0 0 270 /**</span>
 <span class="s0">* Sets the header size of TCP packets.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/ 2 4 this 3 404  15 tcp_header_size 1 390  </span>
<span class="s0">60 0 0 6 64 390 0 0 86 /**</span>
 <span class="s0">* Returns the current setting of TCP header size.  See set_tcp_header_size().</span>
 <span class="s0">*/ 1 4 this 3 405  </span>
<span class="s0">61 0 0 4 65 378 0 0 146 /**</span>
 <span class="s0">* Terminates all threads cleanly.  Normally this is only called by the</span>
 <span class="s0">* destructor, but it may be called explicitly before destruction.</span>
 <span class="s0">*/ 1 4 this 3 404  </span>
<span class="s0">62 0 0 7 70 407 235 0 40 /**</span>
 <span class="s0">* Constructs an empty datagram.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">63 0 0 23 70 407 235 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 408  </span>
<span class="s0">64 0 0 15 70 407 235 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 410  </span>
<span class="s0">65 0 0 6 71 407 0 0 0 2 4 this 3 407  4 copy 1 408  </span>
<span class="s0">66 0 0 6 71 407 0 0 0 2 4 this 3 407  4 copy 1 410  </span>
<span class="s0">67 0 0 4 72 378 0 0 72 /**</span>
 <span class="s0">* Specifies the socket to which the datagram should be written.</span>
 <span class="s0">*/ 2 4 this 3 407  10 connection 1 373  </span>
<span class="s0">68 0 0 7 73 373 0 0 111 /**</span>
 <span class="s0">* Retrieves the socket from which the datagram was read, or to which it is</span>
 <span class="s0">* scheduled to be written.</span>
 <span class="s0">*/ 1 4 this 3 410  </span>
<span class="s0">69 0 0 4 74 378 0 0 67 /**</span>
 <span class="s0">* Specifies the host to which the datagram should be sent.</span>
 <span class="s0">*/ 2 4 this 3 407  7 address 1 385  </span>
<span class="s0">70 0 0 6 75 385 0 0 106 /**</span>
 <span class="s0">* Retrieves the host from which the datagram was read, or to which it is</span>
 <span class="s0">* scheduled to be sent.</span>
 <span class="s0">*/ 1 4 this 3 410  </span>
<span class="s0">71 0 0 7 76 413 0 0 0 0 </span>
<span class="s0">72 0 0 7 79 398 237 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">73 0 0 7 81 373 0 0 720 /**</span>
 <span class="s0">* Opens a socket for sending and/or receiving UDP packets.  If the port</span>
 <span class="s0">* number is greater than zero, the UDP connection will be opened for</span>
 <span class="s0">* listening on the indicated port; otherwise, it will be useful only for</span>
 <span class="s0">* sending.</span>
 <span class="s0">*</span>
 <span class="s0">* This variant accepts both a hostname and port to listen on a particular</span>
 <span class="s0">* interface; if the hostname is empty, all interfaces will be available,</span>
 <span class="s0">* both IPv4 and IPv6.</span>
 <span class="s0">*</span>
 <span class="s0">* If for_broadcast is true, this UDP connection will be configured to send</span>
 <span class="s0">* and/or receive messages on the broadcast address (255.255.255.255);</span>
 <span class="s0">* otherwise, these messages may be automatically filtered by the OS.</span>
 <span class="s0">*</span>
 <span class="s0">* Use a ConnectionReader and ConnectionWriter to handle the actual</span>
 <span class="s0">* communication.</span>
 <span class="s0">*/ 4 4 this 3 398  8 hostname 1 391  4 port 1 414  13 for_broadcast 5 377  </span>
<span class="s0">74 0 0 7 81 373 0 0 325 /**</span>
 <span class="s0">* Opens a socket for sending and/or receiving UDP packets.  If the port</span>
 <span class="s0">* number is greater than zero, the UDP connection will be opened for</span>
 <span class="s0">* listening on the indicated port; otherwise, it will be useful only for</span>
 <span class="s0">* sending.</span>
 <span class="s0">*</span>
 <span class="s0">* Use a ConnectionReader and ConnectionWriter to handle the actual</span>
 <span class="s0">* communication.</span>
 <span class="s0">*/ 2 4 this 3 398  4 port 5 414  </span>
<span class="s0">75 0 0 7 82 373 0 0 422 /**</span>
 <span class="s0">* Creates a socket to be used as a rendezvous socket for a server to listen</span>
 <span class="s0">* for TCP connections.  The socket returned by this call should only be added</span>
 <span class="s0">* to a ConnectionListener (not to a generic ConnectionReader).</span>
 <span class="s0">*</span>
 <span class="s0">* This variant of this method accepts a NetAddress, which allows you to</span>
 <span class="s0">* specify a specific interface to listen to.</span>
 <span class="s0">*</span>
 <span class="s0">* backlog is the maximum length of the queue of pending connections.</span>
 <span class="s0">*/ 3 4 this 3 398  7 address 1 385  7 backlog 1 390  </span>
<span class="s0">76 0 0 7 82 373 0 0 572 /**</span>
 <span class="s0">* Creates a socket to be used as a rendezvous socket for a server to listen</span>
 <span class="s0">* for TCP connections.  The socket returned by this call should only be added</span>
 <span class="s0">* to a ConnectionListener (not to a generic ConnectionReader).</span>
 <span class="s0">*</span>
 <span class="s0">* This variant of this method accepts a &quot;hostname&quot;, which is usually just an</span>
 <span class="s0">* IP address in dotted notation, and a port number.  It will listen on the</span>
 <span class="s0">* interface indicated by the IP address.  If the IP address is empty string,</span>
 <span class="s0">* it will listen on all interfaces.</span>
 <span class="s0">*</span>
 <span class="s0">* backlog is the maximum length of the queue of pending connections.</span>
 <span class="s0">*/ 4 4 this 3 398  8 hostname 1 391  4 port 1 414  7 backlog 1 390  </span>
<span class="s0">77 0 0 7 82 373 0 0 438 /**</span>
 <span class="s0">* Creates a socket to be used as a rendezvous socket for a server to listen</span>
 <span class="s0">* for TCP connections.  The socket returned by this call should only be added</span>
 <span class="s0">* to a ConnectionListener (not to a generic ConnectionReader).</span>
 <span class="s0">*</span>
 <span class="s0">* This variant of this method accepts a single port, and will listen to that</span>
 <span class="s0">* port on all available interfaces, both IPv4 and IPv6.</span>
 <span class="s0">*</span>
 <span class="s0">* backlog is the maximum length of the queue of pending connections.</span>
 <span class="s0">*/ 3 4 this 3 398  4 port 1 414  7 backlog 1 390  </span>
<span class="s0">78 0 0 7 83 373 0 0 201 /**</span>
 <span class="s0">* Attempts to establish a TCP client connection to a server at the indicated</span>
 <span class="s0">* address.  If the connection is not established within timeout_ms</span>
 <span class="s0">* milliseconds, a null connection is returned.</span>
 <span class="s0">*/ 3 4 this 3 398  7 address 1 385  10 timeout_ms 1 390  </span>
<span class="s0">79 0 0 7 83 373 0 0 120 /**</span>
 <span class="s0">* This is a shorthand version of the function to directly establish</span>
 <span class="s0">* communications to a named host and port.</span>
 <span class="s0">*/ 4 4 this 3 398  8 hostname 1 391  4 port 1 414  10 timeout_ms 1 390  </span>
<span class="s0">80 0 0 6 84 377 0 0 693 /**</span>
 <span class="s0">* Terminates a UDP or TCP socket previously opened.  This also removes it</span>
 <span class="s0">* from any associated ConnectionReader or ConnectionListeners.</span>
 <span class="s0">*</span>
 <span class="s0">* The socket itself may not be immediately closed--it will not be closed</span>
 <span class="s0">* until all outstanding pointers to it are cleared, including any pointers</span>
 <span class="s0">* remaining in NetDatagrams recently received from the socket.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the connection was marked to be closed, or</span>
 <span class="s0">* false if close_connection() had already been called (or the connection did</span>
 <span class="s0">* not belong to this ConnectionManager).  In neither case can you infer</span>
 <span class="s0">* anything about whether the connection has *actually* been closed yet based</span>
 <span class="s0">* on the return value.</span>
 <span class="s0">*/ 2 4 this 3 398  10 connection 1 373  </span>
<span class="s0">81 0 0 6 85 377 0 0 664 /**</span>
 <span class="s0">* Blocks the process for timeout number of seconds, or until any data is</span>
 <span class="s0">* available on any of the non-threaded ConnectionReaders or</span>
 <span class="s0">* ConnectionListeners, whichever comes first.  The return value is true if</span>
 <span class="s0">* there is data available (but you have to iterate through all readers to</span>
 <span class="s0">* find it), or false if the timeout occurred without any data.</span>
 <span class="s0">*</span>
 <span class="s0">* If the timeout value is negative, this will block forever or until data is</span>
 <span class="s0">* available.</span>
 <span class="s0">*</span>
 <span class="s0">* This only works if all ConnectionReaders and ConnectionListeners are non-</span>
 <span class="s0">* threaded.  If any threaded ConnectionReaders are part of the</span>
 <span class="s0">* ConnectionManager, the timeout value is implicitly treated as 0.</span>
 <span class="s0">*/ 2 4 this 3 398  7 timeout 1 403  </span>
<span class="s0">82 0 0 6 86 391 0 0 145 /**</span>
 <span class="s0">* Returns the name of this particular machine on the network, if available,</span>
 <span class="s0">* or the empty string if the hostname cannot be determined.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">83 0 0 4 101 378 0 0 258 /**</span>
 <span class="s0">* Repopulates the list reported by get_num_interface()/get_interface().  It</span>
 <span class="s0">* is not necessary to call this explicitly, unless you want to re-determine</span>
 <span class="s0">* the connected interfaces (for instance, if you suspect the hardware has</span>
 <span class="s0">* recently changed).</span>
 <span class="s0">*/ 1 4 this 3 398  </span>
<span class="s0">84 0 0 6 102 396 0 0 140 /**</span>
 <span class="s0">* This returns the number of usable network interfaces detected on this</span>
 <span class="s0">* machine.  See scan_interfaces() to repopulate this list.</span>
 <span class="s0">*/ 1 4 this 3 398  </span>
<span class="s0">85 0 0 6 103 416 0 0 127 /**</span>
 <span class="s0">* Returns the nth usable network interface detected on this machine.</span>
 <span class="s0">* See scan_interfaces() to repopulate this list.</span>
 <span class="s0">*/ 2 4 this 3 398  1 n 1 396  </span>
<span class="s0">86 0 0 15 99 417 256 0 0 1 6 param0 0 416  </span>
<span class="s0">87 0 0 6 88 391 0 0 0 1 4 this 3 416  </span>
<span class="s0">88 0 0 6 89 391 0 0 0 1 4 this 3 416  </span>
<span class="s0">89 0 0 6 90 377 0 0 0 1 4 this 3 416  </span>
<span class="s0">90 0 0 6 91 385 0 0 0 1 4 this 3 416  </span>
<span class="s0">91 0 0 6 92 377 0 0 0 1 4 this 3 416  </span>
<span class="s0">92 0 0 6 93 385 0 0 0 1 4 this 3 416  </span>
<span class="s0">93 0 0 6 94 377 0 0 0 1 4 this 3 416  </span>
<span class="s0">94 0 0 6 95 385 0 0 0 1 4 this 3 416  </span>
<span class="s0">95 0 0 6 96 377 0 0 0 1 4 this 3 416  </span>
<span class="s0">96 0 0 6 97 385 0 0 0 1 4 this 3 416  </span>
<span class="s0">97 0 0 4 98 378 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 416  3 out 1 382  </span>
<span class="s0">98 0 0 7 111 418 261 0 224 /**</span>
 <span class="s0">* Creates a new ConnectionWriter with the indicated number of threads to</span>
 <span class="s0">* handle output.</span>
 <span class="s0">*</span>
 <span class="s0">* If num_threads is 0, all datagrams will be sent immediately instead of</span>
 <span class="s0">* queueing for later transmission by a thread.</span>
 <span class="s0">*/ 3 7 manager 1 398  11 num_threads 1 390  11 thread_name 5 391  </span>
<span class="s0">99 0 0 4 113 378 0 0 192 /**</span>
 <span class="s0">* Limits the number of packets that may be pending on the outbound queue.</span>
 <span class="s0">* This only has an effect when using threads; if num_threads is 0, then all</span>
 <span class="s0">* packets are sent immediately.</span>
 <span class="s0">*/ 2 4 this 3 418  8 max_size 1 390  </span>
<span class="s0">100 0 0 6 114 390 0 0 98 /**</span>
 <span class="s0">* Returns the maximum size the queue is allowed to grow to.  See</span>
 <span class="s0">* set_max_queue_size().</span>
 <span class="s0">*/ 1 4 this 3 419  </span>
<span class="s0">101 0 0 6 115 390 0 0 61 /**</span>
 <span class="s0">* Returns the current number of things in the queue.</span>
 <span class="s0">*/ 1 4 this 3 419  </span>
<span class="s0">102 0 0 6 116 377 0 0 617 /**</span>
 <span class="s0">* Enqueues a datagram for transmittal on the indicated socket.  This form of</span>
 <span class="s0">* the function allows the specification of a destination host address, and so</span>
 <span class="s0">* is appropriate for UDP packets.  Use the other send() method for sending</span>
 <span class="s0">* TCP packets.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false if there was an error.  In the normal,</span>
 <span class="s0">* threaded case, this function only returns false if the send queue is</span>
 <span class="s0">* filled; it's impossible to detect a transmission error at this point.</span>
 <span class="s0">*</span>
 <span class="s0">* If block is true, this will not return false if the send queue is filled;</span>
 <span class="s0">* instead, it will wait until there is space available.</span>
 <span class="s0">*/ 5 4 this 3 418  8 datagram 1 408  10 connection 1 373  7 address 1 385  5 block 5 377  </span>
<span class="s0">103 0 0 6 116 377 0 0 611 /**</span>
 <span class="s0">* Enqueues a datagram for transmittal on the indicated socket.  Since the</span>
 <span class="s0">* host address is not specified with this form, this function should only be</span>
 <span class="s0">* used for sending TCP packets.  Use the other send() method for sending UDP</span>
 <span class="s0">* packets.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false if there was an error.  In the normal,</span>
 <span class="s0">* threaded case, this function only returns false if the send queue is</span>
 <span class="s0">* filled; it's impossible to detect a transmission error at this point.</span>
 <span class="s0">*</span>
 <span class="s0">* If block is true, this will not return false if the send queue is filled;</span>
 <span class="s0">* instead, it will wait until there is space available.</span>
 <span class="s0">*/ 4 4 this 3 418  8 datagram 1 408  10 connection 1 373  5 block 5 377  </span>
<span class="s0">104 0 0 6 117 377 0 0 105 /**</span>
 <span class="s0">* Returns true if the datagram is small enough to be sent over a UDP packet,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 419  8 datagram 1 408  </span>
<span class="s0">105 0 0 6 118 398 0 0 98 /**</span>
 <span class="s0">* Returns a pointer to the ConnectionManager object that serves this</span>
 <span class="s0">* ConnectionWriter.</span>
 <span class="s0">*/ 1 4 this 3 419  </span>
<span class="s0">106 0 0 6 119 377 0 0 86 /**</span>
 <span class="s0">* Returns true if the writer is an immediate writer, i.e.  it has no threads.</span>
 <span class="s0">*/ 1 4 this 3 419  </span>
<span class="s0">107 0 0 6 120 390 0 0 84 /**</span>
 <span class="s0">* Returns the number of threads the ConnectionWriter has been created with.</span>
 <span class="s0">*/ 1 4 this 3 419  </span>
<span class="s0">108 0 0 4 121 378 0 0 455 /**</span>
 <span class="s0">* Sets the ConnectionWriter into raw mode (or turns off raw mode).  In raw</span>
 <span class="s0">* mode, datagrams are not sent along with their headers; the bytes in the</span>
 <span class="s0">* datagram are simply sent down the pipe.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting the ConnectionWriter to raw mode must be done with care.  This can</span>
 <span class="s0">* only be done when the matching ConnectionReader is also set to raw mode, or</span>
 <span class="s0">* when the ConnectionWriter is communicating to a process that does not</span>
 <span class="s0">* expect datagrams.</span>
 <span class="s0">*/ 2 4 this 3 418  4 mode 1 377  </span>
<span class="s0">109 0 0 6 122 377 0 0 81 /**</span>
 <span class="s0">* Returns the current setting of the raw mode flag.  See set_raw_mode().</span>
 <span class="s0">*/ 1 4 this 3 419  </span>
<span class="s0">110 0 0 4 123 378 0 0 270 /**</span>
 <span class="s0">* Sets the header size of TCP packets.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/ 2 4 this 3 418  15 tcp_header_size 1 390  </span>
<span class="s0">111 0 0 6 124 390 0 0 86 /**</span>
 <span class="s0">* Returns the current setting of TCP header size.  See set_tcp_header_size().</span>
 <span class="s0">*/ 1 4 this 3 419  </span>
<span class="s0">112 0 0 4 125 378 0 0 156 /**</span>
 <span class="s0">* Stops all the threads and cleans them up.  This is called automatically by</span>
 <span class="s0">* the destructor, but it may be called explicitly before destruction.</span>
 <span class="s0">*/ 1 4 this 3 418  </span>
<span class="s0">113 0 0 7 140 421 287 0 243 /**</span>
 <span class="s0">* Creates a new DatagramGeneratorNet with the indicated number of threads to</span>
 <span class="s0">* handle requests.  Normally num_threads should be either 0 or 1 to guarantee</span>
 <span class="s0">* that datagrams are generated in the same order in which they were received.</span>
 <span class="s0">*/ 2 7 manager 1 398  11 num_threads 1 390  </span>
<span class="s0">114 0 0 6 142 377 0 0 152 /**</span>
 <span class="s0">* Reads the next datagram from the stream.  Blocks until a datagram is</span>
 <span class="s0">* available.  Returns true on success, false on stream closed or error.</span>
 <span class="s0">*/ 2 4 this 3 421  4 data 1 422  </span>
<span class="s0">115 0 0 6 143 377 0 0 137 /**</span>
 <span class="s0">* Returns true if the stream has been closed normally.  This test may only be</span>
 <span class="s0">* made after a call to get_datagram() has failed.</span>
 <span class="s0">*/ 1 4 this 3 421  </span>
<span class="s0">116 0 0 6 144 377 0 0 61 /**</span>
 <span class="s0">* Returns true if the stream has an error condition.</span>
 <span class="s0">*/ 1 4 this 3 421  </span>
<span class="s0">117 0 0 6 128 423 0 0 0 1 4 this 3 421  </span>
<span class="s0">118 0 0 6 130 404 0 0 0 1 4 this 3 421  </span>
<span class="s0">119 0 0 6 138 424 0 0 0 1 4 this 3 421  </span>
<span class="s0">120 0 0 4 133 378 0 0 0 2 4 this 3 424  8 max_size 1 390  </span>
<span class="s0">121 0 0 6 134 390 0 0 0 1 4 this 3 425  </span>
<span class="s0">122 0 0 6 135 390 0 0 0 1 4 this 3 425  </span>
<span class="s0">123 0 0 6 136 377 0 0 0 1 4 this 3 425  </span>
<span class="s0">124 0 0 4 137 378 0 0 0 1 4 this 3 424  </span>
<span class="s0">125 0 0 7 151 427 301 0 233 /**</span>
 <span class="s0">* Creates a new DatagramSinkNet with the indicated number of threads to</span>
 <span class="s0">* handle writing.  Normally num_threads should be either 0 or 1 to guarantee</span>
 <span class="s0">* that datagrams are delivered in the same order in which they were sent.</span>
 <span class="s0">*/ 2 7 manager 1 398  11 num_threads 1 390  </span>
<span class="s0">126 0 0 4 152 378 0 0 80 /**</span>
 <span class="s0">* Specifies the Connection that will receive all future Datagrams sent.</span>
 <span class="s0">*/ 2 4 this 3 427  10 connection 1 373  </span>
<span class="s0">127 0 0 7 153 373 0 0 115 /**</span>
 <span class="s0">* Returns the current target Connection, or NULL if the target has not yet</span>
 <span class="s0">* been set.  See set_target().</span>
 <span class="s0">*/ 1 4 this 3 428  </span>
<span class="s0">128 0 0 6 154 377 0 0 155 /**</span>
 <span class="s0">* Sends the given datagram to the target.  Returns true on success, false if</span>
 <span class="s0">* there is an error.  Blocks if necessary until the target is ready.</span>
 <span class="s0">*/ 2 4 this 3 427  4 data 1 408  </span>
<span class="s0">129 0 0 6 155 377 0 0 110 /**</span>
 <span class="s0">* Returns true if there is an error on the target connection, or if the</span>
 <span class="s0">* target has never been set.</span>
 <span class="s0">*/ 1 4 this 3 427  </span>
<span class="s0">130 0 0 4 156 378 0 0 90 /**</span>
 <span class="s0">* Ensures that all datagrams previously written will be visible on the</span>
 <span class="s0">* stream.</span>
 <span class="s0">*/ 1 4 this 3 427  </span>
<span class="s0">131 0 0 6 147 430 0 0 0 1 4 this 3 427  </span>
<span class="s0">132 0 0 6 149 418 0 0 0 1 4 this 3 427  </span>
<span class="s0">133 0 0 7 169 431 312 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 7 manager 1 398  11 num_threads 1 390  </span>
<span class="s0">134 0 0 6 171 377 0 0 147 /**</span>
 <span class="s0">* Returns true if a new connection was recently established; the connection</span>
 <span class="s0">* information may then be retrieved via get_new_connection().</span>
 <span class="s0">*/ 1 4 this 3 431  </span>
<span class="s0">135 0 0 6 172 377 0 0 192 /**</span>
 <span class="s0">* This flavor of get_new_connection() simply returns a new connection,</span>
 <span class="s0">* assuming the user doesn't care about the rendezvous socket that originated</span>
 <span class="s0">* it or the address it came from.</span>
 <span class="s0">*/ 2 4 this 3 431  14 new_connection 1 372  </span>
<span class="s0">136 0 0 6 172 377 0 0 741 /**</span>
 <span class="s0">* If a previous call to new_connection_available() returned true, this</span>
 <span class="s0">* function will return information about the newly established connection.</span>
 <span class="s0">*</span>
 <span class="s0">* The rendezvous parameter is the particular rendezvous socket this new</span>
 <span class="s0">* connection originally communicated with; it is provided in case the</span>
 <span class="s0">* ConnectionListener was monitorind more than one and you care which one it</span>
 <span class="s0">* was.  The address parameter is the net address of the new client, and</span>
 <span class="s0">* new_connection is the socket of the newly established connection.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if a connection was successfully returned, or</span>
 <span class="s0">* false if there was, in fact, no new connection.  (This may happen if there</span>
 <span class="s0">* are multiple threads accessing the QueuedConnectionListener).</span>
 <span class="s0">*/ 4 4 this 3 431  10 rendezvous 1 372  7 address 1 384  14 new_connection 1 372  </span>
<span class="s0">137 0 0 6 159 432 0 0 0 1 4 this 3 431  </span>
<span class="s0">138 0 0 6 167 433 0 0 0 1 4 this 3 431  </span>
<span class="s0">139 0 0 4 162 378 0 0 0 2 4 this 3 433  8 max_size 1 390  </span>
<span class="s0">140 0 0 6 163 390 0 0 0 1 4 this 3 434  </span>
<span class="s0">141 0 0 6 164 390 0 0 0 1 4 this 3 434  </span>
<span class="s0">142 0 0 6 165 377 0 0 0 1 4 this 3 434  </span>
<span class="s0">143 0 0 4 166 378 0 0 0 1 4 this 3 433  </span>
<span class="s0">144 0 0 7 184 436 325 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">145 0 0 6 186 377 0 0 631 /**</span>
 <span class="s0">* Returns true if one of the readers/writers/listeners reported a connection</span>
 <span class="s0">* reset recently.  If so, the particular connection that has been reset can</span>
 <span class="s0">* be extracted via get_reset_connection().</span>
 <span class="s0">*</span>
 <span class="s0">* Only connections which were externally reset are certain to appear in this</span>
 <span class="s0">* list.  Those which were explicitly closed via a call to close_connection()</span>
 <span class="s0">* may or may not be reported.  Furthermore, it is the responsibility of the</span>
 <span class="s0">* caller to subsequently call close_connection() with any connection reported</span>
 <span class="s0">* reset by this call.  (There is no harm in calling close_connection() more</span>
 <span class="s0">* than once on a given socket.)</span>
 <span class="s0">*/ 1 4 this 3 437  </span>
<span class="s0">146 0 0 6 187 377 0 0 797 /**</span>
 <span class="s0">* If a previous call to reset_connection_available() returned true, this</span>
 <span class="s0">* function will return information about the newly reset connection.</span>
 <span class="s0">*</span>
 <span class="s0">* Only connections which were externally reset are certain to appear in this</span>
 <span class="s0">* list.  Those which were explicitly closed via a call to close_connection()</span>
 <span class="s0">* may or may not be reported.  Furthermore, it is the responsibility of the</span>
 <span class="s0">* caller to subsequently call close_connection() with any connection reported</span>
 <span class="s0">* reset by this call.  (There is no harm in calling close_connection() more</span>
 <span class="s0">* than once on a given socket.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if a connection was successfully returned, or</span>
 <span class="s0">* false if there was, in fact, no reset connection.  (This may happen if</span>
 <span class="s0">* there are multiple threads accessing the QueuedConnectionManager).</span>
 <span class="s0">*/ 2 4 this 3 436  10 connection 1 372  </span>
<span class="s0">147 0 0 6 174 398 0 0 0 1 4 this 3 436  </span>
<span class="s0">148 0 0 6 182 439 0 0 0 1 4 this 3 436  </span>
<span class="s0">149 0 0 4 177 378 0 0 0 2 4 this 3 439  8 max_size 1 390  </span>
<span class="s0">150 0 0 6 178 390 0 0 0 1 4 this 3 440  </span>
<span class="s0">151 0 0 6 179 390 0 0 0 1 4 this 3 440  </span>
<span class="s0">152 0 0 6 180 377 0 0 0 1 4 this 3 440  </span>
<span class="s0">153 0 0 4 181 378 0 0 0 1 4 this 3 439  </span>
<span class="s0">154 0 0 7 199 442 338 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 7 manager 1 398  11 num_threads 1 390  </span>
<span class="s0">155 0 0 6 201 377 0 0 108 /**</span>
 <span class="s0">* Returns true if a datagram is available on the queue; call get_data() to</span>
 <span class="s0">* extract the datagram.</span>
 <span class="s0">*/ 1 4 this 3 442  </span>
<span class="s0">156 0 0 6 202 377 0 0 295 /**</span>
 <span class="s0">* This flavor of QueuedConnectionReader::get_data(), works like the other,</span>
 <span class="s0">* except that it only fills a Datagram object, not a NetDatagram object.</span>
 <span class="s0">* This means that the Datagram cannot be queried for its source Connection</span>
 <span class="s0">* and/or NetAddress, but it is useful in all other respects.</span>
 <span class="s0">*/ 2 4 this 3 442  6 result 1 422  </span>
<span class="s0">157 0 0 6 202 377 0 0 353 /**</span>
 <span class="s0">* If a previous call to data_available() returned true, this function will</span>
 <span class="s0">* return the datagram that has become available.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if a datagram was successfully returned, or false</span>
 <span class="s0">* if there was, in fact, no datagram available.  (This may happen if there</span>
 <span class="s0">* are multiple threads accessing the QueuedConnectionReader).</span>
 <span class="s0">*/ 2 4 this 3 442  6 result 1 407  </span>
<span class="s0">158 0 0 6 189 404 0 0 0 1 4 this 3 442  </span>
<span class="s0">159 0 0 6 197 443 0 0 0 1 4 this 3 442  </span>
<span class="s0">160 0 0 4 192 378 0 0 0 2 4 this 3 443  8 max_size 1 390  </span>
<span class="s0">161 0 0 6 193 390 0 0 0 1 4 this 3 444  </span>
<span class="s0">162 0 0 6 194 390 0 0 0 1 4 this 3 444  </span>
<span class="s0">163 0 0 6 195 377 0 0 0 1 4 this 3 444  </span>
<span class="s0">164 0 0 4 196 378 0 0 0 1 4 this 3 443  </span>
<span class="s0">165 0 0 7 204 446 214 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 7 manager 1 398  </span>
<span class="s0">166 0 0 6 205 377 0 0 108 /**</span>
 <span class="s0">* Returns true if a datagram is available on the queue; call get_data() to</span>
 <span class="s0">* extract the datagram.</span>
 <span class="s0">*/ 1 4 this 3 446  </span>
<span class="s0">167 0 0 6 206 377 0 0 295 /**</span>
 <span class="s0">* This flavor of RecentConnectionReader::get_data(), works like the other,</span>
 <span class="s0">* except that it only fills a Datagram object, not a NetDatagram object.</span>
 <span class="s0">* This means that the Datagram cannot be queried for its source Connection</span>
 <span class="s0">* and/or NetAddress, but it is useful in all other respects.</span>
 <span class="s0">*/ 2 4 this 3 446  6 result 1 422  </span>
<span class="s0">168 0 0 6 206 377 0 0 353 /**</span>
 <span class="s0">* If a previous call to data_available() returned true, this function will</span>
 <span class="s0">* return the datagram that has become available.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if a datagram was successfully returned, or false</span>
 <span class="s0">* if there was, in fact, no datagram available.  (This may happen if there</span>
 <span class="s0">* are multiple threads accessing the RecentConnectionReader).</span>
 <span class="s0">*/ 2 4 this 3 446  6 result 1 407  </span>
<span class="s0">103</span>
<span class="s0">344 23 PointerTo&lt; Connection &gt; 0 141313 23 PointerTo&lt; Connection &gt; 23 PointerTo&lt; Connection &gt; 0 0 0 1 171 176 0 4 172 173 174 175 0 0 1 0 345 0 0 0 0 0</span>

<span class="s0">345 27 PointerToBase&lt; Connection &gt; 0 43009 27 PointerToBase&lt; Connection &gt; 27 PointerToBase&lt; Connection &gt; 0 0 0 0 0 0 2 169 170 0 0 1 0 346 0 0 0 0 0</span>

<span class="s0">346 13 PointerToVoid 0 2048 13 PointerToVoid 13 PointerToVoid 0 0 0 0 0 0 0 0 0 0 0 0 373</span>
<span class="s0">/**</span>
 <span class="s0">* This is the non-template part of the base class for PointerTo and</span>
 <span class="s0">* ConstPointerTo.  It is necessary so we can keep a pointer to a non-template</span>
 <span class="s0">* class within the ReferenceCount object, to implement weak reference</span>
 <span class="s0">* pointers--we need to have something to clean up when the ReferenceCount</span>
 <span class="s0">* object destructs.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the base class for PointerToBase&lt;T&gt;.</span>
 <span class="s0">*/</span>

<span class="s0">347 10 NetAddress 0 141313 10 NetAddress 10 NetAddress 0 0 0 1 177 194 0 16 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 0 0 0 0 0 114</span>
<span class="s0">/**</span>
 <span class="s0">* Represents a network address to which UDP packets may be sent or to which a</span>
 <span class="s0">* TCP socket may be bound.</span>
 <span class="s0">*/</span>

<span class="s0">348 10 Connection 0 75777 10 Connection 10 Connection 0 0 0 1 195 0 0 18 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 0 0 1 0 349 0 0 0 0 69</span>
<span class="s0">/**</span>
 <span class="s0">* Represents a single TCP or UDP socket for input or output.</span>
 <span class="s0">*/</span>

<span class="s0">349 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">350 16 ConnectionReader 0 26625 16 ConnectionReader 16 ConnectionReader 0 0 0 0 214 0 12 215 216 217 218 219 220 221 222 223 224 225 226 0 0 0 0 0 844</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract base class for a family of classes that listen for</span>
 <span class="s0">* activity on a socket and respond to it, for instance by reading a datagram</span>
 <span class="s0">* and serving it (or queueing it up for later service).</span>
 <span class="s0">*</span>
 <span class="s0">* A ConnectionReader may define an arbitrary number of threads (at least one)</span>
 <span class="s0">* to process datagrams coming in from an arbitrary number of sockets that it</span>
 <span class="s0">* is monitoring.  The number of threads is specified at construction time and</span>
 <span class="s0">* cannot be changed, but the set of sockets that is to be monitored may be</span>
 <span class="s0">* constantly modified at will.</span>
 <span class="s0">*</span>
 <span class="s0">* This is an abstract class because it doesn't define how to process each</span>
 <span class="s0">* received datagram.  See QueuedConnectionReader.  Also note that</span>
 <span class="s0">* ConnectionListener derives from this class, extending it to accept</span>
 <span class="s0">* connections on a rendezvous socket rather than read datagrams.</span>
 <span class="s0">*/</span>

<span class="s0">351 18 ConnectionListener 0 141313 18 ConnectionListener 18 ConnectionListener 0 0 0 0 227 0 0 0 0 1 0 350 0 0 0 0 339</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special kind of ConnectionReader that waits for activity on a</span>
 <span class="s0">* rendezvous port and accepts a TCP connection (instead of attempting to read</span>
 <span class="s0">* a datagram from the rendezvous port).</span>
 <span class="s0">*</span>
 <span class="s0">* It is itself an abstract class, as it doesn't define what to do with the</span>
 <span class="s0">* established connection.  See QueuedConnectionListener.</span>
 <span class="s0">*/</span>

<span class="s0">352 11 NetDatagram 0 141313 11 NetDatagram 11 NetDatagram 0 0 0 1 228 235 0 6 229 230 231 232 233 234 0 0 1 0 353 0 0 0 0 219</span>
<span class="s0">/**</span>
 <span class="s0">* A specific kind of Datagram, especially for sending across or receiving</span>
 <span class="s0">* from a network.  It's different only in that it knows which Connection</span>
 <span class="s0">* and/or NetAddress it is to be sent to or was received from.</span>
 <span class="s0">*/</span>

<span class="s0">353 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565</span>
<span class="s0">/**</span>
 <span class="s0">* An ordered list of data elements, formatted in memory for transmission over</span>
 <span class="s0">* a socket or writing to a data file.</span>
 <span class="s0">*</span>
 <span class="s0">* Data elements should be added one at a time, in order, to the Datagram.</span>
 <span class="s0">* The nature and contents of the data elements are totally up to the user.</span>
 <span class="s0">* When a Datagram has been transmitted and received, its data elements may be</span>
 <span class="s0">* extracted using a DatagramIterator; it is up to the caller to know the</span>
 <span class="s0">* correct type of each data element in order.</span>
 <span class="s0">*</span>
 <span class="s0">* A Datagram is itself headerless; it is simply a collection of data</span>
 <span class="s0">* elements.</span>
 <span class="s0">*/</span>

<span class="s0">354 17 ConnectionManager 0 26625 17 ConnectionManager 17 ConnectionManager 0 0 0 1 236 237 2 447 448 9 238 239 240 241 242 243 257 258 259 1 449 0 0 0 1 355 573</span>
<span class="s0">/**</span>
 <span class="s0">* The primary interface to the low-level networking layer in this package.  A</span>
 <span class="s0">* ConnectionManager is used to establish and destroy TCP and UDP connections.</span>
 <span class="s0">* Communication on these connections, once established, is handled via</span>
 <span class="s0">* ConnectionReader, ConnectionWriter, and ConnectionListener.</span>
 <span class="s0">*</span>
 <span class="s0">* You may use this class directly if you don't care about tracking which</span>
 <span class="s0">* connections have been unexpectedly closed; otherwise, you should use</span>
 <span class="s0">* QueuedConnectionManager to get reports about these events (or derive your</span>
 <span class="s0">* own class to handle these events properly).</span>
 <span class="s0">*/</span>

<span class="s0">355 9 Interface 0 403457 28 ConnectionManager::Interface 28 ConnectionManager::Interface 354 0 0 1 255 256 0 11 244 245 246 247 248 249 250 251 252 253 254 0 0 0 0 0 0</span>

<span class="s0">356 6 string 0 2105344 11 std::string 11 std::string 0 0 357 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">357 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">358 15 Interface const 0 8832 34 ConnectionManager::Interface const 34 ConnectionManager::Interface const 0 0 355 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">359 16 ConnectionWriter 0 26625 16 ConnectionWriter 16 ConnectionWriter 0 0 0 1 260 261 0 13 262 263 264 265 266 267 268 269 270 271 272 273 274 0 0 0 0 0 294</span>
<span class="s0">/**</span>
 <span class="s0">* This class handles threaded delivery of datagrams to various TCP or UDP</span>
 <span class="s0">* sockets.</span>
 <span class="s0">*</span>
 <span class="s0">* A ConnectionWriter may define an arbitrary number of threads (0 or more) to</span>
 <span class="s0">* write its datagrams to sockets.  The number of threads is specified at</span>
 <span class="s0">* construction time and cannot be changed.</span>
 <span class="s0">*/</span>

<span class="s0">360 20 DatagramGeneratorNet 0 26625 20 DatagramGeneratorNet 20 DatagramGeneratorNet 0 0 0 1 286 287 0 3 288 289 290 0 0 3 3 361 275 276 3 350 277 278 3 362 284 285 0 0 186</span>
<span class="s0">/**</span>
 <span class="s0">* This class provides datagrams one-at-a-time as read directly from the net,</span>
 <span class="s0">* via a TCP connection.  If a datagram is not available, get_datagram() will</span>
 <span class="s0">* block until one is.</span>
 <span class="s0">*/</span>

<span class="s0">361 17 DatagramGenerator 0 2048 17 DatagramGenerator 17 DatagramGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* This class defines the abstract interace to any source of datagrams,</span>
 <span class="s0">* whether it be from a file or from the net.</span>
 <span class="s0">*/</span>

<span class="s0">362 24 QueuedReturn&lt; Datagram &gt; 0 43009 24 QueuedReturn&lt; Datagram &gt; 24 QueuedReturn&lt; Datagram &gt; 0 0 0 0 0 0 5 279 280 281 282 283 0 0 0 0 0 0</span>

<span class="s0">363 15 DatagramSinkNet 0 141313 15 DatagramSinkNet 15 DatagramSinkNet 0 0 0 1 295 301 0 5 296 297 298 299 300 0 0 2 3 364 291 292 3 359 293 294 0 0 107</span>
<span class="s0">/**</span>
 <span class="s0">* This class accepts datagrams one-at-a-time and sends them over the net, via</span>
 <span class="s0">* a TCP connection.</span>
 <span class="s0">*/</span>

<span class="s0">364 12 DatagramSink 0 2048 12 DatagramSink 12 DatagramSink 0 0 0 0 0 0 0 0 0 0 0 0 135</span>
<span class="s0">/**</span>
 <span class="s0">* This class defines the abstract interface to sending datagrams to any</span>
 <span class="s0">* target, whether it be into a file or across the net</span>
 <span class="s0">*/</span>

<span class="s0">365 24 QueuedConnectionListener 0 26625 24 QueuedConnectionListener 24 QueuedConnectionListener 0 0 0 1 311 312 0 2 313 314 0 0 2 3 351 302 303 3 366 309 310 0 0 143</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of ConnectionListener will queue up all of the TCP connections</span>
 <span class="s0">* it established for later detection by the client code.</span>
 <span class="s0">*/</span>

<span class="s0">366 38 QueuedReturn&lt; ConnectionListenerData &gt; 0 43009 38 QueuedReturn&lt; ConnectionListenerData &gt; 38 QueuedReturn&lt; ConnectionListenerData &gt; 0 0 0 0 0 0 5 304 305 306 307 308 0 0 0 0 0 0</span>

<span class="s0">367 23 QueuedConnectionManager 0 26625 23 QueuedConnectionManager 23 QueuedConnectionManager 0 0 0 1 324 325 0 2 326 327 0 0 2 3 354 315 316 3 368 322 323 0 0 423</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of ConnectionManager will queue up all of the reset-connection</span>
 <span class="s0">* messages from the ConnectionReaders and ConnectionWriters and report them</span>
 <span class="s0">* to the client on demand.</span>
 <span class="s0">*</span>
 <span class="s0">* When a reset connection has been discovered via</span>
 <span class="s0">* reset_connection_available()/get_reset_connection(), it is still the</span>
 <span class="s0">* responsibility of the client to call close_connection() on that connection</span>
 <span class="s0">* to free up its resources.</span>
 <span class="s0">*/</span>

<span class="s0">368 39 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; 0 43009 39 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; 39 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; 0 0 0 0 0 0 5 317 318 319 320 321 0 0 0 0 0 0</span>

<span class="s0">369 22 QueuedConnectionReader 0 26625 22 QueuedConnectionReader 22 QueuedConnectionReader 0 0 0 1 337 338 0 2 339 340 0 0 2 3 350 328 329 3 370 335 336 0 0 291</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of ConnectionReader will read from its sockets and queue up all</span>
 <span class="s0">* of the datagrams read for later receipt by the client code.  This class is</span>
 <span class="s0">* useful for client code that doesn't want to deal with threading and is</span>
 <span class="s0">* willing to poll for datagrams at its convenience.</span>
 <span class="s0">*/</span>

<span class="s0">370 27 QueuedReturn&lt; NetDatagram &gt; 0 43009 27 QueuedReturn&lt; NetDatagram &gt; 27 QueuedReturn&lt; NetDatagram &gt; 0 0 0 0 0 0 5 330 331 332 333 334 0 0 0 0 0 0</span>

<span class="s0">371 22 RecentConnectionReader 0 75777 22 RecentConnectionReader 22 RecentConnectionReader 0 0 0 1 341 214 0 2 342 343 0 0 1 0 350 0 0 0 0 430</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of ConnectionReader will read from its sockets and retain only</span>
 <span class="s0">* the single most recent datagram for inspection by client code.  It's useful</span>
 <span class="s0">* particularly for reading telemetry-type data from UDP sockets where you</span>
 <span class="s0">* don't care about getting every last socket, and in fact if the sockets are</span>
 <span class="s0">* coming too fast you'd prefer to skip some of them.</span>
 <span class="s0">*</span>
 <span class="s0">* This class will always create one thread for itself.</span>
 <span class="s0">*/</span>

<span class="s0">372 25 PointerTo&lt; Connection &gt; * 0 8576 25 PointerTo&lt; Connection &gt; * 25 PointerTo&lt; Connection &gt; * 0 0 344 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">373 12 Connection * 0 8576 12 Connection * 12 Connection * 0 0 348 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">374 17 decltype(nullptr) 0 8194 17 decltype(nullptr) 17 decltype(nullptr) 0 9 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">375 31 PointerTo&lt; Connection &gt; const * 0 8576 31 PointerTo&lt; Connection &gt; const * 31 PointerTo&lt; Connection &gt; const * 0 0 376 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">376 29 PointerTo&lt; Connection &gt; const 0 8832 29 PointerTo&lt; Connection &gt; const 29 PointerTo&lt; Connection &gt; const 0 0 344 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">377 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">378 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">379 29 PointerToBase&lt; Connection &gt; * 0 8576 29 PointerToBase&lt; Connection &gt; * 29 PointerToBase&lt; Connection &gt; * 0 0 345 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">380 35 PointerToBase&lt; Connection &gt; const * 0 8576 35 PointerToBase&lt; Connection &gt; const * 35 PointerToBase&lt; Connection &gt; const * 0 0 381 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">381 33 PointerToBase&lt; Connection &gt; const 0 8832 33 PointerToBase&lt; Connection &gt; const 33 PointerToBase&lt; Connection &gt; const 0 0 345 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">382 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 383 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">383 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">384 12 NetAddress * 0 8576 12 NetAddress * 12 NetAddress * 0 0 347 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">385 18 NetAddress const * 0 8576 18 NetAddress const * 18 NetAddress const * 0 0 386 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">386 16 NetAddress const 0 8832 16 NetAddress const 16 NetAddress const 0 0 347 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">387 22 Socket_Address const * 0 8576 22 Socket_Address const * 22 Socket_Address const * 0 0 388 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">388 20 Socket_Address const 0 8832 20 Socket_Address const 20 Socket_Address const 0 0 389 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">389 14 Socket_Address 0 2048 14 Socket_Address 14 Socket_Address 0 0 0 0 0 0 0 0 0 0 0 0 97</span>
<span class="s0">/**</span>
 <span class="s0">* A simple place to store and manipulate tcp and port address for</span>
 <span class="s0">* communication layer</span>
 <span class="s0">*/</span>

<span class="s0">390 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">391 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">392 8 uint32_t 0 2105344 8 uint32_t 8 uint32_t 0 0 393 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">393 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">394 7 uint8_t 0 2105344 7 uint8_t 7 uint8_t 0 0 395 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">395 13 unsigned char 0 8198 13 unsigned char 13 unsigned char 0 5 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">396 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 397 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">397 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">398 19 ConnectionManager * 0 8576 19 ConnectionManager * 19 ConnectionManager * 0 0 354 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">399 11 Socket_IP * 0 8576 11 Socket_IP * 11 Socket_IP * 0 0 400 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">400 9 Socket_IP 0 2048 9 Socket_IP 9 Socket_IP 0 0 0 0 0 0 0 0 0 0 0 0 354</span>
<span class="s0">/**</span>
 <span class="s0">* Base functionality for a INET domain Socket This call should be the</span>
 <span class="s0">* starting point for all other unix domain sockets.</span>
 <span class="s0">*</span>
 <span class="s0">* SocketIP |</span>
 <span class="s0">* ------------------------------------------------------------------- |</span>
 <span class="s0">* |                       |                           | SocketTCP</span>
 <span class="s0">* SocketTCP_Listen    SocketUDP_Incoming   SocketUDP_OutBound</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">401 18 Connection const * 0 8576 18 Connection const * 18 Connection const * 0 0 402 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">402 16 Connection const 0 8832 16 Connection const 16 Connection const 0 0 348 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">403 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">404 18 ConnectionReader * 0 8576 18 ConnectionReader * 18 ConnectionReader * 0 0 350 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">405 24 ConnectionReader const * 0 8576 24 ConnectionReader const * 24 ConnectionReader const * 0 0 406 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">406 22 ConnectionReader const 0 8832 22 ConnectionReader const 22 ConnectionReader const 0 0 350 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">407 13 NetDatagram * 0 8576 13 NetDatagram * 13 NetDatagram * 0 0 352 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">408 16 Datagram const * 0 8576 16 Datagram const * 16 Datagram const * 0 0 409 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">409 14 Datagram const 0 8832 14 Datagram const 14 Datagram const 0 0 353 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">410 19 NetDatagram const * 0 8576 19 NetDatagram const * 19 NetDatagram const * 0 0 411 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">411 17 NetDatagram const 0 8832 17 NetDatagram const 17 NetDatagram const 0 0 352 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">412 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">413 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 412 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">414 8 uint16_t 0 2105344 8 uint16_t 8 uint16_t 0 0 415 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">415 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">416 17 Interface const * 0 8576 36 ConnectionManager::Interface const * 36 ConnectionManager::Interface const * 0 0 358 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">417 11 Interface * 0 8576 30 ConnectionManager::Interface * 30 ConnectionManager::Interface * 0 0 355 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">418 18 ConnectionWriter * 0 8576 18 ConnectionWriter * 18 ConnectionWriter * 0 0 359 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">419 24 ConnectionWriter const * 0 8576 24 ConnectionWriter const * 24 ConnectionWriter const * 0 0 420 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">420 22 ConnectionWriter const 0 8832 22 ConnectionWriter const 22 ConnectionWriter const 0 0 359 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">421 22 DatagramGeneratorNet * 0 8576 22 DatagramGeneratorNet * 22 DatagramGeneratorNet * 0 0 360 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">422 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 353 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">423 19 DatagramGenerator * 0 8576 19 DatagramGenerator * 19 DatagramGenerator * 0 0 361 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">424 26 QueuedReturn&lt; Datagram &gt; * 0 8576 26 QueuedReturn&lt; Datagram &gt; * 26 QueuedReturn&lt; Datagram &gt; * 0 0 362 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">425 32 QueuedReturn&lt; Datagram &gt; const * 0 8576 32 QueuedReturn&lt; Datagram &gt; const * 32 QueuedReturn&lt; Datagram &gt; const * 0 0 426 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">426 30 QueuedReturn&lt; Datagram &gt; const 0 8832 30 QueuedReturn&lt; Datagram &gt; const 30 QueuedReturn&lt; Datagram &gt; const 0 0 362 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">427 17 DatagramSinkNet * 0 8576 17 DatagramSinkNet * 17 DatagramSinkNet * 0 0 363 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">428 23 DatagramSinkNet const * 0 8576 23 DatagramSinkNet const * 23 DatagramSinkNet const * 0 0 429 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">429 21 DatagramSinkNet const 0 8832 21 DatagramSinkNet const 21 DatagramSinkNet const 0 0 363 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">430 14 DatagramSink * 0 8576 14 DatagramSink * 14 DatagramSink * 0 0 364 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">431 26 QueuedConnectionListener * 0 8576 26 QueuedConnectionListener * 26 QueuedConnectionListener * 0 0 365 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">432 20 ConnectionListener * 0 8576 20 ConnectionListener * 20 ConnectionListener * 0 0 351 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">433 40 QueuedReturn&lt; ConnectionListenerData &gt; * 0 8576 40 QueuedReturn&lt; ConnectionListenerData &gt; * 40 QueuedReturn&lt; ConnectionListenerData &gt; * 0 0 366 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">434 46 QueuedReturn&lt; ConnectionListenerData &gt; const * 0 8576 46 QueuedReturn&lt; ConnectionListenerData &gt; const * 46 QueuedReturn&lt; ConnectionListenerData &gt; const * 0 0 435 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">435 44 QueuedReturn&lt; ConnectionListenerData &gt; const 0 8832 44 QueuedReturn&lt; ConnectionListenerData &gt; const 44 QueuedReturn&lt; ConnectionListenerData &gt; const 0 0 366 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">436 25 QueuedConnectionManager * 0 8576 25 QueuedConnectionManager * 25 QueuedConnectionManager * 0 0 367 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">437 31 QueuedConnectionManager const * 0 8576 31 QueuedConnectionManager const * 31 QueuedConnectionManager const * 0 0 438 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">438 29 QueuedConnectionManager const 0 8832 29 QueuedConnectionManager const 29 QueuedConnectionManager const 0 0 367 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">439 41 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; * 0 8576 41 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; * 41 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; * 0 0 368 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">440 47 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; const * 0 8576 47 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; const * 47 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; const * 0 0 441 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">441 45 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; const 0 8832 45 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; const 45 QueuedReturn&lt; PointerTo&lt; Connection &gt; &gt; const 0 0 368 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">442 24 QueuedConnectionReader * 0 8576 24 QueuedConnectionReader * 24 QueuedConnectionReader * 0 0 369 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">443 29 QueuedReturn&lt; NetDatagram &gt; * 0 8576 29 QueuedReturn&lt; NetDatagram &gt; * 29 QueuedReturn&lt; NetDatagram &gt; * 0 0 370 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">444 35 QueuedReturn&lt; NetDatagram &gt; const * 0 8576 35 QueuedReturn&lt; NetDatagram &gt; const * 35 QueuedReturn&lt; NetDatagram &gt; const * 0 0 445 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">445 33 QueuedReturn&lt; NetDatagram &gt; const 0 8832 33 QueuedReturn&lt; NetDatagram &gt; const 33 QueuedReturn&lt; NetDatagram &gt; const 0 0 370 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">446 24 RecentConnectionReader * 0 8576 24 RecentConnectionReader * 24 RecentConnectionReader * 0 0 371 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">2</span>
<span class="s0">447 9 host_name 0 2 356 243 0 0 0 0 0 0 0 28 ConnectionManager::host_name 0</span>

<span class="s0">448 10 interfaces 0 66 358 259 0 0 0 0 258 0 0 29 ConnectionManager::interfaces 0</span>

<span class="s0">1</span>
<span class="s0">449 14 get_interfaces 0 258 259 33 ConnectionManager::get_interfaces 0</span>

</pre>
</body>
</html>